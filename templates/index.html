<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="google-client-id" content="{{ GOOGLE_CLIENT_ID }}">
  <meta name="google-api-key" content="{{ GOOGLE_API_KEY }}">
  <meta name="spreadsheet-id" content="{{ SPREADSHEET_ID }}">

  <title>キャスト管理システム v1.4</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    .view {
      display: none;
    }

    .view.active {
      display: block;
    }

    .modal-backdrop {
      background-color: rgba(0, 0, 0, 0.5);
    }

    .gemini-output {
      background-color: #f0f9ff;
      border-left: 4px solid #0284c7;
      padding: 8px;
      font-size: 0.875rem;
      line-height: 1.5;
      color: #0c4a6e;
    }
  </style>
</head>

<body class="bg-gray-100 text-gray-800">

  <header class="bg-white shadow-md sticky top-0 z-40">
    <nav class="container mx-auto px-4 sm:px-6 py-3 flex justify-between items-center">
      <h1 class="text-xl sm:text-2xl font-bold text-gray-800">キャスト管理システム ✨</h1>
      <div class="hidden md:flex items-center space-x-4">
        <button id="nav-casting"
          class="nav-btn text-blue-600 border-b-2 border-blue-600 font-medium px-2 py-1">キャストを探す</button>
        <button id="nav-status"
          class="nav-btn text-gray-600 hover:text-blue-600 font-medium px-2 py-1">キャスティング状況</button>
        <button id="nav-management"
          class="nav-btn text-gray-600 hover:text-blue-600 font-medium px-2 py-1">管理画面</button>
        <button id="nav-cart" class="relative text-gray-600 hover:text-blue-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round"
              d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
          </svg>
          <span id="cart-count"
            class="absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">0</span>
        </button>
      </div>
      <div id="auth-container" class="hidden md:flex items-center">
        <span id="user-name" class="hidden text-sm text-gray-700 mr-4"></span>
        <button id="authorize_button"
          class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition">サインイン</button>
        <button id="signout_button"
          class="hidden bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">サインアウト</button>
      </div>
    </nav>
  </header>

  <main class="container mx-auto p-4 sm:p-6">
    <div id="loader" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50">
      <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500"></div>
      <p class="text-white text-lg ml-4">データを読み込んでいます...</p>
    </div>
    <div id="message-box"
      class="hidden fixed top-20 right-5 bg-green-500 text-white py-2 px-4 rounded-lg shadow-lg z-50"></div>

    <div id="casting-view" class="view">
      <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
        <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-md h-fit">
          <h2 class="text-2xl font-bold mb-4">1. 日付を選択</h2>
          <div id="calendar-container">
            <div class="flex justify-between items-center mb-4">
              <button id="prev-month" class="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">&lt;</button>
              <h3 id="current-month-year" class="text-lg font-semibold"></h3>
              <button id="next-month" class="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">&gt;</button>
            </div>
            <div id="calendar-grid" class="grid grid-cols-7 gap-1 text-center text-sm"></div>
          </div>

          <hr class="my-6">
          <h2 class="text-2xl font-bold mb-4">2. 撮影を選択</h2>
          <div id="shooting-list-container" class="space-y-2 max-h-[60vh] overflow-y-auto">
            <p class="text-gray-500 text-sm">日付を選択すると、候補の撮影が表示されます。</p>
          </div>
        </div>

        <div class="lg:col-span-3">
          <div class="flex items-center justify-between mb-2">
            <h2 class="text-2xl font-bold">3. キャストを選択</h2>
            <div class="inline-flex rounded-lg border text-xs overflow-hidden">
              <button id="view-mode-comfort" class="px-3 py-1 min-w-[3rem] text-center">3列</button>
              <button id="view-mode-dense" class="px-3 py-1 min-w-[3rem] text-center">5列</button>
            </div>
          </div>

          <!-- New Filters Area -->
          <!-- Existing Shootings (Additional Casting) -->
          <div id="shooting-list-container" class="mb-4 hidden"></div>

          <div id="cast-filters-container" class="bg-gray-50 p-4 rounded-lg mb-4 flex flex-wrap gap-4 items-end">
            <!-- Filters will be injected here -->
          </div>

          <p id="selected-period-display" class="text-gray-600 mb-4">カレンダーから日付を選択してください</p>
          <div id="cast-list"
            class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 max-h-[75vh] overflow-y-auto p-2"></div>
        </div>
      </div>
    </div>

    <div id="status-view" class="view">
      <h2 class="text-3xl font-bold mb-4">キャスティング状況</h2>
    </div>

    <div id="management-view" class="view">
      <div id="main-view">
        <!-- content will be injected here -->
      </div>
    </div>
  </main>

  <div id="cart-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="confirmation-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="edit-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="status-quick-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="new-external-cast-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
  </div>
  <div id="shoot-mail-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>

  <div id="progress-modal"
    class="hidden fixed inset-0 z-[60] flex items-center justify-center modal-backdrop bg-black bg-opacity-50">
    <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm text-center">
      <h3 id="progress-title" class="text-lg font-bold text-gray-800 mb-2">処理中...</h3>
      <p id="progress-message" class="text-sm text-gray-600 mb-4">しばらくお待ちください</p>

      <div class="w-full bg-gray-200 rounded-full h-4 mb-2 overflow-hidden">
        <div id="progress-bar-fill" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%">
        </div>
      </div>
      <div id="progress-percent" class="text-xs font-bold text-blue-600">0%</div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // ========= Config =========
      const CLIENT_ID = document.querySelector('meta[name="google-client-id"]')?.content || '';
      const SPREADSHEET_ID = document.querySelector('meta[name="spreadsheet-id"]')?.content || '';
      const API_KEY = document.querySelector('meta[name="google-api-key"]')?.content || '';
      const DISCOVERY_DOCS = [
        "https://sheets.googleapis.com/$discovery/rest?version=v4",
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest",
        "https://www.googleapis.com/discovery/v1/apis/oauth2/v2/rest"
      ];
      const SCOPES = 'https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/documents';

      // ========= State =========
      let tokenClient, gapiInited = false, gisInited = false;
      let currentUser = null, isAdmin = false;
      let castData = [], castingData = [], adminUsers = [];
      let shootingScheduleData = new Map(); // Map<castId, Set<dateString>>
      let cart = {}; // { [castId]: { cast, dates: string[], roleName?: string } }
      let cartMeta = {
        account: '',
        notionUrl: '',
        projectNames: ['', '', ''],
        combinedProjectNames: []
      };
      let cartStep = 1; // 1: STEP1（ヘッダー入力）, 2: STEP2（キャスト紐付け）
      let selectedDates = [];
      let calendarDate = new Date();
      let statusMonth = loadStatusMonth() || new Date();
      let showPast = false;
      let statusOrderWaitOnly = false;
      const ORDER_WAIT_STATUSES = ['オーダー待ち', 'オーダー待ち（仮キャスティング）'];
      let viewMode = 'comfort'; // 'comfort' or 'dense'
      let isAdditionalOrderMode = false;
      let additionalOrderContext = null;
      let shootingContactRows = [];
      let INTERNAL_HOLD_CALENDAR_ID = '';

      const loader = document.getElementById('loader');

      // ========= Helpers =========
      const groupBy = (array, key) => {
        return array.reduce((result, currentValue) => {
          (result[key(currentValue)] = result[key(currentValue)] || []).push(currentValue);
          return result;
        }, {});
      };

      const pad2 = n => String(n).padStart(2, '0');
      const d2str = d => `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
      const TODAY_STR = d2str(new Date());
      const TODAY_EPOCH = toEpochDay(TODAY_STR);

      async function loadConfig() {
        try {
          const res = await fetch('/config');
          if (!res.ok) return;
          const conf = await res.json();
          INTERNAL_HOLD_CALENDAR_ID = conf.calendar_id_internal_hold || '';
        } catch (e) {
          console.warn('Failed to load config', e);
        }
      }

      function showLoader(show) { if (loader) loader.style.display = show ? 'flex' : 'none'; }
      function showMessage(message, type = 'success') {
        const box = document.getElementById('message-box'); if (!box) return;
        box.textContent = message;
        box.className = 'fixed top-20 right-5 text-white py-2 px-4 rounded-lg shadow-lg z-50';
        box.classList.add(type === 'success' ? 'bg-green-500' : (type === 'error' ? 'bg-red-500' : 'bg-blue-500'));
        box.style.display = 'block'; setTimeout(() => { box.style.display = 'none'; }, 3000);
      }
      function updateCartCount() { const el = document.getElementById('cart-count'); if (el) el.textContent = Object.keys(cart).length; }

      function normalizeDateString(input) {
        if (!input) return null; if (typeof input !== 'string') input = String(input);

        // New: Handle MM/DD format
        const md = input.match(/^(\d{1,2})\/(\d{1,2})$/);
        if (md) {
          const year = new Date().getFullYear();
          return `${year}-${pad2(md[1])}-${pad2(md[2])}`;
        }

        const m = input.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})(?:[T\s].*)?$/);
        if (m) return `${m[1]}-${pad2(m[2])}-${pad2(m[3])}`;
        const n = Number(input);
        if (!Number.isNaN(n) && n > 20000 && n < 60000) {
          const epoch = new Date(Date.UTC(1899, 11, 30)); const d = new Date(epoch.getTime() + n * 86400000);
          return d2str(new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())));
        }
        const t = Date.parse(input); if (!Number.isNaN(t)) { const d = new Date(t); return d2str(d); }
        return null;
      }
      function toEpochDay(ymd) {
        if (!ymd) return null;
        const [y, m, d] = ymd.split('-').map(x => parseInt(x, 10));
        return Date.UTC(y, m - 1, d) / 86400000;
      }
      function groupDatesIntoRanges(dates) {
        if (!dates || dates.length === 0) return [];
        const arr = dates.map(normalizeDateString).filter(Boolean).sort();
        const res = []; let start = arr[0], prev = arr[0];
        const next = (s) => { const [y, m, d] = s.split('-').map(n => parseInt(n, 10)); const dt = new Date(Date.UTC(y, m - 1, d) + 86400000); return d2str(new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()))); };
        for (let i = 1; i < arr.length; i++) { if (arr[i] !== next(prev)) { res.push({ start, end: prev }); start = arr[i]; } prev = arr[i]; }
        res.push({ start, end: prev }); return res;
      }
      function overlaps(aStart, aEnd, bStart, bEnd) {
        const as = toEpochDay(aStart), ae = toEpochDay(aEnd), bs = toEpochDay(bStart), be = toEpochDay(bEnd);
        if (as == null || ae == null || bs == null || be == null) return false;
        return !(ae < bs || be < as);
      }
      function saveStatusMonth(d) { localStorage.setItem('status_month', `${d.getFullYear()}-${pad2(d.getMonth() + 1)}`); }
      function loadStatusMonth() {
        const s = localStorage.getItem('status_month'); if (!s) return null;
        const m = s.match(/^(\d{4})[-/](\d{2})$/); if (!m) return null;
        return new Date(parseInt(m[1]), parseInt(m[2]) - 1, 1);
      }

      function calculateAge(dateString) {
        if (!dateString) return null;
        const bd = new Date(dateString), today = new Date();
        let age = today.getFullYear() - bd.getFullYear();
        const mm = today.getMonth() - bd.getMonth();
        if (mm < 0 || (mm === 0 && today.getDate() < bd.getDate())) age--;
        return age;
      }

      function extractNotionPageId(url) {
        if (!url) return "";
        const m = String(url).match(/[0-9a-f]{32}/i);
        if (!m) return "";
        const s = m[0].toLowerCase();
        return `${s.substring(0, 8)}-${s.substring(8, 12)}-${s.substring(12, 16)}-${s.substring(16, 20)}-${s.substring(20)}`;
      }

      function findExistingThreadForOrder(accountName, projectId, dateRanges) {
        // projectId が空の場合は、別案件とみなしてスレッドを再利用しない
        if (!projectId) return null;

        // projectId と accountName が一致し、かつ slackThreadTs を持つレコードを探す
        // 日付の重なりはチェックせず、案件単位でざっくり探す
        const cand = castingData.find(c =>
          c.accountName === accountName &&
          c.projectId === projectId &&
          c.slackThreadTs
        );
        return cand || null;
      }

      function switchView(viewId) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById(viewId)?.classList.add('active');
        document.querySelectorAll('.nav-btn').forEach(b => {
          b.classList.remove('text-blue-600', 'border-b-2', 'border-blue-600');
          if (b.id.includes(viewId.split('-')[0])) b.classList.add('text-blue-600', 'border-b-2', 'border-blue-600');
        });
      }
      function updateSelectedPeriodDisplay() {
        const el = document.getElementById('selected-period-display'); if (!el) return;
        if (selectedDates.length === 0) el.textContent = 'カレンダーから日付を選択してください';
        else if (selectedDates.length === 1) el.textContent = `選択中の日付: ${selectedDates[0]}`;
        else el.textContent = `選択中の期間: ${selectedDates[0]} ~ ${selectedDates[selectedDates.length - 1]} (${selectedDates.length}日間)`;
      }

      // ========= Auth =========
      function gapiLoaded() { gapi.load('client', initializeGapiClient); }
      async function initializeGapiClient() { await gapi.client.init({ apiKey: API_KEY, discoveryDocs: DISCOVERY_DOCS }); gapiInited = true; maybeCheckTokenAndLoad(); }
      function gisLoaded() {
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID, scope: SCOPES,
          callback: (tokenResponse) => {
            if (tokenResponse && tokenResponse.access_token) {
              // ★追加: トークンをセットしてAPI呼び出しに備える
              gapi.client.setToken(tokenResponse);
              localStorage.setItem('gapi_granted', 'true');
              showMessage('ログインしました', 'success');
              // checkLoginStatus(); // This function is not defined in the provided context.
              // Assuming checkLoginStatus() is meant to trigger updateUI(true) or similar.
              // For now, let's call updateUI(true) directly if that's the intent.
              // If it's for a specific login status check, it needs to be defined.
              // Based on the original code, updateUI(true) is called after setting token.
              // Let's keep the original flow for now, but ensure the token is set.

              // Original logic for authResolver/authRejecter
              if (window.authResolver) {
                window.authResolver(tokenResponse);
              }

              if (tokenResponse.error) throw tokenResponse;
              localStorage.setItem('gapi_token', JSON.stringify(tokenResponse));
              // Set Session Start Time if not present (or update on explicit login)
              // Note: We only want to set this on *explicit* login or if missing.
              // But here, this callback runs for both explicit and silent refresh.
              // If we want "1 day from login", we should set it only if it's null?
              // Or if we want "refresh extends session"? No, user said "1 day session".
              // Let's set it if missing. If explicit login (prompt='consent'), we might want to reset it.
              // For now, let's set it if missing.
              if (!localStorage.getItem('session_start')) {
                localStorage.setItem('session_start', Date.now());
              }
              updateUI(true);
            }
          }
        });
        gisInited = true; maybeCheckTokenAndLoad();
      }

      async function ensureAuth() {
        const token = gapi.client.getToken();
        if (token && currentUser) return true; // Valid session

        try {
          await new Promise((resolve, reject) => {
            window.authResolver = resolve;
            window.authRejecter = reject;
            tokenClient.requestAccessToken({ prompt: '' });
          });
          return true;
        } catch (e) {
          console.warn("Silent refresh failed", e);
          return false;
        }
      }
      function maybeCheckTokenAndLoad() {
        if (gapiInited && gisInited) {
          const stored = localStorage.getItem('gapi_token');
          const sessionStart = localStorage.getItem('session_start');
          const ONE_DAY_MS = 24 * 60 * 60 * 1000;

          if (stored && sessionStart) {
            const elapsed = Date.now() - parseInt(sessionStart, 10);
            if (elapsed > ONE_DAY_MS) {
              console.log('Session expired (24h). Clearing token.');
              handleSignoutClick();
              showMessage('セッション有効期限（24時間）が切れました。再度サインインしてください。', 'warning');
              return;
            }
            gapi.client.setToken(JSON.parse(stored));
            updateUI(true);
          }
          else if (stored && !sessionStart) {
            // Legacy session or first run with new code: Treat as new session or expire?
            // Let's start a new session to be user friendly, or expire to be strict.
            // User asked for "1 day session". Let's set start time now.
            localStorage.setItem('session_start', Date.now());
            gapi.client.setToken(JSON.parse(stored));
            updateUI(true);
          }
          else { updateUI(false); showLoader(false); }
        }
      }
      async function updateUI(isAuthorized) {
        const auth = document.getElementById('authorize_button'), out = document.getElementById('signout_button');
        if (auth) auth.style.display = isAuthorized ? 'none' : 'block';
        if (out) out.style.display = isAuthorized ? 'block' : 'none';

        if (isAuthorized) {
          try {
            await getUserProfile();
            await loadConfig();
            await loadAllData();

            // 9. 管理者のみ操作可能にする
            if (isAdmin) {
              document.querySelectorAll('.admin-only').forEach(el => el.classList.remove('hidden'));
            }

            switchView('casting-view');
          }
          catch (err) {
            console.error('Auth/Data failed', err);
            const msg = err.result?.error?.message || err.message || JSON.stringify(err);
            alert(`データ読み込みに失敗しました。\nエラー: ${msg}\n\nOKを押すとサインアウトします。`);
            handleSignoutClick();
          }
        } else {
          currentUser = null; isAdmin = false;
          document.getElementById('user-name')?.classList.add('hidden');
          document.querySelectorAll('.admin-only').forEach(el => el.classList.add('hidden'));
          // Hide all views
          document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
          showMessage('サインインして、キャスト管理を始めましょう。', 'info');
          showLoader(false);
        }
      }
      function handleAuthClick() {
        // Explicit login -> Reset session start
        localStorage.setItem('session_start', Date.now());
        tokenClient?.requestAccessToken({ prompt: 'consent' });
      }
      function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) { google.accounts.oauth2.revoke(token.access_token, () => { }); gapi.client.setToken(''); }
        if (token !== null) { google.accounts.oauth2.revoke(token.access_token, () => { }); gapi.client.setToken(''); }
        localStorage.removeItem('gapi_token');
        localStorage.removeItem('session_start');
        updateUI(false); showMessage('サインアウトしました', 'info');
      }
      async function getUserProfile() {
        const res = await gapi.client.oauth2.userinfo.get(); currentUser = res.result;
        const el = document.getElementById('user-name'); if (el) { el.textContent = `ようこそ ${currentUser.name} さん`; el.classList.remove('hidden'); }
      }

      // ========= Data =========
      async function loadAllData() {
        showLoader(true);
        try {
          const res = await gapi.client.sheets.spreadsheets.values.batchGet({
            spreadsheetId: SPREADSHEET_ID,
            ranges: ['キャストリスト!A2:N', 'キャスティングリスト!A2:T', '権限管理リスト!A2:B', '撮影スケ_キャスト!A2:Z', '新香盤撮影リスト!A2:F', '内部キャストDB!A2:E'],
          });
          const vr = res.result.valueRanges;
          if (!vr || vr.length < 3) throw new Error('必要なシートが見つかりません。');

          // Casts
          // 2-1. キャスト読み込み部分の修正
          const castValues = vr[0].values || [];
          castData = castValues
            .filter(r => r && (r[1]?.trim() || r[0]?.trim()))
            .map((row, idx) => {
              const id = row[0]?.trim() || `cast_${idx + 1}`;
              const name = row[1]?.trim() || `未登録キャスト${idx + 1}`;
              const gender = row[2]?.trim() || '';
              const dob = row[3]?.trim() || '';
              const agency = row[4]?.trim() || 'フリー';
              let imageUrl = row[5]?.trim() || '';
              if (imageUrl && !imageUrl.toLowerCase().startsWith('http')) {
                imageUrl = ''; // Invalid URL, treat as empty
              }
              const appearance = Number.parseInt(row[6], 10);
              const email = row[7]?.trim() || '';
              const notes = row[8]?.trim() || '';
              const castType = row[9]?.trim() || '';

              const isInternal = castType === '内部';
              const slackMentionId = row[10]?.trim() || '';

              // ★追加: SNSリンク (L, M, N)
              const snsX = row[11]?.trim() || '';
              const snsInsta = row[12]?.trim() || '';
              const snsTiktok = row[13]?.trim() || '';

              return {
                castId: id, name, gender, dateOfBirth: dob, age: dob ? calculateAge(dob) : null,
                agency, imageUrl, appearanceCount: Number.isFinite(appearance) ? appearance : 0, email, notes,
                castType,
                isInternal,
                internalType: castType,
                slackMentionId,
                snsX, snsInsta, snsTiktok // ★追加
              };
            });

          // Casting
          // 2-1. キャスティングデータ展開時の修正
          const castMap = new Map(castData.map(c => [c.castId, c]));
          const castingValues = vr[1].values || [];

          castingData = castingValues.map(row => {
            const start = normalizeDateString(row?.[6] || '');
            const end = normalizeDateString(row?.[7] || '');
            const priority = Number.parseInt(row?.[17], 10);
            const castId = row?.[4] || '';

            // ★修正: マップからキャスト情報を取得し、isInternalを設定
            const base = castMap.get(castId);
            const isInternal = base?.isInternal ?? false;

            let slackThreadTs = row?.[11] || '';
            const slackPermalink = row?.[12] || '';

            // もし thread_ts が空 or 10桁の整数っぽい場合は、permalink から復元を試みる
            if ((!slackThreadTs || /^\d{10}$/.test(slackThreadTs)) && slackPermalink) {
              // 例: https://.../p1763537866119239 から 1763537866.119239 を復元
              // クエリパラメータがあってもマッチするように $ を削除
              const m = slackPermalink.match(/p(\d{16})/);
              if (m) {
                const raw = m[1]; // "1763537866119239"
                slackThreadTs = raw.slice(0, 10) + "." + raw.slice(10); // "1763537866.119239"
              }
            }

            return {
              castingId: row?.[0] || '',
              accountName: row?.[1] || '',
              projectName: row?.[2] || '',
              roleName: row?.[3] || '',
              castId: castId,
              castName: row?.[5] || '',
              startDate: start, endDate: end,
              startDay: toEpochDay(start), endDay: toEpochDay(end),
              rank: row?.[8] || '',
              status: row?.[9] || '',
              note: row?.[10] || '',
              slackThreadTs: slackThreadTs,
              slackPermalink: slackPermalink,
              mainSub: row?.[13] || 'その他',     // N列
              calendarEventId: row?.[14] || '', // O列
              projectId: row?.[15] || '',       // P列
              lastUpdated: row?.[16] || '',     // Q列
              updatedBy: row?.[17] || '',       // R列
              castPriority: Number.parseInt(row?.[18], 10), // S列
              isInternal,
              castType: row?.[19] || (isInternal ? '内部' : '外部'), // T列
              email: row?.[20] || '', // U列 (New: Email)
              cost: row?.[21] || '',  // V列 (New: Cost)
              structureData: row?.[22] ? JSON.parse(row[22]) : null // W列 (Structure)
            };
          });

          // Roles (A:email, B:role[admin/viewer])
          const perm = vr[2].values || [];
          const roleByEmail = new Map();
          for (const row of (perm || [])) {
            const email = (row?.[0] || '').trim().toLowerCase();
            const role = (row?.[1] || '').trim().toLowerCase() || 'viewer';
            if (email) roleByEmail.set(email, role);
          }
          const myEmail = (currentUser?.email || '').toLowerCase();
          isAdmin = (roleByEmail.get(myEmail) === 'admin');

          // Shooting Schedule (from new sheet)
          if (vr.length > 3 && vr[3].values) {
            const scheduleValues = vr[3].values || [];
            // Header: Date, Account, Project, Role, Cast, IN, OUT, Location, Address, NotionURL, Emergency
            // Index:  0     1        2        3     4     5   6    7         8        9          10

            shootingScheduleData.clear(); // Map<castId, Set<dateString>>

            // Parse [CastName, Date1, Date2, ...] format? 
            // Wait, the previous code I saw in the diff was parsing `row` which seemed to be `scheduleValues[i]`.
            // Let's assume the structure is what was there before or what I intended.
            // The previous valid code (before my failed edit) was:
            /*
            const scheduleValues = vr[3].values || [];
            shootingScheduleData = new Map();
            scheduleValues.forEach(row => {
              const date = row[0];
              const castName = row[4]; 
              const cast = castData.find(c => c.name === castName);
              if (cast && date) {
                 if (!shootingScheduleData.has(cast.castId)) shootingScheduleData.set(cast.castId, new Set());
                 shootingScheduleData.get(cast.castId).add(normalizeDateString(date));
              }
            });
            */
            // BUT, the code I tried to insert in step 285 was:
            /*
            for (let i = 0; i < scheduleValues.length; i++) {
              const row = scheduleValues[i];
              const castName = row[0]?.trim();
              if (!castName) continue;
              const castObj = castData.find(c => c.name === castName);
              if (!castObj) continue;
              const dates = new Set();
              for (let j = 1; j < row.length; j++) { ... }
            }
            */
            // This suggests the sheet format might be `CastName, Date1, Date2...`. 
            // However, the comment in the code says: `Header: Date, Account, Project, Role, Cast...`
            // I should stick to the format implied by the comments in the file if possible, OR the one that was working.
            // The file content I viewed in Step 282 shows:
            // `// Header: Date, Account, Project, Role, Cast, IN, OUT, Location, Address, NotionURL, Emergency`
            // So I will use that logic.

            shootingScheduleData = new Map();
            scheduleValues.forEach(row => {
              // row[0] is Date, row[4] is CastName
              const date = normalizeDateString(row[0]);
              const castName = row[4]?.trim();
              if (!date || !castName) return;

              const cast = castData.find(c => c.name === castName);
              if (cast) {
                if (!shootingScheduleData.has(cast.castId)) shootingScheduleData.set(cast.castId, new Set());
                shootingScheduleData.get(cast.castId).add(date);
              } else {
                console.warn(`Shooting Schedule: Cast not found for name "${castName}"`);
              }
            });
          }

          // New Shooting List (新香盤撮影リスト)
          if (vr.length > 4 && vr[4].values) {
            const slValues = vr[4].values || [];
            // A:PageID, B:Title, C:Date, D:Team, E:CD, F:FD
            window.shootingListData = slValues.map(row => ({
              pageId: row[0] || '',
              title: row[1] || '',
              date: normalizeDateString(row[2]),
              team: row[3] || '',
              cd: row[4] || '',
              fd: row[5] || ''
            })).filter(item => item.date);
          } else {
            window.shootingListData = [];
          }

          // Internal Cast DB (for Slack CC)
          window.internalCastMap = new Map(); // Name -> UserID
          if (vr.length > 5 && vr[5].values) {
            const icValues = vr[5].values || [];
            // A:Name, E:UserID
            icValues.forEach(row => {
              const name = row[0]?.trim();
              const uid = row[4]?.trim();
              if (name && uid) {
                window.internalCastMap.set(name, uid);
              }
            });
          }

          // Helper to extract NotionID from URL
          function extractNotionIdFromUrl(url) {
            if (!url) return "";
            // Match 32 hex chars (with optional hyphens) usually at the end of path or before query
            // Example: https://www.notion.so/Page-Title-abcdef1234567890abcdef1234567890?pvs=4
            // Regex looks for 32 hex chars
            const match = url.match(/([a-fA-F0-9]{32})/);
            if (match) return match[1];
            return ""; // Return empty if not found
          }
          renderCalendar();
          renderFilters();
          renderShootingList(); // ★Added
          displayAvailableCasts();
        } catch (err) {
          console.error('Data loading error:', err);
          showMessage('データの取得に失敗しました', 'error');
          throw err;
        } finally { showLoader(false); }
      }

      // シート「キャスティングリスト」から最新を再取得
      async function fetchCastingDataFromSheet() {
        const getRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SPREADSHEET_ID,
          range: 'キャスティングリスト!A2:W' // A-W列まで取得 (U:Email, V:Cost, W:Structure)
        });
        const rows = getRes.result.values || [];

        const castMap = new Map(castData.map(c => [c.castId, c])); // マップ再作成

        castingData = rows.map(row => {
          const start = normalizeDateString(row?.[6] || '');
          const end = normalizeDateString(row?.[7] || '');
          const priority = Number.parseInt(row?.[17], 10);
          const castId = row?.[4] || '';

          // ★修正: isInternal の判定
          const base = castMap.get(castId);
          const isInternal = base?.isInternal ?? false;

          let slackThreadTs = row?.[11] || '';
          const slackPermalink = row?.[12] || '';

          // もし thread_ts が空 or 10桁の整数っぽい場合は、permalink から復元を試みる
          if ((!slackThreadTs || /^\d{10}$/.test(slackThreadTs)) && slackPermalink) {
            // 例: https://.../p1763537866119239 から 1763537866.119239 を復元
            // クエリパラメータがあってもマッチするように $ を削除
            const m = slackPermalink.match(/p(\d{16})/);
            if (m) {
              const raw = m[1]; // "1763537866119239"
              slackThreadTs = raw.slice(0, 10) + "." + raw.slice(10); // "1763537866.119239"
            }
          }

          // JSONパース (W列)
          let structureData = [];
          try {
            if (row?.[22]) {
              structureData = JSON.parse(row[22]);
            }
          } catch (e) {
            console.warn("Failed to parse structureData", e);
          }

          return {
            castingId: row?.[0] || '',
            accountName: row?.[1] || '',
            projectName: row?.[2] || '',
            roleName: row?.[3] || '',
            castId: castId,
            castName: row?.[5] || '',
            startDate: start,
            endDate: end,
            startDay: toEpochDay(start),
            endDay: toEpochDay(end),
            rank: row?.[8] || '',
            status: row?.[9] || '',
            note: row?.[10] || '',
            slackThreadTs,
            slackPermalink,
            mainSub: row?.[13] || 'その他',     // N列
            calendarEventId: row?.[14] || '', // O列
            projectId: row?.[15] || '',       // P列
            lastUpdated: row?.[16] || '',     // 旧15 -> 16 (Q列)
            updatedBy: row?.[17] || '',       // 旧16 -> 17 (R列)
            castPriority: Number.parseInt(row?.[18], 10), // 旧17 -> 18 (S列)
            // T列(19) is unused or reserved?
            email: row?.[20] || '',           // U列: Email
            cost: row?.[21] || '',            // V列: Cost
            structureData: structureData,     // W列: Structure
            isInternal,
          };
        });
      }

      // ========= Casting view =========
      function getCastStatusForDates(castId, dates) {
        if (!dates || dates.length === 0) return { isProvisional: false, isConfirmed: false, isShooting: false, isNG: false };
        const targetDates = dates.map(normalizeDateString).filter(v => v != null);
        const targetEpochs = targetDates.map(toEpochDay);

        let isProv = false, isConf = false, isShooting = false, isNG = false;
        const CONFIRM_STATUS = ['決定', 'OK'];
        const NG_STATUS = ['NG']; // ★追加
        const PROV_STATUS = [
          '仮キャスティング',
          'オーダー待ち',
          'オーダー待ち（仮キャスティング）',
          '打診中',
          '条件つきOK',
        ];

        const bookings = castingData.filter(c => c.castId === castId && c.startDay != null && c.endDay != null);

        for (const day of targetEpochs) {
          if (isConf) break;
          for (const b of bookings) {
            if (day >= b.startDay && day <= b.endDay) {
              if (CONFIRM_STATUS.includes(b.status)) {
                isConf = true;
              }
              else if (NG_STATUS.includes(b.status)) {
                isNG = true; // ★NGフラグ
              }
              else if (PROV_STATUS.includes(b.status)) {
                isProv = true;
              }
            }
          }
        }

        // Check shooting schedule if not already confirmed
        if (!isConf) {
          const schedule = shootingScheduleData.get(castId);
          if (schedule) {
            for (const d of targetDates) {
              if (schedule.has(d)) {
                isShooting = true;
                break;
              }
            }
          }
        }

        // Check for 1st/2nd candidates
        let is1st = false, is2nd = false;
        if (isProv) {
          for (const day of targetEpochs) {
            for (const b of bookings) {
              if (day >= b.startDay && day <= b.endDay) {
                if (b.status.includes('第1候補')) is1st = true;
                if (b.status.includes('第2候補')) is2nd = true;
              }
            }
          }
        }

        return { isProvisional: isProv, isConfirmed: isConf, isShooting: isShooting, isNG: isNG, is1st, is2nd };
      }

      function displayAvailableCasts() {
        const list = document.getElementById('cast-list'); if (!list) return;
        list.innerHTML = '';

        // D-2: viewMode に応じて CSS クラスを切り替え
        if (viewMode === 'comfort') {
          list.className = 'grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 max-h-[75vh] overflow-y-auto p-2';
        } else { // dense
          list.className = 'grid grid-cols-2 md:grid-cols-3 xl:grid-cols-5 gap-4 max-h-[75vh] overflow-y-auto p-2';
        }

        // ボタンのスタイル更新
        const comfortBtn = document.getElementById('view-mode-comfort');
        const denseBtn = document.getElementById('view-mode-dense');
        if (comfortBtn && denseBtn) {
          if (viewMode === 'comfort') {
            comfortBtn.classList.add('bg-blue-500', 'text-white');
            comfortBtn.classList.remove('bg-white', 'text-gray-700');
            denseBtn.classList.add('bg-white', 'text-gray-700');
            denseBtn.classList.remove('bg-blue-500', 'text-white');
          } else {
            denseBtn.classList.add('bg-blue-500', 'text-white');
            denseBtn.classList.remove('bg-white', 'text-gray-700');
            comfortBtn.classList.add('bg-white', 'text-gray-700');
            comfortBtn.classList.remove('bg-blue-500', 'text-white');
          }
        }


        if (selectedDates.length === 0) {
          list.innerHTML = `<p class="col-span-full text-center text-gray-500 pt-10">日付を選択すると、キャストが表示されます。</p>`;
          return;
        }

        const filtered = getFilteredCasts();

        // C-1: 「＋新規外部キャスト」カードを常駐
        if (selectedDates.length > 0) {
          const newCard = document.createElement('div');
          newCard.className = 'bg-white rounded-lg shadow-md flex flex-col items-center justify-center border-2 border-dashed border-blue-400 cursor-pointer hover:bg-blue-50';
          newCard.innerHTML = `
        <div class="p-6 flex flex-col items-center justify-center">
          <div class="w-12 h-12 rounded-full border-2 border-blue-400 flex items-center justify-center mb-3">
            <span class="text-2xl text-blue-500">＋</span>
          </div>
          <p class="font-semibold text-blue-600">新規外部キャストを追加</p>
          <p class="text-xs text-gray-500 mt-1 text-center">DBに存在しない外部キャストを作成してからオーダー</p>
        </div>`;
          newCard.addEventListener('click', () => {
            openNewExternalCastModal();
          });
          list.appendChild(newCard);
        }

        if (filtered.length === 0) {
          list.innerHTML += `<p class="col-span-full text-center text-gray-500 pt-10">条件に合うキャストがいません。</p>`;
          return;
        }

        filtered.forEach(cast => {
          const stat = getCastStatusForDates(cast.castId, selectedDates);
          const inCart = !!cart[cast.castId];

          let badge = '', solid = false;
          let badges = [];

          if (stat.isConfirmed) {
            solid = true;
            badges.push(`<span class="bg-red-500 text-white text-xs font-semibold px-2 py-1 rounded-full">決定</span>`);
          } else if (stat.isNG) { // ★NGの場合
            solid = true; // ボタン無効化
            badges.push(`<span class="bg-gray-600 text-white text-xs font-semibold px-2 py-1 rounded-full">NG</span>`);
          } else {
            if (stat.isProvisional) {
              badges.push(`<span class="bg-yellow-400 text-yellow-800 text-xs font-semibold px-2 py-1 rounded-full">仮キャスティング中</span>`);
            }
            if (stat.is1st) {
              badges.push(`<span class="bg-orange-400 text-white text-xs font-semibold px-2 py-1 rounded-full">第1候補あり</span>`);
            }
            if (stat.is2nd) {
              badges.push(`<span class="bg-orange-300 text-white text-xs font-semibold px-2 py-1 rounded-full">第2候補あり</span>`);
            }
            if (stat.isShooting) {
              badges.push(`<span class="bg-cyan-400 text-cyan-800 text-xs font-semibold px-2 py-1 rounded-full">制作稼働あり</span>`);
            }
          }

          const badgeHtml = badges.length > 0 ? `<div class="absolute top-2 right-2 flex flex-col gap-1 items-end">${badges.join('')}</div>` : '';

          const disabled = solid || inCart;
          const buttonLabel = stat.isConfirmed ? 'キャスティング不可' : (stat.isNG ? 'NG' : (inCart ? '仮キャスティング（追加済）' : '仮キャスティング'));

          const meta = []; if (cast.gender) meta.push(cast.gender); if (Number.isFinite(cast.age)) meta.push(`${cast.age}歳`); meta.push(`出演: ${cast.appearanceCount}回`);

          // Helper to format Drive URL for embedding
          function formatDriveUrl(url) {
            if (!url) return "";
            // Check if it's a Drive URL
            if (url.includes("drive.google.com")) {
              // Extract ID
              let id = "";
              const idMatch = url.match(/id=([^&]+)/);
              const fileMatch = url.match(/\/file\/d\/([^/]+)/);

              if (idMatch) id = idMatch[1];
              else if (fileMatch) id = fileMatch[1];

              if (id) {
                // Use thumbnail endpoint which is more permissible for embedding
                // sz=w800 requests a width of 800px
                return `https://drive.google.com/thumbnail?id=${id}&sz=w800`;
              }
            }
            return url;
          }

          const card = document.createElement('div');
          // ★クリック可能にする (cursor-pointer)
          card.className = `bg-white rounded-lg shadow-md overflow-hidden flex flex-col relative ${(solid || inCart) ? 'opacity-50' : ''} cursor-pointer hover:shadow-lg transition-shadow`;

          // ★カード全体クリックイベント
          card.addEventListener('click', (e) => {
            // ボタンクリック時はモーダルを開かない
            if (e.target.closest('.add-to-cart-btn')) return;
            openCastDetailModal(cast.castId);
          });

          const displayUrl = formatDriveUrl(cast.imageUrl);

          card.innerHTML = `
        ${displayUrl ? `<img src="${displayUrl}" alt="${cast.name}" class="w-full h-48 object-cover" referrerpolicy="no-referrer">`
              : `<div class="w-full h-48 bg-gray-300 flex items-center justify-center">
                              <svg class="w-12 h-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                            </div>`}
        ${badgeHtml}
        <div class="p-4 flex-grow flex flex-col">
          <h3 class="text-lg font-bold">${cast.name}</h3>
          <p class="text-sm text-gray-600">${(cast.agency?.trim()) || 'フリー'}</p>
          <div class="mt-2 text-xs text-gray-500">${meta.join(' / ')}</div>
        </div>
        <div class="p-4 pt-0 mt-auto">
          <button data-cast-id="${cast.castId}" class="add-to-cart-btn w-full ${disabled ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600'} text-white font-bold py-2 px-4 rounded-lg transition" ${disabled ? 'disabled' : ''}>${buttonLabel}</button>
          ${(!solid && stat.isShooting) ? '<p class="mt-2 text-xs text-cyan-700">※別件の撮影が入っています。</p>' : ''}
          ${(!solid && stat.isProvisional) ? '<p class="mt-2 text-xs text-amber-700">※仮キャスティングが入っています。</p>' : ''}
        </div>`;
          list.appendChild(card);
        });
      }

      function getFilteredCasts() {
        const kw = document.getElementById('filter-keyword')?.value?.trim()?.toLowerCase() || '';
        const m = document.getElementById('filter-gender-male')?.checked;
        const f = document.getElementById('filter-gender-female')?.checked;
        const minApp = parseInt(document.getElementById('filter-appearance')?.value, 10) || 0;
        const avail = document.getElementById('filter-available-only')?.checked;
        const agencies = Array.from(document.querySelectorAll('#agency-filter-dropdown input[type="checkbox"]:checked')).map(el => el.value);

        const filtered = castData.filter(c => {
          if (kw) {
            const hay = `${c.name || ''}\n${c.agency || ''}\n${c.notes || ''}`.toLowerCase();
            if (!hay.includes(kw)) return false;
          }
          if (m || f) {
            if (m && c.gender === '男性') {/* ok */ }
            else if (f && c.gender === '女性') {/* ok */ }
            else return false;
          }
          if (agencies.length > 0 && !agencies.includes(c.agency || 'フリー')) return false;
          if (c.appearanceCount < minApp) return false;
          if (avail && selectedDates.length > 0) {
            const s = getCastStatusForDates(c.castId, selectedDates);
            if (s.isProvisional || s.isConfirmed) return false;
          }
          return true;
        });

        const byApp = document.getElementById('sort-appearance')?.checked;
        const byKana = document.getElementById('sort-kana')?.checked;
        if (byApp) filtered.sort((a, b) => (b.appearanceCount ?? 0) - (a.appearanceCount ?? 0));
        else if (byKana) filtered.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'ja', { sensitivity: 'base' }));
        return filtered;
      }

      // ========= Status view =========
      // refresh=true: 描画前に必ずシートから再取得
      async function renderCastingStatusView(refresh = false) {
        const view = document.getElementById('status-view');
        if (!view) return;

        if (refresh) {
          try { showLoader(true); await fetchCastingDataFromSheet(); }
          catch (e) { console.error(e); showMessage('ステータスの再取得に失敗しました', 'error'); }
          finally { showLoader(false); }
        }

        const y = statusMonth.getFullYear(), m = statusMonth.getMonth();
        const monthStart = new Date(y, m, 1), monthEnd = new Date(y, m + 1, 0);

        const header = `
      <div class="flex items-center justify-between mb-3">
        <div class="flex items-center gap-2">
          <button id="status-prev-month" class="px-2 py-1 rounded border bg-white">&lt;</button>
          <div class="font-semibold">${y}年${m + 1}月</div>
          <button id="status-next-month" class="px-2 py-1 rounded border bg-white">&gt;</button>
        </div>
        <div class="flex items-center gap-3">
          <label class="inline-flex items-center gap-1 text-sm">
            <input id="status-show-order-wait" type="checkbox" ${statusOrderWaitOnly ? 'checked' : ''} />
            <span>オーダー待ちのみ</span>
          </label>
          <label class="inline-flex items-center gap-1 text-sm">
            <input id="status-show-past" type="checkbox" ${showPast ? 'checked' : ''} />
            <span>過去を表示</span>
          </label>
          <button id="status-reload" class="px-2 py-1 rounded border bg-white text-sm">再読込</button>
        </div>
      </div>`;

        // const ORDER_WAIT_STATUSES = ['オーダー待ち', 'オーダー待ち（仮キャスティング）']; // Moved to global scope

        const grouped = new Map();
        for (const c of castingData) {
          if (!c.startDate || !c.endDate) continue;
          const from = new Date(c.startDate);
          const to = new Date(c.endDate);
          let d = new Date(Math.max(from, monthStart));
          const lastDayInScope = new Date(Math.min(to, monthEnd));

          while (d <= lastDayInScope) {
            const dateKey = d2str(d);
            const epoch = toEpochDay(dateKey);
            if (!showPast && epoch < TODAY_EPOCH) {
              d.setDate(d.getDate() + 1);
              continue;
            }
            if (!grouped.has(dateKey)) grouped.set(dateKey, new Map());
            const dateGroup = grouped.get(dateKey);
            const accountName = c.accountName || 'N/A';
            if (!dateGroup.has(accountName)) dateGroup.set(accountName, new Map());
            const accountGroup = dateGroup.get(accountName);

            // Expand structureData if available
            if (c.structureData && Array.isArray(c.structureData)) {
              c.structureData.forEach(item => {
                const pName = item.project || '未定';
                if (!accountGroup.has(pName)) accountGroup.set(pName, []);
                // Create a virtual record for display
                accountGroup.get(pName).push({
                  ...c,
                  projectName: pName,
                  roleName: item.role || c.roleName,
                  rank: item.rank || c.rank,
                  mainSub: item.type || c.mainSub,
                  note: item.note || c.note
                });
              });
            } else {
              // Fallback for old data (merged)
              const projectName = c.projectName || 'N/A';
              if (!accountGroup.has(projectName)) accountGroup.set(projectName, []);
              accountGroup.get(projectName).push(c);
            }

            d.setDate(d.getDate() + 1);
          }
        }

        const sortedDates = Array.from(grouped.keys()).sort();
        let html = header;
        if (sortedDates.length === 0) {
          html += `<p class="text-gray-600">該当月のキャスティング登録はありません。</p>`;
        } else {
          for (const date of sortedDates) {
            const dateGroup = grouped.get(date);
            let allRecordsInDate = Array.from(dateGroup.values()).flatMap(acc => Array.from(acc.values()).flat());
            const hasOrderWait = allRecordsInDate.some(it => ORDER_WAIT_STATUSES.includes(it.status));
            if (statusOrderWaitOnly && !hasOrderWait) continue;

            html += `
          <div class="mt-6 border rounded-lg overflow-hidden status-date-group" data-date-block="${date}">
            <div class="flex items-center justify-between p-2 cursor-pointer date-header ${hasOrderWait ? 'bg-orange-50' : 'bg-gray-200'}" data-date-header="${date}">
              <h3 class="text-xl font-bold">${date}</h3>
              <button type="button" class="toggle-day flex items-center text-sm text-gray-700" data-toggle-date="${date}">
                <span class="toggle-icon mr-1">▼</span>
                <span>詳細</span>
              </button>
            </div>
            <div class="date-body p-2 bg-white" data-date-body="${date}">`;

            const sortedAccounts = Array.from(dateGroup.keys()).sort();
            for (const account of sortedAccounts) {
              const accountGroup = dateGroup.get(account);
              const allRecordsInAccount = Array.from(accountGroup.values()).flat();
              const baseRec = allRecordsInAccount.find(r => r.slackThreadTs);

              let accountHtml = `<div class="ml-2 border-l-2 border-gray-300 pl-4 py-2">
            <div class="flex items-center justify-between mb-1">
              <h4 class="text-lg font-semibold text-gray-800">${account}</h4>
              ${baseRec ? `
                <button
                  class="text-xs px-2 py-1 bg-emerald-100 hover:bg-emerald-200 text-emerald-800"
                  data-add-order="1"
                  data-date="${date}"
                  data-account="${account}"
                  data-project-id="${baseRec.projectId || ''}"
                  data-thread-ts="${baseRec.slackThreadTs || ''}"
                  data-permalink="${baseRec.slackPermalink || ''}"
                >
                  ＋追加キャスト
                </button>
              ` : ''}
            </div>`;

              let hasContentForAccount = false;
              const sortedProjects = Array.from(accountGroup.keys()).sort();
              for (const project of sortedProjects) {
                let records = accountGroup.get(project);
                if (statusOrderWaitOnly) {
                  records = records.filter(it => ORDER_WAIT_STATUSES.includes(it.status));
                }
                if (records.length === 0) continue;
                hasContentForAccount = true;

                accountHtml += `<div class="ml-4 mt-2">
              <h5 class="font-medium text-gray-700 mb-1">${project}</h5>`;

                const tableRows = records.map(it => {
                  const cast = castData.find(c => c.castId === it.castId);
                  const castName = cast?.name || it.castId;
                  const badgeClass = it.status === '決定' ? 'bg-red-100 text-red-700' : it.status === 'キャンセル' ? 'bg-gray-200 text-gray-700' : it.status === '打診中' ? 'bg-blue-100 text-blue-700' : it.status === '条件つきOK' ? 'bg-emerald-100 text-emerald-700' : it.status === 'NG' ? 'bg-gray-300 text-gray-800' : ORDER_WAIT_STATUSES.includes(it.status) ? 'bg-amber-100 text-amber-800' : 'bg-yellow-100 text-yellow-800';
                  const rowMutedClass = it.status === 'NG' ? 'opacity-50' : '';

                  // Order Wait の場合は金額編集可能に
                  let costDisplay = it.cost ? '¥' + Number(it.cost).toLocaleString() : '-';
                  let actionCol = '';

                  if (ORDER_WAIT_STATUSES.includes(it.status)) {
                    costDisplay = `
                      <input type="text" class="status-cost-input border rounded px-1 py-0.5 text-xs w-20 text-right bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                             value="${it.cost || ''}" placeholder="¥">
                    `;
                    actionCol = `
                      <button class="px-2 py-1 bg-emerald-600 text-white rounded text-xs hover:bg-emerald-700 shadow-sm whitespace-nowrap"
                          onclick="saveCastingCost('${it.castingId}', '${it.status}', this)">
                          保存
                      </button>
                    `;
                  }

                  return `
                <tr class="border-b hover:bg-gray-50 casting-row ${rowMutedClass}" data-casting-id="${it.castingId}">
                  <td class="py-2 px-2">${it.roleName || '-'}</td>
                  <td class="py-2 px-2 text-center">${it.rank || '-'}</td>
                  <td class="py-2 px-2 text-center">${it.mainSub || '-'}</td>
                  <td class="py-2 px-2">${castName}</td>
                  <td class="py-2 px-2"><span class="inline-block text-xs px-2 py-1 rounded-full ${badgeClass}">${it.status || '-'}</span></td>
                  <td class="py-2 px-2 text-right">${costDisplay}</td>
                  <td class="py-2 px-2 text-xs text-gray-600">${it.note || ''}</td>
                  <td class="py-2 px-2 text-center">${actionCol}</td>
                </tr>`;
                }).join('');

                accountHtml += `
              <div class="overflow-x-auto bg-white rounded-lg shadow-sm">
                <table class="min-w-full text-sm table-fixed">
                  <thead class="bg-gray-100">
                    <tr>
                      <th class="text-left py-2 px-2 w-24">役名</th>
                      <th class="text-center py-2 px-2 w-12">役候補</th>
                      <th class="text-center py-2 px-2 w-16">区分</th>
                      <th class="text-left py-2 px-2 w-32">キャスト</th>
                      <th class="text-left py-2 px-2 w-40">ステータス</th>
                      <th class="text-right py-2 px-2 w-24">金額</th>
                      <th class="text-left py-2 px-2">備考</th>
                      <th class="text-center py-2 px-2 w-16">保存</th>
                    </tr>
                  </thead>
                  <tbody>${tableRows}</tbody>
                </table>
              </div>`;
                accountHtml += `</div>`;
              }
              accountHtml += `</div>`;
              if (hasContentForAccount) html += accountHtml;
            }
            html += `</div></div>`;
          }
        }

        view.innerHTML = html;

        view.querySelector('#status-prev-month')?.addEventListener('click', async () => { statusMonth.setMonth(statusMonth.getMonth() - 1); saveStatusMonth(statusMonth); await renderCastingStatusView(true); });
        view.querySelector('#status-next-month')?.addEventListener('click', async () => { statusMonth.setMonth(statusMonth.getMonth() + 1); saveStatusMonth(statusMonth); await renderCastingStatusView(true); });
        view.querySelector('#status-show-past')?.addEventListener('change', async e => { showPast = !!e.target.checked; await renderCastingStatusView(false); });
        view.querySelector('#status-show-order-wait')?.addEventListener('change', async e => { statusOrderWaitOnly = !!e.target.checked; await renderCastingStatusView(false); });
        view.querySelector('#status-reload')?.addEventListener('click', async () => { await renderCastingStatusView(true); });

        view.querySelectorAll('.date-header, .toggle-day').forEach(el => {
          el.addEventListener('click', (e) => {
            if (e.target.closest('button, a, input, select, textarea')) {
              if (e.target.closest('.toggle-day')) { } else { return; }
            }
            const date = el.getAttribute('data-date-header') || el.getAttribute('data-toggle-date');
            if (!date) return;
            const body = view.querySelector(`.date-body[data-date-body="${date}"]`);
            const icon = view.querySelector(`.toggle-day[data-toggle-date="${date}"] .toggle-icon`);
            if (!body) return;
            body.classList.toggle('hidden');
            if (icon) icon.textContent = body.classList.contains('hidden') ? '▶' : '▼';
          });
        });

        if (isAdmin) {
          view.querySelectorAll('.casting-row').forEach(row => {
            row.addEventListener('click', e => {
              if (e.target.closest('button, input')) return;
              const id = row.getAttribute('data-casting-id');
              if (id) handleCastingRowClick(id);
            });
          });
          view.querySelectorAll('[data-add-order="1"]').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const ds = e.currentTarget.dataset;
              // Rename startAdditionalOrder to openAdditionalOrderModal
              startAdditionalOrder({
                date: ds.date,
                accountName: ds.account,
                projectId: ds.projectId,
                slackThreadTs: ds.threadTs,
                slackPermalink: ds.permalink,
              });
            });
          });
        }
      }

      // ==== Admin: status change & edit ====

      // 2-3. postStatusUpdateToSlack の修正
      async function postStatusUpdateToSlack(rec, newStatus, extraMessage) {
        try {
          // 内部キャストはSlack通知しないが、Notion連携のためにAPIは叩く
          // if (rec.isInternal) return; // Removed to allow Notion sync

          const payload = {
            castingId: rec.castingId,
            newStatus,
            castName: rec.castName || rec.castId || "",
            slackThreadTs: rec.slackThreadTs,
            slackPermalink: rec.slackPermalink || "",
            extraMessage: extraMessage || "",
            isInternal: !!rec.isInternal,
            projectId: rec.projectId || "", // Notion Page ID
            mainSub: rec.mainSub || "その他", // Cast Type
            orderDetails: rec.structureData || [] // ★追加: W列のデータを送る
          };

          const res = await fetch("/api/notify/status_update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            console.error("Slack status update notify failed", err);
            showMessage("Slackへのステータス更新通知に失敗しました。", "error");
            return;
          }

        } catch (e) {
          console.error("Slack status update notify exception", e);
          showMessage("Slackへのステータス更新通知でエラーが発生しました。", "error");
        }
      }
      // ★ 差し替え：changeCastingStatus 全体
      async function changeCastingStatus(castingId, newStatus, extraArg = "") {
        if (!isAdmin) {
          showMessage('権限がありません。', 'error');
          return;
        }

        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) {
          showMessage('対象が見つかりません。', 'error');
          return;
        }

        // ★ 修正ポイント1: 引数がオブジェクトの場合（クイックモード）と文字列の場合でメッセージを抽出
        let finalExtraMessage = "";
        let options = {}; // Define options to avoid ReferenceError

        if (typeof extraArg === 'object' && extraArg !== null) {
          finalExtraMessage = extraArg.extraMessage || "";
          options = extraArg; // Assign extraArg to options
        } else {
          finalExtraMessage = extraArg || "";
        }

        // 変更前ステータスを保持
        const prevStatus = rec.status;

        showLoader(true);
        try {
          // 行番号取得
          const getRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'キャスティングリスト!A2:R'
          });
          const rows = getRes.result.values || [];
          let rowIdx = -1;
          for (let i = 0; i < rows.length; i++) {
            if (rows[i]?.[0] === castingId) {
              rowIdx = i;
              break;
            }
          }
          if (rowIdx === -1) {
            showMessage('対象が見つかりません。', 'error');
            return;
          }
          const targetRow = rowIdx + 2;

          // ステータス(J列) と 金額(V列) を更新
          const updates = [
            {
              range: `キャスティングリスト!J${targetRow}`,
              values: [[newStatus]]
            }
          ];

          // options.cost があれば V列も更新
          if (options && options.cost !== undefined) {
            updates.push({
              range: `キャスティングリスト!V${targetRow}`,
              values: [[options.cost]]
            });
            // ローカルも更新
            rec.cost = options.cost;
          }

          await gapi.client.sheets.spreadsheets.values.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: {
              valueInputOption: 'USER_ENTERED',
              data: updates
            }
          });

          // ローカルデータ更新
          rec.status = newStatus;

          // カレンダー側も同期
          await updateCalendarEventOnStatusChange(rec, newStatus, targetRow);

          // ===== Slack 通知ロジック =====
          // 内部/外部フラグ（rec.isInternal プロパティを使用）
          const isInternalCast = rec.isInternal;
          const isExternal = !isInternalCast;

          const isFromDashing = (prevStatus === '打診中');
          const isFinal = ['決定', 'NG', '条件つきOK'].includes(newStatus);

          // 外部キャストかつ、「打診中」→「最終ステータス」への変更時のみ通知
          if (isExternal && isFromDashing && isFinal && rec.slackThreadTs) {
            const statusForSlack = newStatus === '決定' ? 'OK' : newStatus;
            await postStatusUpdateToSlack(rec, statusForSlack, finalExtraMessage);
          }

          // 「決定」の時だけ撮影連絡DBへ追加（外部キャストのみ）
          if (rec.isInternal) {
          }
          if ((newStatus === "決定" || newStatus === "OK") && !rec.isInternal) {
            const updaterEmail = currentUser?.email || '';

            // 香盤DBからデータを検索
            const scheduleKey = `${rec.castId}_${rec.startDate}`;
            const scheduleInfo = shootingScheduleData.get(scheduleKey) || {};

            try {
              const addRes = await fetch("/api/shooting_contact/add", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  castingId: rec.castingId,
                  account: rec.accountName,
                  projectName: rec.projectName,
                  notionId: rec.projectId, // Use original Project ID (Notion Page ID)
                  roleName: rec.roleName,
                  castName: rec.castName,
                  castType: rec.isInternal ? "内部" : "外部",
                  shootDate: rec.startDate,
                  note: rec.note || "",
                  updatedBy: updaterEmail,
                  updatedAt: new Date().toISOString(),
                  mainSub: rec.mainSub || "その他",
                  cost: rec.cost || "" // ★追加: 金額
                })
              });
              if (!addRes.ok) {
                console.error("Failed to add to shooting contact DB", await addRes.text());
              } else {
              }
            } catch (err) {
              console.error("Exception calling shooting_contact/add", err);
            }
          }

          showMessage('ステータスを更新しました。');
          await renderCastingStatusView(false);
          displayAvailableCasts();
        } catch (e) {
          console.error(e);
          showMessage('更新に失敗しました。', 'error');
        } finally {
          showLoader(false);
        }
      }
      async function openEditModal(castingId) {
        if (!isAdmin) { showMessage('権限がありません。', 'error'); return; }
        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) { showMessage('対象が見つかりません。', 'error'); return; }

        const modal = document.getElementById('edit-modal'); if (!modal) return;
        modal.innerHTML = `
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full p-5">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-bold">キャスティング編集</h3>
          <button id="edit-close" class="text-gray-600 hover:text-gray-800">&times;</button>
        </div>
        <div class="space-y-3">
          <div>
            <label class="text-sm text-gray-700">作品名</label>
            <input id="edit-project" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.projectName || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">役名</label>
            <input id="edit-role" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.roleName || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">区分</label>
            <select id="edit-mainsub" class="mt-1 w-full p-2 border rounded-md">
              <option value="その他" ${rec.mainSub === 'その他' ? 'selected' : ''}>その他</option>
              <option value="メイン" ${rec.mainSub === 'メイン' ? 'selected' : ''}>メイン</option>
            </select>
          </div>
          <div>
            <label class="text-sm text-gray-700">キャス優先度</label>
            <input id="edit-priority" type="number" min="1" class="mt-1 w-full p-2 border rounded-md" value="${rec.castPriority || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">担当者</label>
            <input id="edit-bookedby" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.updatedBy || currentUser?.email || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">金額</label>
            <input id="edit-cost" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.cost || ''}" placeholder="金額を入力">
          </div>
          <div>
            <label class="text-sm text-gray-700">ステータス</label>
            <select id="edit-status" class="mt-1 w-full p-2 border rounded-md">
              ${[
            'オーダー待ち',
            '打診中',
            '決定',
            'NG',
            '条件つきOK',
            '仮キャスティング',
          ].map(s => `<option value="${s}" ${rec.status === s ? 'selected' : ''}>${s}</option>`).join('')}
            </select>
             <p class="text-xs text-gray-500 mt-1">
              ※「条件つきOK」を選んだ場合、下のコメント欄も入力できます。
            </p>
          </div>
          <div id="edit-status-comment-wrap" class="mt-2 ${rec.status === '条件つきOK' ? '' : 'hidden'}">
            <label class="text-sm text-gray-700">条件つきOKコメント</label>
            <textarea id="edit-status-comment" class="mt-1 w-full p-2 border rounded-md" rows="3"
              placeholder="条件や注意事項などを入力してください"></textarea>
          </div>
        </div>
        <div class="mt-4 flex justify-end gap-3">
          <button id="edit-cancel" class="px-4 py-2 rounded-md border border-gray-300">閉じる</button>
          <button id="edit-save" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">保存</button>
        </div>
      </div>`;
        modal.classList.remove('hidden');

        const statusSelect = modal.querySelector('#edit-status');
        const commentWrap = modal.querySelector('#edit-status-comment-wrap');
        if (statusSelect && commentWrap) {
          statusSelect.addEventListener('change', () => {
            if (statusSelect.value === '条件つきOK') {
              commentWrap.classList.remove('hidden');
            } else {
              commentWrap.classList.add('hidden');
            }
          });
        }

        modal.querySelector('#edit-close')?.addEventListener('click', closeEditModal);
        modal.querySelector('#edit-cancel')?.addEventListener('click', closeEditModal);
        modal.querySelector('#edit-save')?.addEventListener('click', async () => {
          await saveEdit(castingId);
        });
      }
      function closeEditModal() { const modal = document.getElementById('edit-modal'); if (!modal) return; modal.classList.add('hidden'); modal.innerHTML = ''; }

      function startAdditionalOrder(context) {
        const { date, accountName, projectId, slackThreadTs, slackPermalink } = context;
        if (!slackThreadTs) {
          showMessage('追加オーダーの元となる有効なオーダーが見つかりません。', 'error');
          return;
        }

        // 代表レコードを探して、プロジェクト名などを取得
        const rec = castingData.find(c => c.accountName === accountName && c.projectId === projectId && c.slackThreadTs === slackThreadTs);
        if (!rec) {
          showMessage('追加オーダーの元となる代表レコードが見つかりません。', 'error');
          return;
        }

        isAdditionalOrderMode = true;
        additionalOrderContext = {
          accountName: accountName,
          projectName: rec.projectName, // 代表レコードのプロジェクト名を使う
          projectId: projectId,
          slackThreadTs: slackThreadTs,
          slackPermalink: slackPermalink,
          startDate: date, // この日のオーダー
          endDate: date,
        };

        // cart = {}; // Do NOT clear cart (User might have selected casts)
        const projectNames = rec.projectName.split('/');
        const notionPageId = projectId.replace(/-/g, '');
        cartMeta = {
          account: accountName,
          notionUrl: notionPageId ? `https://www.notion.so/${notionPageId}` : '',
          projectNames: [projectNames[0] || '', projectNames[1] || '', projectNames[2] || ''],
          combinedProjectNames: rec.projectName.includes('/') ? [rec.projectName] : []
        };

        // Populate cartProjects with inherited project name
        // If cartProjects is empty (or default), replace it?
        // Or just add?
        // "その作品名...を引き継いで" -> likely we want to start with that project.
        cartProjects = [{
          id: 'proj_' + Date.now(),
          title: rec.projectName, // Inherit Project Name
          roles: []
        }];
        // Add default roles
        for (let i = 0; i < 3; i++) {
          cartProjects[0].roles.push({
            id: 'role_' + Date.now() + '_' + i,
            name: '',
            type: 'その他',
            note: '',
            castIds: []
          });
        }

        updateCartCount();

        selectedDates = [date];

        switchView('casting-view');

        renderCalendar();
        updateSelectedPeriodDisplay();
        displayAvailableCasts();

        showMessage(`追加オーダーモードを開始しました：${accountName} / ${date}`, 'info');
      }

      function handleCastingRowClick(castingId) {
        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) return;

        // 内部キャストは常に「編集モーダル」を開く（今まで通り）
        if (rec.isInternal) {
          openStatusQuickModal(castingId);
          return;
        }

        // 外部キャスト ＋ ステータスが「オーダー待ち」のときだけ
        // 1回目のクリックで「打診メール作成ポップアップ」を開く
        if (rec.status === "オーダー待ち") {
          openShootMailModal(castingId); // Use the new unified mail modal
          return;
        }

        // 外部キャスト ＋ 「打診中 / 決定 / NG / 条件つきOK など」
        // → ステータス更新用のクイックモーダルを開く
        openStatusQuickModal(castingId);
      }
      function openExternalOrderMailModal(rec) {
        const modal = document.getElementById('edit-modal');
        modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl max-w-lg w-full p-6">
      <h3 class="text-xl font-bold mb-4">外部キャスト：打診メール作成</h3>

      <textarea id="external-mail-body" class="w-full h-48 p-2 border rounded-md text-sm leading-relaxed">
${buildExternalMailBody(rec)}
      </textarea>

      <div class="mt-6 flex justify-end gap-3">
        <button id="external-mail-cancel" class="px-4 py-2 rounded-md border border-gray-300">閉じる</button>
        <button id="external-mail-send" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">打診メール送信済みにする</button>
      </div>
    </div>
  `;
        modal.classList.remove("hidden");

        document.getElementById("external-mail-cancel")?.addEventListener("click", closeEditModal);
        document.getElementById("external-mail-send")?.addEventListener("click", async () => {
          await changeCastingStatus(rec.castingId, "打診中");
          closeEditModal();
        });
      }

      function buildExternalMailBody(rec) {
        return `
◯◯事務所 御中

いつもお世話になっております。
株式会社GOKKO の ${rec.updatedBy || "担当者"} です。

以下の内容でキャスティングのご相談がございます。

■アカウント
${rec.accountName}

■作品名
${rec.projectName}

■役名／候補キャスト
${rec.roleName}：${rec.castName}

■撮影日
${rec.startDate}${rec.startDate !== rec.endDate ? ` ～ ${rec.endDate}` : ""}

■備考
${rec.note || "なし"}

ご確認のほど、何卒よろしくお願いいたします。
  `.trim();
      }

      async function updateCalendarEventOnStatusChange(rec, newStatus, rowNumber) {
        try {
          if (!INTERNAL_HOLD_CALENDAR_ID) return;
          if (!rec.calendarEventId) return;

          // ---- NG の場合は予定を削除する -------------------------
          if (newStatus === 'NG') {
            try {
              await gapi.client.calendar.events.delete({
                calendarId: INTERNAL_HOLD_CALENDAR_ID,
                eventId: rec.calendarEventId,
              });
            } catch (e) {
              // 404（すでに削除済み）の場合は無視、それ以外はログだけ残す
              if (!(e && e.status === 404)) {
                console.error('カレンダー予定削除に失敗:', e);
              }
            }

            // シートの N列(calendarEventId)を空にする
            if (rowNumber) {
              try {
                await gapi.client.sheets.spreadsheets.values.batchUpdate({
                  spreadsheetId: SPREADSHEET_ID,
                  resource: {
                    valueInputOption: 'USER_ENTERED',
                    data: [
                      {
                        range: `キャスティングリスト!N${rowNumber}`,
                        values: [['']],
                      },
                    ],
                  },
                });
              } catch (e) {
                console.error('calendarEventId のクリアに失敗:', e);
              }
            }

            // ローカルデータもクリア
            rec.calendarEventId = '';
            return; // ここで終了（決定タイトルなどの更新は行わない）
          }

          // ---- それ以外のステータスは既存通り「更新」ロジック ----

          // 現在のイベント取得
          const getRes = await gapi.client.calendar.events.get({
            calendarId: INTERNAL_HOLD_CALENDAR_ID,
            eventId: rec.calendarEventId,
          });
          const event = getRes.result;

          // サマリー：決定のときだけ特別な文言
          const summary =
            newStatus === '決定'
              ? `${rec.accountName || 'アカウント未設定'}_決定キャスティング`
              : (event.summary ||
                `${rec.accountName || 'アカウント未設定'}_${rec.rank || ''}候補_${newStatus}`);

          // 説明文の「ステータス」行を差し替え
          let description = event.description || '';
          const statusLineRe = /・ステータス: .*/;
          if (statusLineRe.test(description)) {
            description = description.replace(statusLineRe, `・ステータス: ${newStatus}`);
          } else {
            description += (description ? '\n' : '') + `・ステータス: ${newStatus}`;
          }

          await gapi.client.calendar.events.patch({
            calendarId: INTERNAL_HOLD_CALENDAR_ID,
            eventId: rec.calendarEventId,
            resource: {
              summary,
              description,
            },
          });
        } catch (e) {
          console.error('カレンダー予定更新に失敗:', e);
          // UI側の挙動は継続させたいので、ここでは例外を投げずログのみにする
        }
      }

      async function saveEdit(castingId) {
        if (!isAdmin) { showMessage('権限がありません。', 'error'); return; }
        const rec = castingData.find(c => c.castingId === castingId); if (!rec) { showMessage('対象が見つかりません。', 'error'); return; }
        const prevStatus = rec.status; // 変更前のステータスを保持

        const modal = document.getElementById('edit-modal');
        const newProject = modal.querySelector('#edit-project')?.value?.trim() || '';
        const newRole = modal.querySelector('#edit-role')?.value?.trim() || '';
        const newMainSub = modal.querySelector('#edit-mainsub')?.value || 'その他';
        const newPriorityRaw = modal.querySelector('#edit-priority')?.value;
        const newPriority = Number.isFinite(parseInt(newPriorityRaw, 10)) ? parseInt(newPriorityRaw, 10) : '';
        const newCost = modal.querySelector('#edit-cost')?.value?.trim() || ''; // Cost
        const newBooked = modal.querySelector('#edit-bookedby')?.value?.trim() || ''; // This is now 'updater'
        const newStatus = modal.querySelector('#edit-status')?.value || rec.status;
        const commentEl = modal.querySelector('#edit-status-comment');
        const commentText = commentEl ? (commentEl.value || '') : '';

        showLoader(true);
        try {
          // 行番号探索
          const getRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID, range: 'キャスティングリスト!A2:R'
          });
          const rows = getRes.result.values || [];
          let rowIdx = -1; for (let i = 0; i < rows.length; i++) { if (rows[i]?.[0] === castingId) { rowIdx = i; break; } }
          if (rowIdx === -1) { showMessage('対象が見つかりません。', 'error'); return; }
          const targetRow = rowIdx + 2;

          const updates = [
            { range: `キャスティングリスト!C${targetRow}`, values: [[newProject]] },
            { range: `キャスティングリスト!D${targetRow}`, values: [[newRole]] },
            { range: `キャスティングリスト!J${targetRow}`, values: [[newStatus]] },
            { range: `キャスティングリスト!N${targetRow}`, values: [[newMainSub]] }, // N列: mainSub
            { range: `キャスティングリスト!Q${targetRow}`, values: [[newBooked]] }, // Updater
            { range: `キャスティングリスト!R${targetRow}`, values: [[newPriority]] }, // Cast Priority
            { range: `キャスティングリスト!V${targetRow}`, values: [[newCost]] }, // V列: Cost
          ];

          await gapi.client.sheets.spreadsheets.values.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: { valueInputOption: 'USER_ENTERED', data: updates }
          });

          // ローカル反映
          rec.projectName = newProject; rec.roleName = newRole; rec.updatedBy = newBooked; rec.status = newStatus; rec.castPriority = newPriority; rec.mainSub = newMainSub; rec.cost = newCost;

          // Slack 通知は外部キャストかつ「打診中 → 最終ステータス」への遷移だけ
          const isExternal = !rec.isInternal;
          const isFromDashing = (prevStatus === "打診中");
          const isFinal = ["決定", "NG", "条件つきOK"].includes(newStatus);

          if (isExternal && isFromDashing && isFinal) {
            const statusForSlack = newStatus === '決定' ? 'OK' : newStatus;
            await postStatusUpdateToSlack(rec, statusForSlack, commentText);
          }

          await updateCalendarEventOnStatusChange(rec, newStatus, targetRow);

          closeEditModal();
          showMessage('更新しました。');
          await renderCastingStatusView(false); // Do not force reload, just re-render
          displayAvailableCasts();
        } catch (e) {
          console.error(e); showMessage('更新に失敗しました。', 'error');
        } finally { showLoader(false); }
      }


      function openStatusQuickModal(castingId) {
        if (!isAdmin) { showMessage('権限がありません。', 'error'); return; }
        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) { showMessage('対象が見つかりません。', 'error'); return; }

        const modal = document.getElementById('status-quick-modal');
        if (!modal) return;

        const cast = castData.find(c => c.castId === rec.castId);
        const castName = cast?.name || rec.castName || rec.castId || '';
        const currentStatus = rec.status || '';

        // ★修正: シンプルなセレクトボックス形式のHTMLに差し替え
        modal.innerHTML = `
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full p-5">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-bold">ステータス更新</h3>
          <button id="status-quick-close" class="text-gray-600 hover:text-gray-800">&times;</button>
        </div>
        
        <div class="text-sm text-gray-700 mb-4 border-b pb-3">
          <div>作品：${rec.projectName || '-'}</div>
          <div>役名：${rec.roleName || '-'}</div>
          <div>氏名：${castName}</div>
          <div class="mt-1 text-xs text-gray-500">現在：${currentStatus}</div>
        </div>

        <div class="space-y-3 text-sm">
          <div>
            <label class="block text-xs font-medium text-gray-600 mb-1">
              ステータス
            </label>
            <select
              id="status-edit-status"
              class="w-full border rounded px-2 py-1 text-sm"
            >
              <option value="決定" ${currentStatus === '決定' || currentStatus === 'OK' ? 'selected' : ''}>OK（決定）</option>
              <option value="NG" ${currentStatus === 'NG' ? 'selected' : ''}>NG</option>
              <option value="条件つきOK" ${currentStatus === '条件つきOK' ? 'selected' : ''}>条件つきOK</option>
              <option value="オーダー待ち" ${currentStatus === 'オーダー待ち' ? 'selected' : ''}>オーダー待ち</option>
              <option value="打診中" ${currentStatus === '打診中' ? 'selected' : ''}>打診中</option>
            </select>
          </div>

          <div>
            <label class="block text-xs font-medium text-gray-600 mb-1">
              金額
            </label>
            <input
              type="text"
              id="status-edit-cost"
              class="w-full border rounded px-2 py-1 text-sm text-right"
              placeholder="¥"
              value="${rec.cost || ''}"
            >
          </div>

          <div
            id="status-edit-extra-message-wrapper"
            class="space-y-1 ${currentStatus === "条件つきOK" ? "" : "hidden"}"
          >
            <label class="block text-xs font-medium text-gray-600">
              条件メモ（Slackに一緒に送信されます）
            </label>
            <textarea
              id="status-edit-extra-message"
              rows="3"
              class="w-full border rounded px-2 py-1 text-xs"
              placeholder="例）・条件：◯◯はNG、△△の場合のみ出演可能 など"
            ></textarea>
          </div>
        </div>

        <div class="mt-6 flex justify-end gap-3">
          <button id="status-quick-cancel" class="px-4 py-2 rounded-md border border-gray-300">キャンセル</button>
          <button id="status-quick-save" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">更新</button>
        </div>
      </div>`;

        modal.classList.remove('hidden');

        // ★イベントリスナー設定
        const statusSelect = modal.querySelector("#status-edit-status");
        const costInput = modal.querySelector("#status-edit-cost");
        const extraMessageWrapper = modal.querySelector("#status-edit-extra-message-wrapper");
        const extraMessageInput = modal.querySelector("#status-edit-extra-message");

        // ステータス変更時の表示切り替え
        statusSelect.addEventListener("change", () => {
          if (statusSelect.value === "条件つきOK") {
            extraMessageWrapper.classList.remove("hidden");
          } else {
            extraMessageWrapper.classList.add("hidden");
          }
        });

        // 閉じる・キャンセルボタン
        modal.querySelector('#status-quick-close')?.addEventListener('click', closeStatusQuickModal);
        modal.querySelector('#status-quick-cancel')?.addEventListener('click', closeStatusQuickModal);

        // 更新ボタン（シンプル化した取得ロジック）
        modal.querySelector('#status-quick-save')?.addEventListener('click', async () => {
          const newStatus = statusSelect.value;
          const newCost = costInput.value.trim();
          const extraMessage = extraMessageInput.value || "";

          // API呼び出し
          // changeCastingStatus needs to support cost update.
          // Currently it calls /api/notify/status_update AND updates sheet.
          // But changeCastingStatus implementation (lines 1200+) might not handle Cost update to sheet.
          // Let's check changeCastingStatus.
          // If it doesn't, we might need to call saveEdit logic or update changeCastingStatus.
          // For now, let's pass cost to changeCastingStatus and ensure it handles it.
          await changeCastingStatus(rec.castingId, newStatus, {
            quick: true,
            extraMessage: extraMessage,
            cost: newCost
          });

          closeStatusQuickModal();
        });
      }

      function closeStatusQuickModal() {
        const modal = document.getElementById('status-quick-modal');
        if (!modal) return;
        modal.classList.add('hidden');
        modal.innerHTML = '';
      }

      // ========= Calendar (today red) =========
      function renderCalendar() {
        const monthYearEl = document.getElementById('current-month-year');
        const grid = document.getElementById('calendar-grid');
        if (!monthYearEl || !grid) return;

        // header
        monthYearEl.textContent = `${calendarDate.getFullYear()}年${calendarDate.getMonth() + 1}月`;

        // clear & rebuild
        grid.innerHTML = '';
        const frag = document.createDocumentFragment();

        // weekday header
        ['日', '月', '火', '水', '木', '金', '土'].forEach(d => {
          const h = document.createElement('div');
          h.textContent = d; h.className = 'font-bold text-gray-600';
          frag.appendChild(h);
        });

        const y = calendarDate.getFullYear(), m = calendarDate.getMonth();
        const first = new Date(y, m, 1), last = new Date(y, m + 1, 0);

        // leading blanks
        for (let i = 0; i < first.getDay(); i++) {
          const blank = document.createElement('div'); blank.className = 'p-2';
          frag.appendChild(blank);
        }

        // days
        for (let day = 1; day <= last.getDate(); day++) {
          const d = new Date(y, m, day);
          const ymd = d2str(d);
          const cell = document.createElement('div');
          const isToday = (ymd === TODAY_STR);
          const isSelected = selectedDates.includes(ymd);
          const isPast = toEpochDay(ymd) < TODAY_EPOCH;

          cell.dataset.date = ymd;
          cell.textContent = String(day);

          if (isPast) {
            cell.className = 'p-2 rounded-md text-gray-400 cursor-not-allowed';
          } else {
            cell.className = 'p-2 rounded-md cursor-pointer hover:bg-blue-200 calendar-day';
            if (isSelected) { cell.classList.add('bg-blue-500', 'text-white'); }
            else if (isToday) { cell.classList.add('text-red-600', 'font-semibold'); }
          }
          frag.appendChild(cell);
        }
        grid.appendChild(frag);
      }

      // ========= Additional Casting List =========
      function renderShootingList() {
        const container = document.getElementById('shooting-list-container');
        if (!container) return;

        if (selectedDates.length !== 1) {
          container.innerHTML = '';
          container.classList.add('hidden');
          return;
        }

        const date = selectedDates[0];
        // Find existing shootings for this date
        // Group by Account + Project Name
        const shootings = castingData.filter(c => c.startDate === date && c.slackThreadTs);

        if (shootings.length === 0) {
          container.innerHTML = '';
          container.classList.add('hidden');
          return;
        }

        const uniqueShootings = new Map();
        shootings.forEach(s => {
          const key = `${s.accountName}__${s.projectName}`;
          if (!uniqueShootings.has(key)) {
            uniqueShootings.set(key, s);
          }
        });

        container.classList.remove('hidden');
        container.innerHTML = `
          <div class="text-sm font-bold text-gray-700 mb-2">この日の既存撮影（追加キャスティング）:</div>
          <div class="flex flex-wrap gap-2">
            ${Array.from(uniqueShootings.values()).map(s => `
              <button onclick="startAdditionalOrder({
                date: '${s.startDate}',
                accountName: '${s.accountName}',
                projectId: '${s.projectId}',
                slackThreadTs: '${s.slackThreadTs}',
                slackPermalink: '${s.slackPermalink}'
              })" class="px-3 py-2 bg-blue-100 text-blue-800 rounded hover:bg-blue-200 text-sm font-semibold flex items-center gap-2">
                <span>${s.accountName} / ${s.projectName}</span>
                <span class="text-xs bg-white px-1 rounded border">追加</span>
              </button>
            `).join('')}
          </div>
        `;
      }

      // ========= Filters =========
      function renderFilters() {
        const container = document.getElementById('cast-filters-container'); if (!container) return;

        // Horizontal Layout: Gender | Agency | Keyword | AvailableOnly | Sort
        container.innerHTML = `
    <!-- Gender -->
    <div class="flex flex-col">
      <span class="text-xs font-bold text-gray-500 mb-1">性別</span>
      <div class="flex items-center space-x-3 bg-white border rounded px-3 py-2 h-10">
        <label class="inline-flex items-center space-x-1 cursor-pointer">
          <input id="filter-gender-male" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
          <span class="text-sm">男性</span>
        </label>
        <label class="inline-flex items-center space-x-1 cursor-pointer">
          <input id="filter-gender-female" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
          <span class="text-sm">女性</span>
        </label>
      </div>
    </div>

    <!-- Agency -->
    <div class="flex flex-col relative w-48">
      <label class="text-xs font-bold text-gray-500 mb-1">事務所</label>
      <button id="agency-filter-btn" class="w-full px-3 py-2 border rounded bg-white text-left text-sm flex justify-between items-center h-10">
        <span class="truncate">選択...</span>
        <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
      </button>
      <div id="agency-filter-dropdown" class="hidden absolute top-full left-0 w-full mt-1 bg-white border rounded shadow-lg z-20 max-h-60 overflow-y-auto"></div>
    </div>

    <!-- Keyword -->
    <div class="flex flex-col flex-grow min-w-[200px]">
      <label for="filter-keyword" class="text-xs font-bold text-gray-500 mb-1">フリーワード</label>
      <input id="filter-keyword" type="text" placeholder="名前・事務所・メモ" class="w-full px-3 py-2 border rounded text-sm h-10">
    </div>

    <!-- Extra Options (Available Only / Appearance) -->
    <div class="flex flex-col justify-end pb-1 gap-2">
       <div class="flex items-center">
          <input id="filter-available-only" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
          <label for="filter-available-only" class="ml-2 text-sm text-gray-700 cursor-pointer">未仮キャスのみ</label>
       </div>
    </div>
    
    <!-- Sort (Compact) -->
    <div class="flex flex-col justify-end pb-1 gap-2 ml-auto">
       <div class="flex items-center space-x-3 text-sm">
          <label class="inline-flex items-center space-x-1 cursor-pointer">
            <input id="sort-appearance" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
            <span>出演回数順</span>
          </label>
          <label class="inline-flex items-center space-x-1 cursor-pointer">
            <input id="sort-kana" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
            <span>50音順</span>
          </label>
       </div>
    </div>
  `;

        renderAgencyFilter();

        // dropdown
        const btn = document.getElementById('agency-filter-btn');
        const dd = document.getElementById('agency-filter-dropdown');
        btn?.addEventListener('click', e => { e.stopPropagation(); dd?.classList.toggle('hidden'); });
        document.addEventListener('click', e => { if (!dd || dd.classList.contains('hidden')) return; if (!dd.contains(e.target) && e.target !== btn) dd.classList.add('hidden'); });

        // sort exclusive
        const sA = document.getElementById('sort-appearance');
        const sK = document.getElementById('sort-kana');
        sA?.addEventListener('change', () => { if (sA.checked) sK.checked = false; displayAvailableCasts(); });
        sK?.addEventListener('change', () => { if (sK.checked) sA.checked = false; displayAvailableCasts(); });

        // Add listeners for new inputs
        document.getElementById('filter-keyword')?.addEventListener('input', displayAvailableCasts);
        document.getElementById('filter-gender-male')?.addEventListener('change', displayAvailableCasts);
        document.getElementById('filter-gender-female')?.addEventListener('change', displayAvailableCasts);

        document.getElementById('filter-available-only')?.addEventListener('change', displayAvailableCasts);
      }
      function renderAgencyFilter() {
        const dd = document.getElementById('agency-filter-dropdown'); if (!dd) return;
        const agencies = [...new Set(castData.map(c => c.agency?.trim() || 'フリー'))].sort((a, b) => a.localeCompare(b, 'ja'));

        dd.innerHTML = agencies.map(a => `
          <label class="flex items-center px-3 py-2 hover:bg-gray-100 cursor-pointer">
            <input type="checkbox" value="${a}" class="h-4 w-4 text-blue-600 border-gray-300 rounded mr-2" onchange="updateAgencyButton(); displayAvailableCasts();">
            <span class="text-sm text-gray-700">${a}</span>
          </label>
        `).join('');
      }

      function updateAgencyButton() {
        const btn = document.getElementById('agency-filter-btn');
        if (!btn) return;
        const checked = document.querySelectorAll('#agency-filter-dropdown input[type="checkbox"]:checked');
        if (checked.length === 0) {
          btn.firstElementChild.textContent = '選択...';
        } else if (checked.length === 1) {
          btn.firstElementChild.textContent = checked[0].value;
        } else {
          btn.firstElementChild.textContent = `選択中 (${checked.length})`;
        }
      }

      // ========= Shooting List (Area 2) =========
      let selectedShooting = null; // { pageId, title, date }

      function renderShootingList() {
        const container = document.getElementById('shooting-list-container');
        if (!container) return;

        container.innerHTML = '';

        if (selectedDates.length === 0) {
          container.innerHTML = `<p class="text-gray-500 text-sm">日付を選択すると、候補の撮影が表示されます。</p>`;
          selectedShooting = null;
          updateCartFromShooting();
          return;
        }

        // Filter shootingListData by selectedDates
        // shootingListData has { pageId, title, date, team, cd, fd }
        // We want to show titles that match ANY of the selected dates?
        // User said: "1で選ばれた撮影日に対して、該当する撮影のタイトルを2の場所に表示"
        // "複数日選択された場合は、全てに引っかかっているものではなく、引っかかった撮影日全てのタイトルを出力するイメージ"
        // So union of shootings on selected dates.

        const matchedShootings = (window.shootingListData || []).filter(item => selectedDates.includes(item.date));

        if (matchedShootings.length === 0) {
          container.innerHTML = `<p class="text-gray-500 text-sm">選択された日付の撮影予定はありません。</p>`;
          selectedShooting = null;
          updateCartFromShooting();
          return;
        }

        // Deduplicate by PageID or Title?
        // User said "PageID タイトル...". Let's assume PageID is unique.
        // If same title appears on multiple dates, do we show it once or multiple times?
        // "引っかかった撮影日全てのタイトルを出力するイメージ" -> List all occurrences or unique titles?
        // Usually you select a specific "Shooting Day" which is bound to a date.
        // If I select Dec 1 and Dec 2, and Project A shoots on both, maybe I want to select "Project A (Dec 1)"?
        // But the cart input is "Project Name" and "Notion URL".
        // If I select a shooting, I probably want to set the Project Name and Notion URL for the order.
        // Let's list all items found.

        matchedShootings.forEach(item => {
          const btn = document.createElement('div');
          // Style: Card-like button
          const isSelected = selectedShooting && selectedShooting.pageId === item.pageId && selectedShooting.date === item.date;

          btn.className = `p-3 border rounded-md cursor-pointer transition flex flex-col gap-1 ${isSelected ? 'bg-blue-100 border-blue-500 ring-1 ring-blue-500' : 'bg-white hover:bg-gray-50 border-gray-200'}`;

          btn.innerHTML = `
            <div class="font-bold text-sm text-gray-800">${item.title}</div>
            <div class="text-xs text-gray-500 flex justify-between">
              <span>${item.date}</span>
              <span>${item.team || ''}</span>
            </div>
          `;

          btn.addEventListener('click', () => {
            if (isSelected) {
              // Deselect
              selectedShooting = null;
            } else {
              selectedShooting = item;
            }
            renderShootingList(); // Re-render to update selection state
            updateCartFromShooting();
          });

          container.appendChild(btn);
        });
      }

      function updateCartFromShooting() {
        // Update global cartMeta or similar if needed?
        // The user said: "取得できるデータは、カート内のSTEP1で入力していた、アカウント名、NotionIDになります。"
        // "一旦ここまでできたら、カートの変更を伝えます。"
        // So for now, I just need to store it in `selectedShooting`.
        // I will log it for debug.
      }

      // ========= Cart =========
      async function submitNewOrder() {
        // 1. Auth Check (Auto-Login)
        const isAuth = await ensureAuth();
        if (!isAuth) {
          alert("ログアウト状態のため送信できません。再ログインしてください。");
          handleAuthClick();
          return;
        }

        if (Object.keys(cart).length === 0) {
          showMessage('カートが空です。', 'info');
          return;
        }

        // Show Custom Confirmation Modal instead of native confirm
        const modal = document.getElementById('special-confirmation-modal');
        if (modal) {
          modal.classList.remove('hidden');

          // Reset checkboxes
          document.getElementById('confirm-intimacy').checked = false;
          document.getElementById('confirm-child').checked = false;

          // Setup one-time event listener for OK button
          const okBtn = document.getElementById('special-confirm-ok');
          // Clone button to remove old listeners
          const newOkBtn = okBtn.cloneNode(true);
          okBtn.parentNode.replaceChild(newOkBtn, okBtn);

          newOkBtn.addEventListener('click', async () => {
            modal.classList.add('hidden');

            // Handle Intimacy Check
            const isIntimacy = document.getElementById('confirm-intimacy').checked;
            if (isIntimacy) {
              // Append to note for all items in cart
              for (const key in cart) {
                if (cart[key].note) {
                  cart[key].note += "\n【インティマシーシーンあり】";
                } else {
                  cart[key].note = "【インティマシーシーンあり】";
                }
              }
            }

            // Call submission
            await confirmProvisionalBookings();
          });
        } else {
          // Fallback if modal missing
          if (!confirm('この内容でオーダーを送信しますか？')) return;
          await confirmProvisionalBookings();
        }
      }



      // Make handleAddToCart global
      window.handleAddToCart = function (castId) {
        addToCart(castId);
        const modal = document.getElementById('cast-detail-modal');
        if (modal) modal.remove();
      };

      function addToCart(castId) {
        if (!castId) return;
        if (selectedDates.length === 0) {
          showMessage('まず日付を選択してください。', 'info');
          return;
        }
        const cast = castData.find(c => c.castId === castId);
        if (!cast) return;

        const existing = cart[castId] || {};
        const baseTitles = (cartMeta.projectNames || []).map(t => t.trim()).filter(t => t);

        cart[castId] = {
          cast,
          dates: [...selectedDates],
          roleName: existing.roleName || '',
          rank: existing.rank || 1,
          dates: [...selectedDates],
          roleName: existing.roleName || '',
          rank: existing.rank || 1,
          mainSub: existing.mainSub || 'その他', // Default to 'その他'
          note: existing.note || '',
          projectName: existing.projectName || baseTitles[0] || '',
          note: existing.note || '',
          projectName: existing.projectName || baseTitles[0] || '',
        };

        updateCartCount();
        showMessage(`${cast.name} をカートに追加しました（${selectedDates.length}日）。`);
        displayAvailableCasts();
      }

      function getNextCastPriority(castId, rangeStart, rangeEnd, tempAssignments) {
        let maxPriority = 0;
        const STATUS_BLOCK = ['決定', '仮キャスティング', 'オーダー待ち', '打診中', 'オーダー待ち（仮キャスティング）', '条件つきOK'];
        for (const c of castingData) {
          if (c.castId !== castId || !STATUS_BLOCK.includes(c.status) || !overlaps(rangeStart, rangeEnd, c.startDate, c.endDate)) continue;
          const p = parseInt(c.castPriority, 10);
          if (Number.isFinite(p) && p > maxPriority) maxPriority = p;
        }
        for (const key in tempAssignments) {
          if (key.startsWith(castId + '_')) {
            const [_, tempStart, tempEnd] = key.split('_');
            if (overlaps(rangeStart, rangeEnd, tempStart, tempEnd)) {
              if (tempAssignments[key] > maxPriority) maxPriority = tempAssignments[key];
            }
          }
        }
        return maxPriority + 1;
      }

      async function confirmProvisionalBookings(confirmationData) {
        const items = Object.values(cart); if (items.length === 0) { showMessage('カートが空です。', 'info'); return; }

        const accountName = cartMeta.account || '';
        const notionUrl = cartMeta.notionUrl || '';
        const projectNames = cartMeta.projectNames || [];
        const updaterEmail = currentUser?.email || '';
        const projectId = extractNotionPageId(notionUrl);

        if (!accountName) { showMessage('アカウント名を入力してください。', 'error'); return; }
        if (!projectNames[0]) { showMessage('作品名1を入力してください。', 'error'); return; }
        if (!updaterEmail) { showMessage('更新者情報が取得できませんでした。', 'error'); return; }

        showLoader(true);
        const internalEvents = [];

        try {
          const values = []; const nowISO = new Date().toISOString();
          const castingIdPrefix = `pc_${Date.now()}`; let seq = 1;
          const ordersForSlack = [];
          const allDateRanges = new Set();
          const tempAssignments = {};
          const allTitlesSet = new Set(); // Slack表示用に作品名を収集

          for (const it of items) {
            const ranges = groupDatesIntoRanges(it.dates);
            const workTitle = it.projectName || projectNames[0];

            // 作品名リスト作成（Slack表示用）
            if (!allTitlesSet.has(workTitle)) {
              allTitlesSet.add(workTitle);
            }

            // キャスト情報（内部/外部・メール・SlackメンションID）
            const castFull = castData.find(c => c.castId === it.cast.castId) || null;
            const internalType = castFull?.internalType || '';
            const internalLabel =
              internalType === '内部' ? '内部' :
                internalType === '外部' ? '外部' :
                  '';
            const emailForRow = internalType === '内部' ? (castFull?.email || '') : '';
            const slackMentionId = internalType === '内部' ? (castFull?.slackMentionId || '') : '';
            const isInternal = internalType === '内部';

            // ステータス初期値
            const statusValue = isInternal
              ? '仮キャスティング'
              : 'オーダー待ち';

            // Slack 通知用の注文情報
            ordersForSlack.push({
              castingId: `${castingIdPrefix}_${seq}`,
              roleName: it.roleName || '',
              castName: it.cast.name,
              rank: it.rank,
              mainSub: it.mainSub,
              note: it.note || '',
              projectName: workTitle,
              slack_user_id: slackMentionId || null,
            });

            for (const rg of ranges) {
              const castingId = `${castingIdPrefix}_${seq++}`;
              allDateRanges.add(`${rg.start}〜${rg.end}`);

              const castPriority = getNextCastPriority(it.cast.castId, rg.start, rg.end, tempAssignments);
              tempAssignments[`${it.cast.castId}_${rg.start}_${rg.end}`] = castPriority;

              // キャスティングリスト 1 行分
              // A: castingId (0)
              // B: accountName (1)
              // C: projectName (2)
              // D: roleName (3)
              // E: castId (4)
              // F: castName (5)
              // G: startDate (6)
              // H: endDate (7)
              // I: rank (8)
              // J: status (9)
              // K: note (10)
              // L: slackThreadTs (11)
              // M: slackPermalink (12)
              // N: mainSub (13)
              // O: calendarEventId (14)
              // P: projectId (15)
              // Q: lastUpdated (16)
              // R: updatedBy (17)
              // S: castPriority (18)
              values.push([
                castingId,         // A (0)
                accountName,       // B (1)
                workTitle,         // C (2)
                it.roleName || '', // D (3)
                it.cast.castId,    // E (4)
                it.cast.name,      // F (5)
                rg.start,          // G (6)
                rg.end,            // H (7)
                it.rank,           // I (8)
                statusValue,       // J (9)
                it.note || '',     // K (10)
                "",                // L (11) slackThreadTs (あとでまとめて更新)
                "",                // M (12) slackPermalink (あとでまとめて更新)
                it.mainSub || 'その他', // N (13) mainSub
                "",                // O (14) calendarEventId (あとでカレンダー作成時に更新)
                projectId,         // P (15)
                nowISO,            // Q (16)
                updaterEmail,      // R (17)
                castPriority,      // S (18)
                isInternal ? '内部' : '外部', // T (19) internalType
              ]);

              // 内部キャストのみカレンダー仮ホールド対象にする
              if (isInternal) {
                internalEvents.push({
                  castingId,
                  cast: it.cast,
                  roleName: it.roleName || '',
                  rank: it.rank,
                  mainSub: it.mainSub,
                  accountName,
                  projectName: workTitle,
                  start: rg.start,
                  end: rg.end,
                  castPriority,
                  email: emailForRow,   // カレンダー招待用
                  status: statusValue,  // ディスクリプション用
                  rowNumber: null,      // 後で埋める
                });
              }
            }
          }
          if (values.length === 0) { showMessage('追加対象の日付がありません。', 'info'); return; }

          const appendResult = await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID, range: 'キャスティングリスト!A2',
            valueInputOption: 'USER_ENTERED', insertDataOption: 'INSERT_ROWS',
            resource: { values }
          });

          // B-2 -> A-2: 初回オーダーか追加オーダーかを判定
          const isAdditionalOrder = isAdditionalOrderMode;
          const finalContext = isAdditionalOrder ? additionalOrderContext : null;

          let slackTs = "", slackLink = "";

          if (!isAdditionalOrder) {
            // --- 初回オーダー：今まで通り /api/notify/order_created を呼ぶ ---
            const existingThread = findExistingThreadForOrder(accountName, projectId, Array.from(allDateRanges));
            if (existingThread) {
              // 既存スレッドが見つかった場合は、追加オーダーとして扱う
              slackTs = existingThread.slackThreadTs;
              slackLink = existingThread.slackPermalink;
              // 通知ロジックは後続の status_update に任せる
            } else {
              try {
                const payload = {
                  accountName: cartMeta.account,
                  projectName: "複数のオーダー",
                  projectId: extractNotionPageId(cartMeta.notionUrl) || "00000000-0000-0000-0000-000000000000",
                  dateRanges: Array.from(allDateRanges),
                  orders: ordersForSlack,
                  orderType: "test" // Default
                };

                // Use FormData to send file and payload
                const formData = new FormData();
                formData.append('payload_str', JSON.stringify(payload));
                if (cartMeta.pdfFiles && cartMeta.pdfFiles.length > 0) {
                  for (let i = 0; i < cartMeta.pdfFiles.length; i++) {
                    formData.append('files', cartMeta.pdfFiles[i]);
                  }
                }

                try {
                  const res = await fetch('/api/notify/order_created', {
                    method: 'POST',
                    body: formData // Content-Type header is set automatically
                  });
                  if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || '送信エラー');
                  }
                  const data = await res.json();
                  if (data.upload_error) {
                    showMessage(`オーダーは送信されましたが、PDFの添付に失敗しました: ${data.upload_error}`, 'error');
                  } else {
                    showMessage('オーダーを送信しました！');
                  }

                  // Set Slack info for sheet update
                  slackTs = data.ts;
                  slackLink = data.permalink;
                  cart = {};
                  cartMeta = { account: '', notionUrl: '', projectNames: ['', '', ''], combinedProjectNames: [] };
                  cartStep = 1;
                  updateCartCount();
                  closeCartModal();
                  closeConfirmationModal();
                  displayAvailableCasts();

                  // Reload data to reflect new status
                  setTimeout(() => {
                    loadAllData();
                  }, 2000);

                } catch (e) {
                  console.error(e);
                  showMessage(`送信失敗: ${e.message}`, 'error');
                } finally {
                  showLoader(false);
                }
              } catch (e) {
                console.error("Slack notification failed:", e);
                showMessage('Slack通知APIの呼び出しに失敗しました。', 'error');
              }
            }
          } else {
            // --- 追加オーダー：既存 thread に status_update を飛ばす ---
            const threadTs = finalContext.slackThreadTs;
            if (threadTs) {
              const blockLines = items.map(item => {
                const workTitle = item.projectName || finalContext.projectName;
                const roleName = item.roleName || '役名未定';
                return `${workTitle}
${roleName}：${item.cast.name}`;
              });
              const extraMessage = blockLines.join("\n");

              const mockRec = {
                castingId: values[0]?.[0] || '',
                castName: items.map(it => it.cast.name).join(', '),
                slackThreadTs: threadTs,
                slackPermalink: finalContext.slackPermalink,
                isInternal: false,
              };

              await postStatusUpdateToSlack(mockRec, '追加オーダー', extraMessage);

              // Set slackTs and slackLink for the new rows
              slackTs = finalContext.slackThreadTs;
              slackLink = finalContext.slackPermalink;
            }
          }

          if (slackTs && slackLink) {
            const updatedRange = appendResult.result.updates.updatedRange;
            const match = updatedRange.match(/!A(\d+):/);
            if (match) {
              const startRow = parseInt(match[1], 10);

              // 1) castingId ごとのシート行番号をマッピング
              const rowNumberByCastingId = new Map();
              for (let i = 0; i < values.length; i++) {
                const castingId = values[i][0]; // A列
                const rowNum = startRow + i;
                if (castingId) {
                  rowNumberByCastingId.set(castingId, rowNum);
                }
              }

              // 2) Slack の L/M 列更新
              const updates = [];
              for (let i = 0; i < values.length; i++) {
                const rowNum = startRow + i;
                // 先頭に ' を付けてテキストとして保存（小数点以下を保持するため）
                updates.push({
                  range: `キャスティングリスト!L${rowNum}`,
                  values: [[`'${slackTs}`]],
                });
                updates.push({
                  range: `キャスティングリスト!M${rowNum}`,
                  values: [[slackLink]],
                });
              }

              await gapi.client.sheets.spreadsheets.values.batchUpdate({
                spreadsheetId: SPREADSHEET_ID,
                resource: { valueInputOption: 'USER_ENTERED', data: updates }
              });

              // 3) internalEvents に行番号を埋める
              internalEvents.forEach(ev => {
                ev.rowNumber = rowNumberByCastingId.get(ev.castingId) || null;
              });
            }
          }

          values.forEach(r => {
            const s = normalizeDateString(r[6]), e = normalizeDateString(r[7]);
            if (!castingData.find(c => c.castingId === r[0])) {
              castingData.push({
                castingId: r[0], accountName: r[1], projectName: r[2], roleName: r[3],
                castId: r[4], castName: r[5], startDate: s, endDate: e, startDay: toEpochDay(s), endDay: toEpochDay(e),
                rank: r[8], status: r[9], note: r[10], slackThreadTs: slackTs, slackPermalink: slackLink,
                mainSub: r[13], calendarEventId: r[14], projectId: r[15], lastUpdated: r[16], updatedBy: r[17],
                castPriority: r[18]
              });
            }
          });

          await createInternalHoldEvents(internalEvents);

          cart = {}; cartMeta = { account: '', notionUrl: '', projectNames: ['', '', ''], combinedProjectNames: [] }; cartStep = 1;
          updateCartCount(); closeCartModal(); closeConfirmationModal(); displayAvailableCasts();
          await renderCastingStatusView(true);
          showMessage('仮キャスティングを登録し、Slackに通知しました。');

          // A-2: 追加オーダーモードをリセット
          if (isAdditionalOrderMode) {
            isAdditionalOrderMode = false;
            additionalOrderContext = null;
          }
        } catch (e) {
          console.error(e);
          showMessage('仮キャスティングの登録またはSlack通知の連携に失敗しました。', 'error');
        } finally {
          showLoader(false);
        }
      }

      async function createInternalHoldEvents(events) {
        if (!events || events.length === 0) return;
        if (!INTERNAL_HOLD_CALENDAR_ID) {
          console.warn('INTERNAL_HOLD_CALENDAR_ID が設定されていないため、仮ホールド作成をスキップします。');
          return;
        }

        const calUpdates = [];

        for (const ev of events) {
          // サマリー（仮ホールド時点）
          const summary = `${ev.accountName || 'アカウント未設定'}_${ev.rank || ''}候補_仮キャスティング`;

          // 説明文（ステータス付き）
          const descriptionLines = [];
          descriptionLines.push('【キャスティング仮ホールド】');
          descriptionLines.push('');
          descriptionLines.push(`・アカウント: ${ev.accountName || '未設定'}`);
          descriptionLines.push(`・作品名: ${ev.projectName || '未設定'}`);
          descriptionLines.push(`・役名: ${ev.roleName || '未設定'}`);
          descriptionLines.push(`・区分: ${ev.mainSub || 'その他'}`);
          descriptionLines.push(`・キャスティングID: ${ev.castingId}`);
          descriptionLines.push(`・ステータス: ${ev.status || '仮キャスティング'}`);
          descriptionLines.push('');
          descriptionLines.push('この予定はキャスティング管理システムから自動作成されています。');
          descriptionLines.push('ステータス変更時にはシステム側で更新される場合があります。');

          // 終日イベント用（end は翌日）
          const startDateStr = ev.start;
          const endDateObj = new Date(ev.end);
          endDateObj.setDate(endDateObj.getDate() + 1);
          const endDateStr = d2str(endDateObj);

          const resource = {
            summary,
            description: descriptionLines.join('\n'),
            start: { date: startDateStr, timeZone: 'Asia/Tokyo' },
            end: { date: endDateStr, timeZone: 'Asia/Tokyo' },
          };

          // 内部キャストメールがあれば出席者として招待
          if (ev.email) {
            resource.attendees = [{ email: ev.email }];
          }

          try {
            const res = await gapi.client.calendar.events.insert({
              calendarId: INTERNAL_HOLD_CALENDAR_ID,
              resource,
            });

            const eventId = res.result.id;
            if (eventId && ev.rowNumber) {
              calUpdates.push({
                range: `キャスティングリスト!O${ev.rowNumber}`, // O列: calendarEventId
                values: [[eventId]],
              });
            }
          } catch (e) {
            console.error('内部キャストの仮ホールド作成に失敗:', e);
            showMessage('内部キャストの仮ホールド登録に失敗しました。', 'error');
          }
        }

        // まとめて N 列に eventId を書き戻し
        if (calUpdates.length) {
          try {
            await gapi.client.sheets.spreadsheets.values.batchUpdate({
              spreadsheetId: SPREADSHEET_ID,
              resource: {
                valueInputOption: 'USER_ENTERED',
                data: calUpdates,
              },
            });
          } catch (e) {
            console.error('calendarEventId の書き込みに失敗:', e);
          }
        }
      }




      // ========= Shooting Contact Page =========

      let currentContactTab = '香盤連絡待ち'; // '香盤連絡待ち' | 'メイキング共有待ち' | '投稿日連絡待ち'

      async function showShootContactPage() {
        const view = document.getElementById("main-view");
        if (!view) return;

        view.innerHTML = `
      <div class="p-4">
        <h2 class="text-2xl font-bold mb-6 text-gray-800">撮影連絡管理</h2>
        
        <div class="flex space-x-1 border-b mb-6 overflow-x-auto">
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === '香盤連絡待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="香盤連絡待ち">
                1. 香盤連絡待ち
            </button>
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === '発注書送信待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="発注書送信待ち">
                2. 発注書送信待ち
            </button>
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === 'メイキング共有待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="メイキング共有待ち">
                3. メイキング共有待ち
            </button>
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === '投稿日連絡待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="投稿日連絡待ち">
                4. 投稿日連絡待ち
            </button>
        </div>

        <div id="shoot-contact-loading" class="text-gray-500 mb-4 hidden">読み込み中...</div>
        <div id="shoot-contact-container" class="overflow-x-auto"></div>
      </div>
    `;
        // Event Listeners
        view.querySelectorAll('.contact-tab').forEach(btn => {
          btn.addEventListener('click', () => {
            currentContactTab = btn.dataset.tab;
            showShootContactPage();
          });
        });

        await loadShootingContactPage();
      }

      async function loadShootingContactPage() {
        const loading = document.getElementById("shoot-contact-loading");
        const container = document.getElementById("shoot-contact-container");
        if (!loading || !container) return;

        try {
          loading.classList.remove('hidden');
          const res = await fetch("/api/shooting_contact/list");
          if (!res.ok) {
            container.innerHTML = `<p class="text-red-500">データ取得に失敗しました (APIエラー)</p>`;
            return;
          }

          const allItems = await res.json();
          window.shootingContactData = allItems; // Store globally

          // Filter by current tab
          const items = allItems.filter(item => item.status === currentContactTab);

          // Header with Sync Button (Dynamic based on tab)
          let syncBtnHtml = "";
          if (currentContactTab === '香盤連絡待ち') {
            syncBtnHtml = `
            <button onclick="syncShootingSchedule(this, 'schedule')" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded flex items-center gap-2 shadow transition">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                香盤DBと同期
            </button>`;
          } else if (currentContactTab === 'メイキング共有待ち') {
            syncBtnHtml = `
            <button onclick="syncShootingSchedule(this, 'making')" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded flex items-center gap-2 shadow transition">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                メイキングDBと同期
            </button>`;
          } else if (currentContactTab === '投稿日連絡待ち') {
            syncBtnHtml = `
            <button onclick="syncShootingSchedule(this, 'post_date')" class="bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded flex items-center gap-2 shadow transition">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                投稿日DBと同期
            </button>`;
          }

          let headerHtml = `
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">撮影連絡管理</h2>
            ${syncBtnHtml}
        </div>
      `;

          if (!items || items.length === 0) {
            container.innerHTML = headerHtml + `<div class="p-8 text-center text-gray-500 bg-gray-50 rounded-lg border border-dashed border-gray-300">
            <p class="text-lg">「${currentContactTab}」の対象はありません</p>
        </div>`;
            return;
          }

          // Grouping: Date -> Account+NotionID
          // We want to display Account Name / Project Name in the header.
          const grouped = {};
          items.forEach(item => {
            let dateKey = item.shootDate || "未定";
            if (currentContactTab === '投稿日連絡待ち') {
              dateKey = item.postDate || "未定";
            }

            const notionId = item.notionId || "NoID";
            const account = item.accountName || "未設定";
            const project = item.projectName || "未設定";

            if (!grouped[dateKey]) grouped[dateKey] = {};

            // Create a unique key for the group
            // If NotionID exists, use it. If not, use Project Name to avoid grouping unrelated "NoID" items.
            // Also include Account Name to prevent cross-account merging.
            const groupKey = `${account}_${notionId !== "NoID" ? notionId : project}`;

            if (!grouped[dateKey][groupKey]) {
              grouped[dateKey][groupKey] = {
                accountName: account,
                projectName: project,
                items: []
              };
            }
            grouped[dateKey][groupKey].items.push(item);
          });

          // Render Accordion
          let html = '<div class="space-y-2">';

          // Sort dates
          const dates = Object.keys(grouped).sort();

          dates.forEach(date => {
            const dateLabel = (currentContactTab === '投稿日連絡待ち') ? `📮 投稿日: ${date}` : `📅 撮影日: ${date}`;
            html += `
            <div class="border rounded-lg bg-white overflow-hidden">
                <button class="w-full px-4 py-3 bg-gray-100 text-left font-bold flex justify-between items-center hover:bg-gray-200 transition" onclick="toggleAccordion(this)">
                    <span>${dateLabel}</span>
                    <span class="text-xs text-gray-500">▼</span>
                </button>
                <div class="hidden border-t">
          `;

            // Sort projects within date (by Account then Project)
            const groupKeys = Object.keys(grouped[date]).sort((a, b) => {
              const groupA = grouped[date][a];
              const groupB = grouped[date][b];
              if (groupA.accountName !== groupB.accountName) {
                return groupA.accountName.localeCompare(groupB.accountName);
              }
              return groupA.projectName.localeCompare(groupB.projectName);
            });

            groupKeys.forEach(key => {
              const group = grouped[date][key];
              const projectItems = group.items;

              html += `
                <div class="border-b last:border-b-0">
                    <button class="w-full px-4 py-2 bg-white text-left font-medium text-sm flex justify-between items-center hover:bg-blue-50 transition pl-8" onclick="toggleAccordion(this)">
                        <span>🏢 ${group.accountName} / 🎬 ${group.projectName} (${projectItems.length}名)</span>
                        <span class="text-xs text-gray-500">▼</span>
                    </button>
                    <div class="hidden border-t p-2 pl-8 bg-gray-50">
                        ${renderProjectTable(projectItems)}
                    </div>
                </div>
              `;
            });

            html += `</div></div>`;
          });

          html += '</div>';
          container.innerHTML = headerHtml + html;

        } catch (err) {
          console.error(err);
          container.innerHTML = `<p class="text-red-500">読み込みエラーが発生しました</p>`;
        } finally {
          loading.classList.add('hidden');
        }
      }

      // Helper for Accordion
      window.toggleAccordion = function (btn) {
        const content = btn.nextElementSibling;
        content.classList.toggle('hidden');
        const icon = btn.querySelector('span:last-child');
        if (icon) icon.textContent = content.classList.contains('hidden') ? '▼' : '▲';
      };

      function renderProjectTable(items) {
        // Dynamic Columns based on Tab
        let extraHeader = "";
        let costHeader = ""; // 金額ヘッダー用

        if (currentContactTab === '香盤連絡待ち') {
          extraHeader = '<th class="px-2 py-2 text-left w-64">時間/場所</th>';
          costHeader = '<th class="px-2 py-2 text-left w-24">金額</th>';
        } else if (currentContactTab === '発注書送信待ち') {
          // ★追加: 発注書送信待ち用のヘッダー（香盤連絡待ちと同様に見せる）
          extraHeader = '<th class="px-2 py-2 text-left w-64">時間/場所</th>';
          costHeader = '<th class="px-2 py-2 text-left w-24">金額</th>';
        } else if (currentContactTab === 'メイキング共有待ち') {
          extraHeader = '<th class="px-2 py-2 text-left w-24">メイキングURL</th>';
        } else if (currentContactTab === '投稿日連絡待ち') {
          extraHeader = '<th class="px-2 py-2 text-left w-24">投稿日</th>';
        }

        let html = `
        <table class="min-w-full bg-white border rounded-lg overflow-hidden table-fixed">
          <thead class="bg-gray-100 text-xs text-gray-500 uppercase">
            <tr>
              <th class="px-2 py-2 text-left w-48">案件名 / 役名</th>
              <th class="px-2 py-2 text-left w-24">キャスト</th>
              <th class="px-2 py-2 text-left w-12">M/S</th>
              <th class="px-2 py-2 text-left w-24">日時/場所</th>
              ${costHeader ? '<th class="px-2 py-2 text-left w-12">金額</th>' : ''}
              ${!costHeader && extraHeader ? extraHeader : ''}
              <th class="px-2 py-2 text-center w-20">アクション</th>
            </tr>
          </thead>
          <tbody class="divide-y divide-gray-200">
      `;

        items.forEach(item => {
          let extraCol = "";
          let costCol = "";
          let actionBtns = "";

          // メール作成ボタン（共通）
          const mailBtn = `
            <button class="px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700 shadow-sm whitespace-nowrap w-full"
                onclick="openShootMailModal('${item.castingId}')">
                ✉️ 作成
            </button>`;

          if (currentContactTab === '香盤連絡待ち') {
            // 時間・場所を編集可能な input に変更
            extraCol = `
            <td class="px-2 py-2 align-top">
              <div class="flex flex-col gap-1">
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">IN</span>
                   <input type="text" class="shoot-in border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.inTime || ''}" placeholder="00:00">
                </div>
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">OUT</span>
                   <input type="text" class="shoot-out border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.outTime || ''}" placeholder="00:00">
                </div>
                <input type="text" class="shoot-location border rounded px-1 py-0.5 text-xs w-full mt-1 bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                       value="${item.location || ''}" placeholder="場所">
              </div>
            </td>`;

            // 金額入力欄 (P列)
            costCol = `
            <td class="px-2 py-2 align-top">
              <input type="text" class="shoot-cost border rounded px-1 py-0.5 text-xs w-full text-right bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                     value="${item.cost || ''}" placeholder="¥">
            </td>`;

            // 保存ボタンを追加
            actionBtns = `
            <div class="flex flex-col gap-2 items-center">
                <button class="px-2 py-1 bg-emerald-600 text-white rounded text-xs hover:bg-emerald-700 shadow-sm whitespace-nowrap w-full"
                    onclick="saveShootingRow('${item.castingId}', this)">
                    💾 保存
                </button>
                ${mailBtn}
            </div>`;

          } else if (currentContactTab === '発注書送信待ち') {
            // ★追加: 発注書送信待ちのロジック
            // 香盤連絡待ちと同様に編集可能にする
            extraCol = `
            <td class="px-2 py-2 align-top">
              <div class="flex flex-col gap-1">
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">IN</span>
                   <input type="text" class="shoot-in border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.inTime || ''}" placeholder="00:00">
                </div>
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">OUT</span>
                   <input type="text" class="shoot-out border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.outTime || ''}" placeholder="00:00">
                </div>
                <input type="text" class="shoot-location border rounded px-1 py-0.5 text-xs w-full mt-1 bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                       value="${item.location || ''}" placeholder="場所">
              </div>
            </td>`;

            costCol = `
            <td class="px-2 py-2 align-top">
              <input type="text" class="shoot-cost border rounded px-1 py-0.5 text-xs w-full text-right bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                     value="${item.cost || ''}" placeholder="¥">
            </td>`;

            // アクションボタン: 保存、発注書作成、メール
            actionBtns = `
            <div class="flex flex-col gap-2 items-center">
                <button class="px-2 py-1 bg-emerald-600 text-white rounded text-xs hover:bg-emerald-700 shadow-sm whitespace-nowrap w-full"
                    onclick="saveShootingRow('${item.castingId}', this)">
                    💾 保存
                </button>
                <button class="px-2 py-1 bg-indigo-600 text-white rounded text-xs hover:bg-indigo-700 shadow-sm whitespace-nowrap w-full"
                    onclick="openOrderDocModal('${item.castingId}')">
                    📄 発注書
                </button>
                ${mailBtn}
            </div>`;

          } else if (currentContactTab === 'メイキング共有待ち') {
            extraCol = `<td class="px-2 py-2 text-xs text-blue-600 truncate max-w-xs"><a href="${item.makingUrl}" target="_blank">${item.makingUrl || '-'}</a></td>`;
            costCol = `<td class="px-2 py-2 text-xs text-right">${item.cost || '-'}</td>`;
            actionBtns = mailBtn;
          } else if (currentContactTab === '投稿日連絡待ち') {
            extraCol = `<td class="px-2 py-2 text-xs">${item.postDate || '-'}</td>`;
            costCol = `<td class="px-2 py-2 text-xs text-right">${item.cost || '-'}</td>`;
            actionBtns = mailBtn;
          }

          html += `
            <tr class="hover:bg-gray-50">
              <td class="px-2 py-2 align-top">
                <div class="text-sm font-bold text-gray-900">${item.projectName}</div>
                <div class="text-xs text-gray-500">${item.roleName}</div>
              </td>
              <td class="px-2 py-2 align-top">
                <div class="text-sm text-gray-900">${item.castName}</div>
              </td>
              <td class="px-2 py-2 align-top">
                <div class="text-xs text-gray-500">${item.mainSub || '-'}</div>
              </td>
              ${extraCol ? extraCol : `<td class="px-2 py-2 align-top text-sm text-gray-500">${item.date}</td>`}
              ${costCol ? costCol : (costHeader ? `<td class="px-2 py-2 align-top text-sm text-gray-500">${item.cost || ''}</td>` : '')}
              ${!costHeader && extraHeader ? `<td class="px-2 py-2 align-top text-sm text-gray-500">${item.makingUrl || item.postDate || ''}</td>` : ''}
              <td class="px-2 py-2 align-top text-center">
                ${actionBtns}
              </td>
            </tr>
          `;
        });

        html += `</tbody></table>`;
        return html;
      }

      // Make functions global
      // 行ごとの保存処理
      window.saveCastingCost = async function (castingId, currentStatus, btn) {
        const row = btn.closest('tr');
        if (!row) return;
        const costInput = row.querySelector('.status-cost-input');
        if (!costInput) return;

        const newCost = costInput.value.trim();
        const originalText = btn.innerText;
        btn.innerText = '...';
        btn.disabled = true;

        try {
          // Reuse changeCastingStatus to update Cost (and Status, which is unchanged)
          await changeCastingStatus(castingId, currentStatus, {
            cost: newCost,
            quick: true // Suppress some UI feedback if needed, or just standard
          });
          // changeCastingStatus already shows message and re-renders if needed
          // But we might want to avoid full re-render if possible?
          // changeCastingStatus calls renderCastingStatusView(false) at the end.
        } catch (e) {
          console.error(e);
          showMessage('保存に失敗しました', 'error');
        } finally {
          btn.innerText = originalText;
          btn.disabled = false;
        }
      };

      window.saveShootingRow = async function (castingId, btn) {
        const row = btn.closest('tr');
        if (!row) return;

        const inTime = row.querySelector('.shoot-in')?.value || '';
        const outTime = row.querySelector('.shoot-out')?.value || '';
        const location = row.querySelector('.shoot-location')?.value || '';
        const cost = row.querySelector('.shoot-cost')?.value || '';

        // ボタンをローディング状態に
        const originalText = btn.innerHTML;
        btn.innerHTML = '...';
        btn.disabled = true;

        try {
          // updateShootingContactFields を呼ぶ (API: /api/shooting_contact/update)
          // 既存の updateShootingContactFields (汎用) を使います

          const res = await fetch("/api/shooting_contact/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              castingId: castingId,
              inTime: inTime,
              outTime: outTime,
              location: location,
              cost: cost  // 新規追加: P列
            })
          });

          if (res.ok) {
            showMessage('情報を更新しました');
            // フロントエンドのデータも更新しておく（再読み込みまでの表示用）
            const item = (window.shootingContactData || []).find(i => i.castingId === castingId);
            if (item) {
              item.inTime = inTime;
              item.outTime = outTime;
              item.location = location;
              item.cost = cost;
            }
          } else {
            throw new Error('Update failed');
          }
        } catch (e) {
          console.error(e);
          showMessage('更新に失敗しました', 'error');
        } finally {
          btn.innerHTML = originalText;
          btn.disabled = false;
        }
      };

      // ========= Cast Detail Modal =========
      function openCastDetailModal(castId) {
        const cast = castData.find(c => c.castId === castId);
        if (!cast) return;

        const modal = document.getElementById('cart-modal'); // Reusing cart-modal container for simplicity or create new one?
        // Using a dedicated modal container is better to avoid conflict.
        // Let's use a new one dynamically or reuse 'new-external-cast-modal' structure?
        // Creating a new one in HTML structure is best, but I can inject it dynamically.

        let detailModal = document.getElementById('cast-detail-modal');
        if (!detailModal) {
          detailModal = document.createElement('div');
          detailModal.id = 'cast-detail-modal';
          detailModal.className = 'hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop';
          document.body.appendChild(detailModal);
        }

        const inCart = !!cart[cast.castId];
        const stat = getCastStatusForDates(cast.castId, selectedDates);
        const isNG = stat.isNG;
        const isConfirmed = stat.isConfirmed;
        const disabled = isNG || isConfirmed || inCart;
        const btnText = isConfirmed ? 'キャスティング不可' : (isNG ? 'NG' : (inCart ? '追加済み' : '仮キャスティングリストに追加'));
        const btnClass = disabled ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700';

        // SNS Links
        const snsLinks = [];
        if (cast.snsX) {
          snsLinks.push(`<a href="${cast.snsX}" target="_blank" class="text-gray-500 hover:text-black"><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a>`);
        }
        if (cast.snsInsta) {
          snsLinks.push(`<a href="${cast.snsInsta}" target="_blank" class="text-gray-500 hover:text-pink-600"><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg></a>`);
        }
        if (cast.snsTiktok) {
          snsLinks.push(`<a href="${cast.snsTiktok}" target="_blank" class="text-gray-500 hover:text-black"><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12.525.02c1.31-.02 2.61-.01 3.91-.02.08 1.53.63 3.09 1.75 4.17 1.12 1.11 2.7 1.62 4.24 1.79v4.03c-1.44-.05-2.89-.35-4.2-.97-.57-.26-1.1-.59-1.62-.93-.01 2.92.01 5.84-.02 8.75-.08 1.4-.54 2.79-1.35 3.94-1.31 1.92-3.58 3.17-5.91 3.21-1.43.08-2.86-.31-4.08-1.03-2.02-1.19-3.44-3.37-3.65-5.71-.02-.5-.03-1-.01-1.49.18-1.9 1.12-3.72 2.58-4.96 1.66-1.44 3.98-2.13 6.15-1.72.02 1.48-.04 2.96-.04 4.44-.99-.32-2.15-.23-3.02.37-.63.35-1.17 1.09-1.07 1.93.03.58.01 1.16.44 1.57.89.97 2.55.88 3.4-.14.57-.71.79-1.6.78-2.49-.01-4.22.01-8.43.01-12.65-.02-.03-.03-.07-.05-.1z"/></svg></a>`);
        }

        // Helper to format Drive URL
        function formatDriveUrl(url) {
          if (!url) return "";
          if (url.includes("drive.google.com")) {
            let id = "";
            const idMatch = url.match(/id=([^&]+)/);
            const fileMatch = url.match(/\/file\/d\/([^/]+)/);
            if (idMatch) id = idMatch[1];
            else if (fileMatch) id = fileMatch[1];
            if (id) return `https://drive.google.com/thumbnail?id=${id}&sz=w800`;
          }
          return url;
        }
        const displayUrl = formatDriveUrl(cast.imageUrl);

        // Purchase Order Button Condition
        const relevantCasting = castingData.find(c => c.castId === castId && overlaps(selectedDates[0], selectedDates[selectedDates.length - 1], c.startDate, c.endDate));
        const canDownloadOrder = relevantCasting && ['OK', '香盤連絡待ち', '決定'].includes(relevantCasting.status);

        detailModal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto relative flex flex-col md:flex-row">
             <button onclick="document.getElementById('cast-detail-modal').remove()" class="absolute top-4 right-4 text-gray-500 hover:text-gray-700 z-10">
               <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
             
             <!-- Left: Image -->
             <div class="w-full md:w-1/2 bg-gray-100 flex items-center justify-center p-4">
               ${cast.imageUrl ? `<img src="${formatDriveUrl(cast.imageUrl)}" class="max-w-full max-h-[70vh] object-contain rounded shadow-sm" referrerpolicy="no-referrer">`
            : `<div class="text-gray-400">No Image</div>`}
             </div>

             <!-- Right: Info -->
             <div class="w-full md:w-1/2 p-8 flex flex-col">
               <h2 class="text-3xl font-bold mb-2">${cast.name}</h2>
               <p class="text-lg text-gray-600 mb-4">${cast.agency || 'フリー'}</p>
               
               <div class="flex space-x-4 mb-6">
                 ${snsLinks.join('')}
               </div>

               <div class="space-y-3 text-sm text-gray-700 mb-8">
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">年齢</span>
                   <span>${cast.age ? cast.age + '歳' : '-'}</span>
                 </div>
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">性別</span>
                   <span>${cast.gender || '-'}</span>
                 </div>
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">連絡先</span>
                   <span class="break-all">${cast.email || '-'}</span>
                 </div>
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">備考</span>
                   <span class="whitespace-pre-wrap">${cast.notes || '-'}</span>
                 </div>
               </div>

               <div class="mt-auto">
                 <button onclick="handleAddToCart('${cast.castId}')" 
                   class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow transition ${disabled ? 'opacity-50 cursor-not-allowed' : ''}" ${disabled ? 'disabled' : ''}>
                   ${btnText}
                 </button>
               </div>
             </div>
          </div>
        `;

        detailModal.classList.remove('hidden');

        // Event Listeners
        detailModal.addEventListener('click', (e) => {
          if (e.target === detailModal) detailModal.classList.add('hidden');
        });
      }

      // ========== PDF生成ロジック (Google Docs廃止版) ==========

      // 日本語フォントを読み込むためのヘルパー
      async function loadJapaneseFont(doc) {
        // 今回はhtml2canvas方式のため、この関数は実質未使用ですが、将来のために残します
      }

      // ========== 発注書作成モーダル & PDF生成 ==========

      // 1. モーダルを開く関数
      window.openOrderDocModal = function (castingId) {
        // データ取得
        let targetCasting = null;
        if (window.shootingContactData) {
          targetCasting = window.shootingContactData.find(item => item.castingId === castingId);
        }
        if (!targetCasting) {
          targetCasting = castingData.find(c => c.castingId === castingId);
        }
        if (!targetCasting) {
          showMessage('対象データが見つかりません', 'error');
          return;
        }

        // 初期値セット
        const data = {
          date: new Date().toLocaleDateString(),
          castName: targetCasting.castName || targetCasting.name || '',
          project: targetCasting.projectName || '',
          role: targetCasting.roleName || '',
          shootDate: targetCasting.date || targetCasting.startDate || targetCasting.shootDate || '',
          cost: targetCasting.cost || '',
          note: targetCasting.note || ''
        };

        const modal = document.getElementById('edit-modal'); // 既存の汎用モーダルを流用
        if (!modal) return;

        modal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl max-w-lg w-full p-6">
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-xl font-bold">発注書作成（編集）</h3>
              <button onclick="document.getElementById('edit-modal').classList.add('hidden')" class="text-gray-500 hover:text-gray-700">&times;</button>
            </div>
            
            <div class="space-y-3 text-sm">
              <p class="text-xs text-gray-500">PDFに記載する内容を編集できます。</p>
              
              <div>
                <label class="block font-bold text-gray-700">日付</label>
                <input type="text" id="pdf-date" class="w-full border rounded p-2" value="${data.date}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">宛名（キャスト様）</label>
                <input type="text" id="pdf-castname" class="w-full border rounded p-2" value="${data.castName}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">案件名</label>
                <input type="text" id="pdf-project" class="w-full border rounded p-2" value="${data.project}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">役名</label>
                <input type="text" id="pdf-role" class="w-full border rounded p-2" value="${data.role}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">撮影日</label>
                <input type="text" id="pdf-shootdate" class="w-full border rounded p-2" value="${data.shootDate}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">金額</label>
                <input type="text" id="pdf-cost" class="w-full border rounded p-2" value="${data.cost}" placeholder="数値のみ入力すると自動フォーマットされます">
              </div>
              <div>
                <label class="block font-bold text-gray-700">備考</label>
                <textarea id="pdf-note" class="w-full border rounded p-2" rows="3">${data.note}</textarea>
              </div>
            </div>

            <div class="mt-6 flex justify-end gap-3">
              <button onclick="document.getElementById('edit-modal').classList.add('hidden')" class="px-4 py-2 border rounded hover:bg-gray-50">キャンセル</button>
              <button id="btn-generate-pdf" class="px-6 py-2 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700">
                PDFを作成
              </button>
            </div>
          </div>
        `;

        modal.classList.remove('hidden');

        // 生成ボタンイベント
        document.getElementById('btn-generate-pdf').addEventListener('click', () => {
          const finalData = {
            date: document.getElementById('pdf-date').value,
            castName: document.getElementById('pdf-castname').value,
            project: document.getElementById('pdf-project').value,
            role: document.getElementById('pdf-role').value,
            shootDate: document.getElementById('pdf-shootdate').value,
            cost: document.getElementById('pdf-cost').value,
            note: document.getElementById('pdf-note').value
          };
          generatePDFFromData(finalData);
          modal.classList.add('hidden');
        });
      };



      // 季節の挨拶を取得する関数
      function getSeasonalGreeting() {
        const month = new Date().getMonth() + 1;
        const greetings = {
          1: "初春", 2: "晩冬", 3: "早春", 4: "陽春", 5: "新緑", 6: "初夏",
          7: "盛夏", 8: "晩夏", 9: "初秋", 10: "秋冷", 11: "晩秋", 12: "初冬"
        };
        return greetings[month] || "時下";
      }

      // 2. 実際のPDF生成処理（データを引数で受け取るように変更）
      window.generatePDFFromData = async function (data) {
        // 金額フォーマット
        let costStr = data.cost;
        const numCost = Number(data.cost.replace(/[^0-9]/g, ''));
        if (numCost > 0 && !data.cost.includes('¥')) {
          costStr = `¥${numCost.toLocaleString()}`;
        }

        const tempDiv = document.createElement('div');
        tempDiv.style.width = '210mm';
        tempDiv.style.minHeight = '297mm';
        tempDiv.style.padding = '20mm';
        tempDiv.style.backgroundColor = 'white';
        tempDiv.style.color = 'black';
        tempDiv.style.fontFamily = '"Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif';
        tempDiv.style.position = 'fixed';
        tempDiv.style.top = '-9999px';
        tempDiv.style.left = '-9999px';
        tempDiv.style.zIndex = '-100';
        // ★修正: 線が入る問題を防ぐ
        tempDiv.style.textDecoration = 'none';

        const greeting = getSeasonalGreeting();

        tempDiv.innerHTML = `
          <div style="text-decoration: none !important; font-size: 14px; line-height: 1.6;">
            <h1 style="text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 30px;">GOKKO倶楽部出演発注書</h1>
            
            <div style="text-align: right; margin-bottom: 20px;">${data.date}</div>
            
            <div style="font-size: 14px; margin-bottom: 20px;">
              <span style="font-size: 14px; border-bottom: 1px solid #000;">${data.castName} 様</span>
            </div>

            <p style="margin-bottom: 5px;">拝啓</p>
            <p style="margin-bottom: 5px;">${greeting}の候、貴社におかれましては益々ご清栄のこととお慶び申し上げます。<br>
            平素は格別のご高配を賜り、厚く御礼申し上げます。</p>
            <p style="margin-bottom: 5px;">ご快諾いただきましたドラマ出演の件につきまして、下記の通り発注申し上げます。<br>
            内容をご確認いただき、ご不明な点がございましたら担当までご連絡ください。<br>
            本作品へのご出演、心より感謝申し上げます。</p>
            <p style="text-align: right; margin-bottom: 20px;">敬具</p>

            <div style="margin-bottom: 20px; padding: 10px; width: 100%;">
              <p style="font-weight: bold; margin-bottom: 5px;">【発注元】</p>
              <p style="margin: 0;">〒135-0091</p>
              <p style="margin: 0;">東京都港区台場2-3-1トレードピアお台場12F</p>
              <p style="margin: 0;">株式会社GOKKO</p>
              <p style="margin: 0;">担当：GOKKO倶楽部キャスティング担当</p>
            </div>

            <div style="margin-bottom: 20px;">
              <p style="font-weight: bold; border-bottom: 1px solid #000; display: inline-block; margin-bottom: 10px;">【お取引条件】</p>
              <p style="margin: 2px 0;">支払条件： 月末締め翌月末払い</p>
              <p style="margin: 2px 0;">支払方法： ご指定の銀行口座へお振込み</p>
              <p style="margin: 2px 0;">源泉徴収： [例：有・無（必要な場合はマイナンバーをご提出ください）]</p>
              <p style="margin: 2px 0;">秘密保持： 本件に関わる脚本内容、撮影情報、共演者情報等は、公式解禁まで第三者への漏洩（SNS含む）を禁止とさせていただきます。</p>
              <p style="text-align: right; margin: 0;">以上</p>
            </div>

            <div style="text-align: center; margin-bottom: 20px; font-weight: bold;">記</div>

            <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
              <tr style="border: 1px solid #000;">
                <th style="border: 1px solid #000; padding: 8px; background-color: #f0f0f0; width: 30%; text-align: center;">項目</th>
                <th style="border: 1px solid #000; padding: 8px; background-color: #f0f0f0; text-align: center;">内容</th>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">案件名</td>
                <td style="border: 1px solid #000; padding: 8px;">${data.project}</td>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">役名</td>
                <td style="border: 1px solid #000; padding: 8px;">${data.role}</td>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">撮影日</td>
                <td style="border: 1px solid #000; padding: 8px;">${data.shootDate}</td>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">出演料（金額）</td>
                <td style="border: 1px solid #000; padding: 8px;">${costStr} （税別・税込）</td>
              </tr>
            </table>

          </div>
        `;

        document.body.appendChild(tempDiv);
        showLoader(true);

        try {
          // html2canvas / jsPDF のロード確認
          if (typeof html2canvas === 'undefined') await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
          if (typeof window.jspdf === 'undefined') await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');

          const canvas = await html2canvas(tempDiv, { scale: 2 });
          const imgData = canvas.toDataURL('image/png');

          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF('p', 'mm', 'a4');
          const pdfWidth = pdf.internal.pageSize.getWidth();
          const pdfHeight = (canvas.height * pdfWidth) / canvas.width;

          pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);

          const fileName = `${data.shootDate.replace(/[\/-]/g, '')}_${data.project}_${data.castName}_発注書.pdf`;
          pdf.save(fileName);

          showMessage('発注書PDFをダウンロードしました', 'success');
        } catch (e) {
          console.error(e);
          showMessage('PDF作成に失敗しました: ' + e.message, 'error');
        } finally {
          document.body.removeChild(tempDiv);
          showLoader(false);
        }
      };

      // 旧関数を削除または上書き
      window.createOrderDoc = window.openOrderDocModal;

      // スクリプト読み込みヘルパー
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src;
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }

      window.openShootMailModal = openShootMailModal;
      window.openShootStatusModal = openShootStatusModal;

      function openShootMailModal(castingId) {

        // Try to find in shootingContactData first, then castingData
        let item = (window.shootingContactData || []).find(i => i.castingId === castingId);
        let isCastingItem = false;

        if (!item) {
          item = castingData.find(c => c.castingId === castingId);
          isCastingItem = true;
        }

        if (!item) { showMessage("データが見つかりません", "error"); return; }

        const modal = document.getElementById('shoot-mail-modal');
        if (!modal) return;

        // Store current item ID and status for auto-update
        modal.dataset.castingId = castingId;
        modal.dataset.currentStatus = item.status;
        // Store flag to know if we should update casting status or shooting status
        modal.dataset.isCastingItem = isCastingItem;

        let subject = "";
        let body = "";

        // Template Logic
        if (item.status === "香盤連絡待ち") {
          subject = `【香盤連絡】${item.projectName}`;
          body = `${item.castName} 様\n\nお世話になっております。\n株式会社GOKKOです。\n\n${item.projectName} の香盤をお送りいたします。\n\n日時：${item.date} ${item.inTime || '未定'}〜${item.outTime || '未定'}\n場所：${item.location || '未定'}\n\nご確認のほど、よろしくお願いいたします。`;
        } else if (item.status === "発注書送信待ち") {
          // ★追加: 発注書送付用のメールテンプレート
          subject = `【発注書送付】${item.projectName}`;
          body = `${item.castName} 様\n\nお世話になっております。\n株式会社GOKKOです。\n\n${item.projectName} の発注書をお送りいたします。\n添付ファイルをご確認のほど、よろしくお願いいたします。\n\n引き続きよろしくお願いいたします。`;
        } else if (item.status === "メイキング共有待ち") {
          subject = `【メイキング共有】${item.projectName}`;
          body = `${item.castName} 様\n\nお世話になっております。\n株式会社GOKKOです。\n\n${item.projectName} のメイキング映像が完成いたしました。\n以下のURLよりご確認いただけます。\n\n${item.makingUrl || '(URL)'}\n\nご確認のほど、よろしくお願いいたします。`;
        } else if (item.status === "投稿日連絡待ち") {
          subject = `【投稿日連絡】${item.projectName}`;
          body = `${item.castName} 様\n\nお世話になっております。\n株式会社GOKKOです。\n\n${item.projectName} の投稿日が決定いたしました。\n\n投稿日：${item.postDate || '(日付)'}\n\nご確認のほど、よろしくお願いいたします。`;
        } else {
          // Default
          subject = `【連絡】${item.projectName}`;
          body = `${item.castName} 様\n\nお世話になっております。\n株式会社GOKKOです。\n\n（本文）\n\nよろしくお願いいたします。`;
        }

        // Find email from castingData (Column U) - redundant if item is from castingData but safe
        const originalRec = castingData.find(c => c.castingId === castingId);
        // ★修正: キャストDBからも検索してフォールバック
        const castInfo = castData.find(c => c.castId === (originalRec?.castId || item.castId));
        const castEmail = originalRec?.email || item.email || castInfo?.email || "";

        modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">メール作成</h3>
                <button class="text-gray-500 hover:text-gray-700" onclick="document.getElementById('shoot-mail-modal').classList.add('hidden')">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">送信先 (To)</label>
                    <div class="flex gap-2">
                        <input type="text" id="mail-to-input" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 bg-gray-50" value="${castEmail}" readonly>
                        <button class="mt-1 px-3 py-2 bg-gray-200 rounded hover:bg-gray-300 text-sm" onclick="navigator.clipboard.writeText(document.getElementById('mail-to-input').value); showMessage('メールアドレスをコピーしました')">コピー</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">件名</label>
                    <input type="text" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" value="${subject}">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">本文</label>
                    <textarea class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 h-64">${body}</textarea>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50" onclick="document.getElementById('shoot-mail-modal').classList.add('hidden')">キャンセル</button>
                <button class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700" onclick="copyToClipboardAndClose()">コピーして閉じる（ステータス更新）</button>
            </div>
        </div>
      `;
        modal.classList.remove('hidden');
      };

      window.copyToClipboardAndClose = async function () {
        const modal = document.getElementById('shoot-mail-modal');
        const textarea = modal.querySelector('textarea');

        if (textarea) {
          textarea.select();
          document.execCommand('copy');
          showMessage("本文をクリップボードにコピーしました");
        }

        // Auto Update Status
        const castingId = modal.dataset.castingId;
        const currentStatus = modal.dataset.currentStatus;
        const isCastingItem = modal.dataset.isCastingItem === "true";

        if (castingId && currentStatus) {
          let nextStatus = "";

          if (isCastingItem && ORDER_WAIT_STATUSES.includes(currentStatus)) {
            nextStatus = "打診中";
          } else if (currentStatus === "香盤連絡待ち") {
            nextStatus = "発注書送信待ち";
          } else if (currentStatus === "発注書送信待ち") {
            nextStatus = "メイキング共有待ち";
          } else if (currentStatus === "メイキング共有待ち") {
            nextStatus = "投稿日連絡待ち";
          } else if (currentStatus === "投稿日連絡待ち") {
            nextStatus = "完了";
          }

          if (nextStatus) {
            if (isCastingItem) {
              // Call Casting Status Update API
              await changeCastingStatus(castingId, nextStatus, "メール作成による自動更新");
            } else {
              // Call Shooting Contact Update API
              await updateShootingContactStatus(castingId, nextStatus);
            }
          }
        }

        modal.classList.add('hidden');
      };

      function openShootStatusModal(castingId, currentStatus) {
        // Legacy manual update if needed, but "Copy" is now the primary driver.
        // Keeping this for manual override.
        let nextStatus = "";
        if (currentStatus === "香盤連絡待ち") nextStatus = "メイキング共有待ち";
        else if (currentStatus === "メイキング共有待ち") nextStatus = "投稿日連絡待ち";
        else if (currentStatus === "投稿日連絡待ち") nextStatus = "完了";

        if (!nextStatus) return;

        if (confirm(`ステータスを「${nextStatus}」に進めますか？`)) {
          updateShootingContactStatus(castingId, nextStatus);
        }
      }

      async function updateShootingContactStatus(castingId, newStatus) {
        try {
          const res = await fetch("/api/shooting_contact/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ castingId, status: newStatus })
          });
          if (res.ok) {
            showMessage(`ステータスを「${newStatus}」に更新しました`);
            loadShootingContactPage(); // Reload to reflect changes
          } else {
            showMessage("更新に失敗しました", "error");
          }
        } catch (e) {
          console.error(e);
          showMessage("エラーが発生しました", "error");
        }
      }

      // Generic Update Function for Shooting Contact Fields
      window.updateShootingContactFields = async function (id, fields) {
        try {
          // Calculate cost if IN/OUT changed (Simple logic: just log for now, or implement if rate is known)
          // For now just save the fields

          const payload = {
            id: id,
            ...fields
          };

          // If cost is not manually set but IN/OUT are, we could try to auto-calc here
          // But we don't have hourly rate. So we skip auto-calc for now.

          const res = await fetch("/api/shooting_contact/status", { // Reusing status endpoint or create new?
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (!res.ok) {
            throw new Error("Update failed");
          }
          // Optional: Show toast
        } catch (e) {
          console.error(e);
          showMessage("更新に失敗しました", "error");
        }
      };

      // Sync Function (GAS Trigger)
      window.syncShootingSchedule = async function (btn, syncType = 'schedule') {
        let label = "香盤DB";
        if (syncType === 'making') label = "メイキングDB";
        if (syncType === 'post_date') label = "投稿日DB";

        if (!confirm(`${label}から最新情報を取得して同期しますか？\n(GASスクリプトを実行します)`)) return;

        const originalContent = btn ? btn.innerHTML : `${label}と同期`;
        if (btn) {
          btn.disabled = true;
          btn.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> 同期中...`;
        }

        const loading = document.getElementById("shoot-contact-loading");
        if (loading) loading.classList.remove('hidden');

        try {
          const res = await fetch(`/api/sync/gas?type=${syncType}`, { method: "POST" });
          if (res.ok) {
            const data = await res.json();
            const updatedCount = data.gas_response?.updatedRows ?? 0;
            showMessage(`同期が完了しました（更新: ${updatedCount}件）`, "success");

            await loadShootingContactPage();
          } else {
            const err = await res.json();
            showMessage(`同期に失敗しました: ${err.detail || 'Unknown error'}`, "error");
          }
        } catch (e) {
          console.error(e);
          showMessage("同期リクエスト中にエラーが発生しました", "error");
        } finally {
          if (loading) loading.classList.add('hidden');
          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalContent;
          }
        }
      };



      // ========= New Cart UI (Drag & Drop) =========
      let cartProjects = []; // Array of { id, title, roles: [{ id, name, type, note, castIds: [] }] }

      function renderCartModal() {
        const modal = document.getElementById('cart-modal');
        if (!modal) return;

        // Initialize cartProjects if empty (first open)
        initCartProjects();

        renderNewCartModal(modal);
      }
      window.submitNewOrder = async function () {
        // 1. Auth Check (Auto-Login attempt / サイレントリフレッシュ)
        // ここでトークン切れなら再取得を試みます
        const isAuth = await ensureAuth();
        if (!isAuth) {
          alert("ログアウト状態のため送信できません。再ログインしてください。");
          handleAuthClick();
          return;
        }

        // ■■■ 追加: 画面更新前にファイルを退避 ■■■
        const fileInput = document.getElementById('order-pdf-file');
        if (fileInput && fileInput.files.length > 0) {
          cartMeta.pdfFiles = fileInput.files;
          console.log("Files saved to memory:", cartMeta.pdfFiles.length);
        }
        // ■■■ 追加ここまで ■■■

        // Cleanup: 役名などが空の無効なデータを掃除
        cartProjects = cartProjects.map(p => {
          const validRoles = p.roles.filter(r => r.name.trim() && r.castIds.length > 0);
          return { ...p, roles: validRoles };
        }).filter(p => p.roles.length > 0);

        // カート画面を再描画（掃除後の状態にするため）
        renderCartModal();

        if (cartProjects.length === 0) {
          showMessage('有効なオーダー（役名とキャストが入力されたもの）がありません。', 'error');
          return;
        }

        // Validate
        for (const p of cartProjects) {
          if (!p.title.trim()) {
            showMessage('作品名が入力されていないものがあります。', 'error');
            return;
          }
        }

        // ★ここで確認モーダルを開く
        renderConfirmationModal();
      }

      function renderConfirmationModal() {
        const modal = document.getElementById('confirmation-modal');
        if (!modal) return;

        // 【修正】データソースの優先順位を変更
        // 新しいDrag&Dropカート(cartProjects)がある場合はそこからタイトルを取得
        let mainProjectName = '';
        if (cartProjects && cartProjects.length > 0) {
          mainProjectName = cartProjects[0].title;
        } else if (cartMeta && cartMeta.projectNames && cartMeta.projectNames[0]) {
          // 古いフローのバックアップ
          mainProjectName = cartMeta.projectNames[0];
        }

        const booked = currentUser?.email || '';

        // バリデーション修正
        if (!mainProjectName) {
          showMessage('作品名が入力されていません。', 'error');
          return;
        }
        if (!booked) {
          // ensureAuthでチェック済みのはずだが念の為
          showMessage('ログイン情報が取得できませんでした。もう一度サインインしてください。', 'error');
          return;
        }

        modal.innerHTML = `
      <div class="bg-white rounded-lg shadow-xl max-w-lg w-full p-6">
        <h3 class="text-xl font-bold mb-4">最終確認</h3>
        <p class="text-sm text-gray-600 mb-4">作品名：<span class="font-bold text-black">${mainProjectName}</span> 他</p>
        
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700">インティマシーシーンの有無</label>
            <div class="mt-2 flex space-x-4">
              <label class="inline-flex items-center">
                <input type="radio" name="intimacy" value="あり" class="form-radio">
                <span class="ml-2 font-bold text-red-600">あり</span>
              </label>
              <label class="inline-flex items-center">
                <input type="radio" name="intimacy" value="なし" class="form-radio" checked>
                <span class="ml-2">なし</span>
              </label>
              <label class="inline-flex items-center">
                <input type="radio" name="intimacy" value="未定" class="form-radio">
                <span class="ml-2">未定</span>
              </label>
            </div>
            <p class="text-xs text-gray-500 mt-1">※「あり」を選択すると、備考欄に自動追記されます。</p>
          </div>
          <div class="bg-yellow-50 p-3 rounded border border-yellow-200">
            <label class="flex items-start cursor-pointer">
              <input id="child-actor-check" type="checkbox"
                     class="mt-1 h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
              <span class="ml-3 text-sm text-gray-700 leading-snug">
                <strong>未成年者（18歳未満）</strong>が含まれる場合、<br>
                労働基準法（深夜労働の禁止・労働時間制限など）および関連法規を遵守した撮影計画であることを確認しました。
              </span>
            </label>
          </div>
        </div>
        <div class="mt-6 flex justify-end gap-3">
          <button id="confirm-cancel" class="px-4 py-2 rounded-md border border-gray-300 hover:bg-gray-50">キャンセル</button>
          <button id="confirm-final" class="px-6 py-2 rounded-md bg-blue-600 text-white font-bold shadow hover:bg-blue-700">
            同意して送信
          </button>
        </div>
      </div>
    `;
        modal.classList.remove('hidden');

        // イベント設定
        modal.querySelector('#confirm-cancel').addEventListener('click', closeConfirmationModal);

        // 送信ボタンクリック時
        modal.querySelector('#confirm-final').addEventListener('click', async () => {
          const intimacyValue = modal.querySelector('input[name="intimacy"]:checked').value;
          const childActorConfirmed = modal.querySelector('#child-actor-check').checked;

          // 子役が含まれているか簡易チェック (cart内の全キャストを対象)
          const hasChildActor = Object.values(cart).some(item =>
            item.cast && item.cast.age !== null && item.cast.age < 18
          );

          if (hasChildActor && !childActorConfirmed) {
            showMessage(
              '未成年キャストが含まれています。法令遵守の確認にチェックを入れてください。',
              'error'
            );
            return;
          }

          // ★ここで実際の送信処理 (processNewOrderFromModal) を呼ぶ
          await processNewOrderFromModal({
            intimacy: intimacyValue === 'あり',
            childConfirmed: childActorConfirmed
          });
        });
      }

      function closeConfirmationModal() {
        const modal = document.getElementById('confirmation-modal');
        if (modal) modal.classList.add('hidden');
      }

      // Progress Bar Functions
      function showProgressBar(message = "処理中...", percent = 0) {
        const modal = document.getElementById('progress-modal');
        if (modal) {
          modal.classList.remove('hidden');
          updateProgressBar(message, percent);
        }
      }

      function updateProgressBar(message, percent) {
        const titleEl = document.getElementById('progress-title');
        const msgEl = document.getElementById('progress-message');
        const barEl = document.getElementById('progress-bar-fill');
        const percentEl = document.getElementById('progress-percent');

        if (titleEl) titleEl.textContent = "処理中..."; // Or dynamic title
        if (msgEl) msgEl.textContent = message;
        if (barEl) barEl.style.width = `${percent}%`;
        if (percentEl) percentEl.textContent = `${percent}%`;
      }

      function hideProgressBar() {
        const modal = document.getElementById('progress-modal');
        if (modal) modal.classList.add('hidden');
      }

      // モーダルから呼ばれるラッパー関数
      async function processNewOrderFromModal(options) {
        const teamName = selectedShooting ? selectedShooting.team : (currentUser?.name || '不明');
        const pageId = selectedShooting ? selectedShooting.pageId : '';
        const notionUrl = pageId ? `https://www.notion.so/${pageId.replace(/-/g, '')}` : '';

        // CC設定
        let ccString = "";
        if (selectedShooting && window.internalCastMap) {
          const names = [];
          if (selectedShooting.cd) names.push(...selectedShooting.cd.split(/[,、]/).map(s => s.trim()));
          if (selectedShooting.fd) names.push(...selectedShooting.fd.split(/[,、]/).map(s => s.trim()));
          const ccIds = new Set();
          names.forEach(name => {
            if (window.internalCastMap.has(name)) ccIds.add(window.internalCastMap.get(name));
          });
          if (ccIds.size > 0) ccString = Array.from(ccIds).map(uid => `<@${uid}>`).join(' ');
        }

        // showLoader(true); // Disable global loader in favor of progress bar
        showProgressBar("処理を開始します...", 10);

        try {
          await processNewOrder({
            accountName: teamName,
            pageId: pageId,
            notionUrl: notionUrl,
            projects: cartProjects,
            ccString: ccString,
            slackThreadTs: isAdditionalOrderMode && additionalOrderContext ? additionalOrderContext.slackThreadTs : null,
            // ★追加オプション
            intimacy: options.intimacy
          });

          updateProgressBar("完了しました", 100);
          await new Promise(r => setTimeout(r, 500)); // Show 100% briefly

          closeCartModal();
          closeConfirmationModal(); // モーダルも閉じる

          // Reset
          cart = {};
          cartProjects = [];
          updateCartCount();
          displayAvailableCasts();

          showMessage('オーダーを送信しました。', 'success');

          // ステータス反映のため少し待って再読み込み
          setTimeout(() => loadAllData(), 2000);

        } catch (e) {
          console.error(e);
          if (e.status === 401 || e.result?.error?.code === 401) {
            // ensureAuthでカバーしているはずだが念の為
            showMessage('認証エラーが発生しました。リロードして再ログインしてください。', 'error');
          } else {
            showMessage('オーダー送信に失敗しました: ' + (e.message || 'Unknown error'), 'error');
          }
        } finally {
          // showLoader(false);
          hideProgressBar();
        }
      }

      // 実際のデータ構築とAPI送信を行う関数
      async function processNewOrder(data) {
        const shootDate = selectedShooting ? selectedShooting.date : (selectedDates[0] || '');
        const nowISO = new Date().toISOString();
        const updaterEmail = currentUser?.email || '';
        const internalEvents = [];
        const tempAssignments = {};

        // Collect all orders & Apply Intimacy Note
        const allOrders = data.projects.flatMap(proj =>
          proj.roles.flatMap((role, rIdx) =>
            role.castIds.map((cid, cIdx) => {
              const cast = cart[cid]?.cast;
              const isInternal = cast?.isInternal;

              // ★ インティマシーシーンありの場合、備考に追記
              let finalNote = role.note || '';
              if (data.intimacy) {
                finalNote = "【インティマシーシーンあり】\n" + finalNote;
              }

              return {
                castingId: 'temp_' + Date.now() + '_' + Math.random(),
                roleName: role.name,
                castName: cast?.name || '不明',
                rank: cIdx + 1,
                note: finalNote.trim(),
                projectName: proj.title,
                slack_user_id: isInternal ? cast.slackMentionId : null,
                castId: cid,
                cast: cast,
                type: role.type
              };
            })
          )
        );

        if (allOrders.length === 0) return;

        const uniqueProjectNames = [...new Set(data.projects.map(p => p.title))].join(' / ');

        // 2. Send Slack Notification Payload
        const payload = {
          accountName: data.accountName,
          projectName: uniqueProjectNames,
          projectId: data.pageId,
          dateRanges: [shootDate],
          orders: allOrders.map(o => ({
            castingId: o.castingId,
            roleName: o.roleName,
            castName: o.castName,
            rank: o.rank,
            note: o.note,
            projectName: o.projectName,
            slack_user_id: o.slack_user_id
          })),
          orderType: "pattern_a",
          ccString: data.ccString || "",
          slackThreadTs: data.slackThreadTs || null
        };

        // PDF Upload - Multiple Files Support
        // ■■■ 修正: 退避したファイル情報を使用 ■■■
        // まず退避データを確認し、なければDOMから取得（フォールバック）
        let files = cartMeta.pdfFiles;

        if (!files || files.length === 0) {
          const fileInput = document.getElementById('order-pdf-file');
          files = fileInput?.files;
        }
        // ■■■ 修正ここまで ■■■

        const formData = new FormData();
        formData.append('payload_str', JSON.stringify(payload));

        // 【修正】複数ファイルをループしてFormDataに追加
        if (files && files.length > 0) {
          for (let i = 0; i < files.length; i++) {
            formData.append('files', files[i], files[i].name);
          }
        }

        // ■ 追加: デバッグ用ログ出力（コンソールで確認用）
        console.log("--- Debug: FormData Sending Check ---");
        let fileCount = 0;
        for (let pair of formData.entries()) {
          if (pair[0] === 'files') {
            fileCount++;
            console.log(`Key: ${pair[0]}, File: ${pair[1].name}, Size: ${pair[1].size}`);
          } else {
            console.log(`Key: ${pair[0]}, Value: [Payload String]`);
          }
        }
        if (fileCount === 0) console.warn("⚠️ FormDataにファイルが含まれていません！");

        let slackThreadTs = '';
        let slackPermalink = '';

        updateProgressBar("Slackに通知を送信中...", 30);

        try {
          const slackRes = await fetch('/api/notify/order_created', {
            method: 'POST',
            body: formData
          });

          if (!slackRes.ok) throw new Error('Slack notification failed');
          const slackData = await slackRes.json();

          slackThreadTs = data.slackThreadTs || slackData.ts;
          slackPermalink = slackData.permalink;
        } catch (e) {
          console.error("Slack notification error:", e);
          // Slack失敗でもシート書き込みは続行する方針なら続行、そうでなければthrow
          // ここでは続行しつつエラー表示などのハンドリングが望ましいが、
          // 既存ロジックに合わせて続行します。
        }

        updateProgressBar("スプレッドシートに書き込み中...", 60);
        // 3. Prepare Sheet Rows (以下、既存コードと同様)
        const newRows = [];
        const castGroups = new Map();
        allOrders.forEach(o => {
          if (!castGroups.has(o.castId)) castGroups.set(o.castId, []);
          castGroups.get(o.castId).push(o);
        });

        for (const [castId, orders] of castGroups) {
          const firstOrder = orders[0];
          const cast = firstOrder.cast;

          const mergedProjectName = [...new Set(orders.map(o => o.projectName))].join(' / ');
          const mergedRoleName = orders.map(o => o.roleName).join(' / ');
          const mergedType = [...new Set(orders.map(o => o.type))].join(' / ');
          const mergedNote = orders.map(o => o.note).filter(n => n).join(' / ');

          const minRank = Math.min(...orders.map(o => o.rank));
          const castingId = 'casting_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          const castPriority = getNextCastPriority(castId, shootDate, shootDate, tempAssignments);
          tempAssignments[`${castId}_${shootDate}_${shootDate}`] = castPriority;

          const initialStatus = cast.isInternal ? '打診中' : 'オーダー待ち';

          if (cast.isInternal) {
            internalEvents.push({
              accountName: data.accountName,
              projectName: mergedProjectName,
              roleName: mergedRoleName,
              mainSub: mergedType,
              castingId: castingId,
              status: initialStatus,
              start: shootDate,
              end: shootDate,
              email: cast.email,
            });
          }

          const structureData = orders.map(o => ({
            project: o.projectName,
            role: o.roleName,
            rank: o.rank,
            type: o.type,
            note: o.note
          }));
          const structureJson = JSON.stringify(structureData);

          newRows.push([
            castingId, data.accountName, mergedProjectName, mergedRoleName,
            cast.castId, cast.name, shootDate, shootDate, minRank.toString(),
            initialStatus, mergedNote, slackThreadTs, slackPermalink,
            mergedType, '', data.pageId, nowISO, updaterEmail, castPriority,
            cast.isInternal ? '内部' : '外部', cast.email || '', '', structureJson
          ]);
        }

        // 4. Batch Append
        if (newRows.length > 0) {
          const appendResult = await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID,
            range: 'キャスティングリスト!A2',
            valueInputOption: 'USER_ENTERED',
            insertDataOption: 'INSERT_ROWS',
            resource: { values: newRows }
          });

          const updatedRange = appendResult.result.updates.updatedRange;
          const match = updatedRange.match(/!A(\d+):/);
          if (match) {
            const startRow = parseInt(match[1], 10);
            const rowNumberByCastingId = new Map();
            for (let i = 0; i < newRows.length; i++) {
              if (newRows[i][0]) rowNumberByCastingId.set(newRows[i][0], startRow + i);
            }
            internalEvents.forEach(ev => {
              ev.rowNumber = rowNumberByCastingId.get(ev.castingId) || null;
            });
            await createInternalHoldEvents(internalEvents);
          }
        }
      }

      window.closeCartModal = function () {
        const modal = document.getElementById('cart-modal');
        if (!modal) return;
        modal.classList.add('hidden');
        modal.innerHTML = '';
        // Reset state? Maybe keep it if user accidentally closes?
        // For now, let's keep it but maybe we should clear it on successful order.
      }

      function renderNewCartModal(modal) {
        const teamName = selectedShooting ? selectedShooting.team : (currentUser?.name || '不明');
        const pageId = selectedShooting ? selectedShooting.pageId : '未選択';

        // Cast Pool (only those in cart but not assigned to any role yet?)
        // Or just list all in cart and allow dragging?
        // User said: "カートに追加したキャストの名前が下に...並んでいる想定"
        // Let's list all casts in `cart`.
        // If assigned, maybe dim them or remove them?
        // "追加した人は削除も可能" implies we move them.
        // Let's assume "Pool" contains unassigned casts.

        // Cast Pool: Show ALL casts in cart (User request: "消えないようにして欲しい")
        const allCartCastIds = Object.keys(cart);
        const poolCastIds = allCartCastIds; // No filtering

        modal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl h-[90vh] flex flex-col">
            <!-- Header -->
            <div class="flex items-center justify-between p-4 border-b bg-gray-50">
              <div>
                <div class="text-sm text-gray-500">アカウント名: <span class="font-bold text-gray-800">${teamName}</span></div>
                <div class="text-sm text-gray-500">PageID: <span class="font-mono text-gray-800">${pageId}</span></div>
              </div>
              <button onclick="closeCartModal()" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>

            <!-- Body -->
            <div class="flex-grow flex overflow-hidden">
              <!-- Left: Cast Pool -->
              <div class="w-1/4 border-r bg-gray-50 flex flex-col">
                <div class="p-3 font-bold text-gray-700 border-b">キャストプール</div>
                <div id="cart-cast-pool" class="flex-grow overflow-y-auto p-2 space-y-2">
                  ${poolCastIds.map(cid => renderDraggableCast(cid)).join('')}
                  ${poolCastIds.length === 0 ? '<div class="text-xs text-gray-400 text-center mt-4">キャストがいません</div>' : ''}
                </div>
              </div>

              <!-- Right: Projects -->
              <div class="w-3/4 flex flex-col bg-white">
                <div id="cart-projects-container" class="flex-grow overflow-y-auto p-4 space-y-6">
                  ${cartProjects.map(p => renderCartProject(p)).join('')}
                </div>
                
                <!-- Add Project Button -->
                <div class="p-4 border-t bg-gray-50 flex justify-center">
                  <button onclick="addCartProject()" class="flex items-center gap-2 text-blue-600 hover:text-blue-800 font-semibold">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    作品を追加
                  </button>
                </div>
              </div>
            </div>

            <!-- Footer -->
            <div class="p-4 border-t bg-white flex justify-between items-center">
              <div class="flex items-center gap-2">
                 <label class="text-sm font-bold text-gray-600">PDF添付:</label>
                 <input type="file" id="order-pdf-file" accept="application/pdf" multiple class="text-sm text-gray-600 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
              </div>
              <div class="flex gap-3">
                <button onclick="closeCartModal()" class="px-4 py-2 rounded-md border border-gray-300">閉じる</button>
                <button onclick="submitNewOrder()" class="px-6 py-2 rounded-md bg-blue-600 text-white font-bold shadow hover:bg-blue-700">
                  オーダー送信
                </button>
              </div>
            </div>
          </div>
        `;

        // Setup Drag & Drop
        setupDragAndDrop();
      }

      function renderDraggableCast(castId) {
        const c = cart[castId]?.cast;
        if (!c) return '';
        return `
          <div class="draggable-cast bg-white p-2 rounded shadow-sm border cursor-move flex items-center gap-2 hover:bg-blue-50 justify-between" draggable="true" data-cast-id="${castId}">
            <div class="flex items-center gap-2">
              <div class="w-8 h-8 rounded-full bg-gray-200 overflow-hidden flex-shrink-0">
                ${c.imageUrl ? `<img src="${c.imageUrl}" class="w-full h-full object-cover">` : ''}
              </div>
              <div class="text-sm truncate font-medium">${c.name}</div>
            </div>
            <button onclick="removeCastFromCart('${castId}')" class="text-gray-400 hover:text-red-500 text-xs font-bold px-1" title="カートから削除">✕</button>
          </div>
        `;
      }

      window.removeCastFromCart = function (castId) {
        if (cart[castId]) {
          delete cart[castId];
          updateCartCount();
          renderCartModal(); // Re-render modal to update pool
        }
      };

      function renderCartProject(project) {
        return `
          <div class="border rounded-lg p-4 bg-gray-50 relative group" data-project-id="${project.id}">
            <div class="mb-3 flex items-center gap-2">
              <label class="text-sm font-bold text-gray-600 w-16">作品名</label>
              <input type="text" class="flex-grow border rounded px-2 py-1 text-sm font-bold" 
                     value="${project.title}" onchange="updateProjectTitle('${project.id}', this.value)" placeholder="作品名を入力">
              <button onclick="removeCartProject('${project.id}')" class="text-red-400 hover:text-red-600 p-1" title="作品を削除">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
              </button>
            </div>

            <div class="space-y-3 pl-4 border-l-2 border-gray-200">
              ${project.roles.map((role, idx) => renderCartRole(project.id, role, idx)).join('')}
            </div>

            <div class="mt-3 pl-4">
              <button onclick="addCartRole('${project.id}')" class="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                役名を追加
              </button>
            </div>
          </div>
        `;
      }

      function renderCartRole(projectId, role, index) {
        const rankLabel = `第${index + 1}候補`; // Or just sequential? User said "左から順に第1候補、第2候補" but UI is vertical list of roles?
        // Wait, "作品名...役名...〇〇 / 〇〇 / 〇〇（ドラッグ&ドロップで追加する形）"
        // Ah, one role can have multiple candidates (1st, 2nd...)?
        // "そのカラムは第１候補となっていて、カートに追加された人をドラッグして追加できる。"
        // "左から順に第1候補、第2候補として保存する。"
        // So: Role Row -> [Candidate 1] [Candidate 2] ...

        return `
          <div class="bg-white border rounded p-3 shadow-sm" data-role-id="${role.id}">
            <div class="flex items-center gap-2 mb-2">
              <input type="text" class="border rounded px-2 py-1 text-sm w-1/3" 
                     value="${role.name}" onchange="updateRoleName('${projectId}', '${role.id}', this.value)" placeholder="役名">
              
              <select class="border rounded px-2 py-1 text-sm w-24" onchange="updateRoleType('${projectId}', '${role.id}', this.value)">
                <option value="メイン" ${role.type === 'メイン' ? 'selected' : ''}>メイン</option>
                <option value="その他" ${role.type === 'その他' ? 'selected' : ''}>その他</option>
              </select>

              <input type="text" class="flex-grow border rounded px-2 py-1 text-sm" 
                     value="${role.note}" onchange="updateRoleNote('${projectId}', '${role.id}', this.value)" placeholder="備考">

              <button onclick="removeCartRole('${projectId}', '${role.id}')" class="text-gray-400 hover:text-red-500">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>

            <!-- Drop Zone for Candidates -->
            <div class="role-drop-zone min-h-[50px] bg-gray-50 border-2 border-dashed border-gray-200 rounded flex items-center gap-2 p-2 overflow-x-auto"
                 data-project-id="${projectId}" data-role-id="${role.id}">
              ${role.castIds.map((cid, cIdx) => `
                <div class="relative group bg-white border rounded px-2 py-1 flex items-center gap-2 shadow-sm min-w-[100px]">
                  <span class="text-xs font-bold text-gray-500 mr-1">${cIdx + 1}</span>
                  <span class="text-sm truncate max-w-[100px]">${cart[cid]?.cast?.name}</span>
                  <button onclick="removeCastFromRole('${projectId}', '${role.id}', '${cid}')" class="ml-auto text-gray-400 hover:text-red-500">
                    &times;
                  </button>
                </div>
              `).join('')}
              <div class="text-xs text-gray-400 italic flex-shrink-0">ここへドラッグ</div>
            </div>
</content>
      </div>
    `;
      }

      // --- State Updaters ---
      window.addCartProject = function () {
        const newProj = {
          id: 'proj_' + Date.now(),
          title: '',
          roles: []
        };
        // Default 3 roles
        for (let i = 0; i < 3; i++) {
          newProj.roles.push({
            id: 'role_' + Date.now() + '_' + i,
            name: '',
            type: 'その他',
            note: '',
            castIds: []
          });
        }
        cartProjects.push(newProj);
        renderCartModal();
      };

      // Initialize cartProjects with default state if empty
      function initCartProjects() {
        if (cartProjects.length === 0) {
          for (let i = 0; i < 2; i++) {
            window.addCartProject(); // Use window.addCartProject to ensure it's called correctly
          }
        }
      }
      window.removeCartProject = function (pid) {
        cartProjects = cartProjects.filter(p => p.id !== pid);
        renderCartModal();
      };
      window.updateProjectTitle = function (pid, val) {
        const p = cartProjects.find(p => p.id === pid); if (p) p.title = val;
      };
      window.addCartRole = function (pid) {
        const p = cartProjects.find(p => p.id === pid);
        if (p) {
          p.roles.push({ id: 'role_' + Date.now(), name: '', type: 'その他', note: '', castIds: [] });
          renderCartModal();
        }
      };
      window.removeCartRole = function (pid, rid) {
        const p = cartProjects.find(p => p.id === pid);
        if (p) {
          p.roles = p.roles.filter(r => r.id !== rid);
          renderCartModal();
        }
      };
      window.updateRoleName = function (pid, rid, val) {
        const r = findRole(pid, rid); if (r) r.name = val;
      };
      window.updateRoleType = function (pid, rid, val) {
        const r = findRole(pid, rid); if (r) r.type = val;
      };
      window.updateRoleNote = function (pid, rid, val) {
        const r = findRole(pid, rid); if (r) r.note = val;
      };
      window.removeCastFromRole = function (pid, rid, cid) {
        const r = findRole(pid, rid);
        if (r) {
          r.castIds = r.castIds.filter(id => id !== cid);
          renderCartModal();
        }
      };

      function findRole(pid, rid) {
        const p = cartProjects.find(p => p.id === pid);
        return p ? p.roles.find(r => r.id === rid) : null;
      }

      // --- Drag & Drop Handlers ---
      function setupDragAndDrop() {
        const draggables = document.querySelectorAll('.draggable-cast');
        const dropZones = document.querySelectorAll('.role-drop-zone');

        draggables.forEach(d => {
          d.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', d.dataset.castId);
            d.classList.add('opacity-50');
          });
          d.addEventListener('dragend', e => {
            d.classList.remove('opacity-50');
          });
        });

        dropZones.forEach(z => {
          z.addEventListener('dragover', e => {
            e.preventDefault(); // Allow drop
            z.classList.add('bg-blue-50', 'border-blue-300');
          });
          z.addEventListener('dragleave', e => {
            z.classList.remove('bg-blue-50', 'border-blue-300');
          });
          z.addEventListener('drop', e => {
            e.preventDefault();
            z.classList.remove('bg-blue-50', 'border-blue-300');
            const castId = e.dataTransfer.getData('text/plain');
            const pid = z.dataset.projectId;
            const rid = z.dataset.roleId;

            if (castId && pid && rid) {
              const role = findRole(pid, rid);
              if (role && !role.castIds.includes(castId)) {
                role.castIds.push(castId);
                renderCartModal();
              }
            }
          });
        });
      }



      // C-2: 新規外部キャスト作成モーダル
      async function openNewExternalCastModal() {
        const modal = document.getElementById('new-external-cast-modal');
        if (!modal) return;

        modal.innerHTML = `
          < div class="bg-white rounded-lg shadow-xl max-w-md w-full p-5" >
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-bold">新規外部キャストを追加</h3>
          <button id="new-cast-close" class="text-gray-600 hover:text-gray-800">&times;</button>
        </div>
        <div class="space-y-3">
          <div>
            <label class="text-sm text-gray-700">名前（必須）</label>
            <input id="new-cast-name" type="text" class="mt-1 w-full p-2 border rounded-md" />
          </div>
          <div>
            <label class="text-sm text-gray-700">性別</label>
            <select id="new-cast-gender" class="mt-1 w-full p-2 border rounded-md">
              <option value="">未選択</option>
              <option value="男性">男性</option>
              <option value="女性">女性</option>
            </select>
          </div>
          <div>
            <label class="text-sm text-gray-700">所属</label>
            <input id="new-cast-agency" type="text" class="mt-1 w-full p-2 border rounded-md" placeholder="例：フリー / 〇〇プロダクション" />
          </div>
          <div>
            <label class="text-sm text-gray-700">メールアドレス</label>
            <input id="new-cast-email" type="email" class="mt-1 w-full p-2 border rounded-md" />
          </div>
          <div>
            <label class="text-sm text-gray-700">備考</label>
            <textarea id="new-cast-notes" class="mt-1 w-full p-2 border rounded-md" rows="2"></textarea>
          </div>
        </div>
        <div class="mt-4 flex justify-end gap-3">
          <button id="new-cast-cancel" class="px-4 py-2 rounded-md border border-gray-300">キャンセル</button>
          <button id="new-cast-save" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">保存</button>
        </div>
      </div > `;

        modal.classList.remove('hidden');

        modal.querySelector('#new-cast-close')?.addEventListener('click', () => closeNewExternalCastModal());
        modal.querySelector('#new-cast-cancel')?.addEventListener('click', () => closeNewExternalCastModal());
        modal.querySelector('#new-cast-save')?.addEventListener('click', async () => {
          await saveNewExternalCast();
        });
      }

      function closeNewExternalCastModal() {
        const modal = document.getElementById('new-external-cast-modal');
        if (!modal) return;
        modal.classList.add('hidden');
        modal.innerHTML = '';
      }

      async function saveNewExternalCast() {
        const name = document.getElementById('new-cast-name').value.trim();
        if (!name) {
          showMessage('名前は必須です。', 'error');
          return;
        }
        const gender = document.getElementById('new-cast-gender').value;
        const agency = document.getElementById('new-cast-agency').value.trim() || '外部';
        const email = document.getElementById('new-cast-email').value.trim();
        const notes = document.getElementById('new-cast-notes').value.trim();

        // 新規 castId は簡易に "ext_" + timestamp で生成
        const castId = 'ext_' + Date.now();

        try {
          showLoader(true);
          // スプレッドシート "キャストリスト" に 1 行追加
          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID,
            range: 'キャストリスト!A2',
            valueInputOption: 'USER_ENTERED',
            insertDataOption: 'INSERT_ROWS',
            resource: {
              values: [[
                castId,      // A: キャストID
                name,        // B: 名前
                gender,      // C: 性別
                '',          // D: 生年月日（未入力）
                agency,      // E: 事務所
                '',          // F: 画像URL
                0,           // G: 出演回数
                email,       // H: メール
                notes,       // I: 備考
                '外部',      // J: 内部/外部フラグ
                ''           // K: SlackメンションID
              ]]
            }
          });

          // ローカルの castData にも追加
          const newCast = {
            castId, name, gender, dateOfBirth: '', age: null,
            agency, imageUrl: '', appearanceCount: 0, email, notes,
            castType: '外部',
            isInternal: false,
            internalType: '外部',
            slackMentionId: '',
          };
          castData.push(newCast);

          // B: 作成と同時にカートへ追加
          addToCart(newCast.castId);

          closeNewExternalCastModal();
          showMessage('外部キャストをカートに追加しました。');
          displayAvailableCasts();
        } catch (e) {
          console.error(e);
          showMessage('外部キャストの追加に失敗しました。', 'error');
        } finally {
          showLoader(false);
        }
      }

      // ========= Cart Step1 / Step2 =========
      function renderCartStep1(modal) {
        modal.innerHTML = `
          < div class="bg-white rounded-lg shadow-xl max-w-lg w-full p-6" >
        <div class="flex items-center justify-between mb-4">
          <h3 class="text-xl font-bold">STEP1：オーダー情報の入力</h3>
          <button id="cart-step1-close" class="text-gray-500 hover:text-gray-700">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
          </button>
        </div>
        <div class="mb-4">
          <label class="block text-sm font-medium text-gray-700 mb-1">アカウント名（必須）</label>
          <input type="text" id="cart-account" class="w-full border rounded px-3 py-2" placeholder="アカウント名" value="${cartMeta.account || ''}">
        </div>
        <div class="grid grid-cols-1 gap-3 mb-4">
          <div>
            <label class="text-sm font-medium text-gray-700 mb-1">作品名1（必須）</label>
            <input type="text" id="cart-project-1" class="w-full border rounded px-3 py-2" placeholder="作品名1" value="${cartMeta.projectNames?.[0] || ''}">
          </div>
          <div>
            <label class="text-sm font-medium text-gray-700 mb-1">作品名2（任意）</label>
            <input type="text" id="cart-project-2" class="w-full border rounded px-3 py-2" placeholder="作品名2" value="${cartMeta.projectNames?.[1] || ''}">
          </div>
          <div>
            <label class="text-sm font-medium text-gray-700 mb-1">作品名3（任意）</label>
            <input type="text" id="cart-project-3" class="w-full border rounded px-3 py-2" placeholder="作品名3" value="${cartMeta.projectNames?.[2] || ''}">
          </div>
          <div class="mb-4">
            <label class="block text-sm font-medium text-gray-700 mb-1">Notion URL (任意)</label>
            <input type="text" id="cart-notion" class="w-full border rounded px-3 py-2" placeholder="https://www.notion.so/..." value="${cartMeta.notionUrl || ''}">
          </div>
          <div class="mb-6">
            <label class="block text-sm font-medium text-gray-700 mb-1">PDFファイル添付 (任意)</label>
            <input type="file" id="cart-pdf-file" accept="application/pdf" multiple class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
            <p class="text-xs text-gray-500 mt-1">※Slack通知のスレッドにアップロードされます。</p>
          </div>
          <div class="flex justify-end">
            <button id="cart-step1-next" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">次へ</button>
          </div>
        </div>
      </div >
          `;
        modal.classList.remove('hidden');

        // Restore file input if exists in memory (Note: file input value cannot be set programmatically for security, so we just keep the object in cartMeta)
        // If user re-selects, we update.

        modal.querySelector('#cart-step1-close')?.addEventListener('click', () => closeCartModal());

        modal.querySelector('#cart-step1-next').addEventListener('click', () => {
          const acc = document.getElementById('cart-account').value.trim();
          const p1 = document.getElementById('cart-project-1').value.trim();
          const p2 = document.getElementById('cart-project-2').value.trim();
          const p3 = document.getElementById('cart-project-3').value.trim();
          const not = document.getElementById('cart-notion').value.trim();
          const fileInput = document.getElementById('cart-pdf-file');

          if (!acc) { alert('アカウント名は必須です'); return; }
          if (!p1 && !p2 && !p3) { alert('作品名は少なくとも1つ入力してください'); return; }

          cartMeta.account = acc;
          cartMeta.projectNames = [p1, p2, p3];
          cartMeta.notionUrl = not;

          if (fileInput.files.length > 0) {
            cartMeta.pdfFiles = fileInput.files;
          }

          // A-1: 組み合わせ作品名を生成
          const baseTitles = cartMeta.projectNames
            .map(t => (t || '').trim())
            .filter(t => t);

          const comboTitles = [];
          // 2作品の組み合わせ
          if (baseTitles.length > 1) {
            for (let i = 0; i < baseTitles.length; i++) {
              for (let j = i + 1; j < baseTitles.length; j++) {
                comboTitles.push(`${baseTitles[i]}/${baseTitles[j]}`);
              }
            }
          }
          // 3作品すべての組み合わせ
          if (baseTitles.length === 3) {
            comboTitles.push(`${baseTitles[0]}/${baseTitles[1]}/${baseTitles[2]}`);
          }
          cartMeta.combinedProjectNames = comboTitles;

          cartStep = 2;
          renderCartModal();
        });
      }


      function renderCartStep2(modal) {
        const items = Object.values(cart);

        // A-2.1: 単体作品と組み合わせ作品を候補リスト化
        const baseTitles = (cartMeta.projectNames || []).map(t => t.trim()).filter(t => t);
        const comboTitles = cartMeta.combinedProjectNames || [];
        const allTitles = [...baseTitles, ...comboTitles];

        const projectOptions = allTitles
          .map(p => `<option value="${p}">${p}</option>`)
          .join('');

        modal.innerHTML = `
      <div class="bg-white rounded-lg shadow-xl max-w-4xl w-full p-6">
        <h3 class="text-xl font-bold mb-4">STEP2：キャスト情報の紐付け</h3>
        <div class="max-h-[70vh] overflow-y-auto">
          <table class="min-w-full text-sm">
            <thead>
              <tr class="bg-gray-100">
                <th class="px-4 py-2 text-left">キャスト名</th>
                <th class="px-4 py-2 text-left">作品名</th>
                <th class="px-4 py-2 text-left">区分</th>
                <th class="px-4 py-2 text-left">役名</th>
                <th class="px-4 py-2 text-left">候補順位</th>
                <th class="py-2 px-3 text-left">備考</th>
                <th class="py-2 px-3 text-center">削除</th>
              </tr>
            </thead>
            <tbody>
              ${items.map((item, i) => `
                <tr class="border-b" data-cart-item-id="${item.cast.castId}">
                  <td class="px-4 py-2 font-bold">${item.cast.name}</td>
                  <td class="py-2 px-3">
                    <select class="cart-item-project w-full p-1 border rounded">
                      <option value="">作品を選択</option>
                      ${projectOptions}
                    </select>
                  </td>
                  <td class="px-4 py-2">
                    <select class="cart-item-mainsub border rounded px-2 py-1" data-idx="${i}">
                        <option value="その他" ${item.mainSub === 'その他' ? 'selected' : ''}>その他</option>
                        <option value="メイン" ${item.mainSub === 'メイン' ? 'selected' : ''}>メイン</option>
                    </select>
                  </td>
                  <td class="py-2 px-3">
                    <input type="text" class="cart-item-role w-full p-1 border rounded"
                           value="${item.roleName || ''}" placeholder="役名を入力（例：女1）">
                  </td>
                  <td class="py-2 px-3">
                    <input type="number" class="cart-item-rank w-20 p-1 border rounded"
                           value="${item.rank || 1}" min="1">
                  </td>
                  <td class="py-2 px-3">
                    <input type="text" class="cart-item-note w-full p-1 border rounded"
                           value="${item.note || ''}" placeholder="備考">
                  </td>
                  <td class="py-2 px-3 text-center">
                    <button class="cart-item-remove text-red-500 hover:text-red-700">
                      &times;
                    </button>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
        <div class="mt-6 flex justify-between">
          <button id="cart-step2-back"
                  class="px-4 py-2 border rounded">戻る</button>
          <button id="cart-step2-confirm"
                  class="px-4 py-2 bg-blue-600 text-white rounded">
            内容を確認して確定へ
          </button>
        </div>
      </div>
    `;

        modal.classList.remove('hidden');

        // イベントリスナー
        modal.querySelector('#cart-step2-back')
          .addEventListener('click', () => {
            cartStep = 1;
            renderCartModal();
          });

        modal.querySelector('#cart-step2-confirm')
          .addEventListener('click', () => {
            // 最終確認モーダルを開く
            renderConfirmationModal();
          });

        modal.querySelectorAll('[data-cart-item-id]').forEach(row => {
          const castId = row.dataset.cartItemId;
          const item = cart[castId];
          if (!item) return;

          const projectEl = row.querySelector('.cart-item-project');
          const roleEl = row.querySelector('.cart-item-role');
          const rankEl = row.querySelector('.cart-item-rank');
          const noteEl = row.querySelector('.cart-item-note');
          const removeEl = row.querySelector('.cart-item-remove');

          // 初期値設定
          if (projectEl) {
            // item.projectName があればそれを選択、なければ基本作品の先頭
            projectEl.value = item.projectName || baseTitles[0] || '';
            // 初期読み込み時にもプレースホルダーを更新
            if (roleEl) {
              roleEl.placeholder = (projectEl.value || '').includes('/')
                ? "役名をスラッシュ区切りで入力（例：女1/友達）"
                : "役名を入力（例：女1）";
            }
          }

          // イベント
          projectEl.addEventListener('change', e => {
            item.projectName = e.target.value;
            // A-2.3: プレースホルダーを更新
            if (roleEl) {
              roleEl.placeholder = (e.target.value || '').includes('/')
                ? "役名をスラッシュ区切りで入力（例：女1/友達）"
                : "役名を入力（例：女1）";
            }
          });

          // ★追加: メイン/その他の変更を検知して保存する
          const mainSubEl = row.querySelector('.cart-item-mainsub');
          if (mainSubEl) {
            mainSubEl.addEventListener('change', e => {
              item.mainSub = e.target.value;
            });
          }
          // ★追加ここまで

          roleEl.addEventListener('input', e => {
            item.roleName = e.target.value;
          });
          rankEl.addEventListener('input', e => {
            item.rank = parseInt(e.target.value, 10) || 1;
          });
          noteEl.addEventListener('input', e => {
            item.note = e.target.value;
          });
          removeEl.addEventListener('click', () => {
            delete cart[castId];
            updateCartCount();
            renderCartModal();
            displayAvailableCasts();
          });
        });
      }
      // ========= Events =========
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          if (btn.id === 'nav-cart') return; // cartは別処理
          const viewId = btn.id.replace('nav-', '') + '-view';
          switchView(viewId);

          if (viewId === 'status-view') {
            await renderCastingStatusView(true);
          } else if (viewId === 'management-view') {
            if (isAdmin) {
              // 管理画面を開いたら、デフォルトで撮影連絡ページを表示
              showShootContactPage();
            } else {
              document.getElementById('management-view').innerHTML = '<p class="text-gray-600">管理者権限がありません。</p>';
            }
          }
        });
      });

      document.getElementById('shooting-contact-btn')?.addEventListener('click', showShootContactPage);

      // (1790行目付近の nav-cart イベントリスナーは残す)
      document.getElementById('nav-cart')?.addEventListener('click', e => {
        e.preventDefault();
        const modal = document.getElementById('cart-modal');
        if (!modal) return;

        if (!cartMeta.projectNames[0]) {
          cartStep = 1;
        } else {
          cartStep = 2;
        }
        modal.classList.remove('hidden');
        renderCartModal();
      });

      document.getElementById('authorize_button')?.addEventListener('click', handleAuthClick);
      document.getElementById('signout_button')?.addEventListener('click', handleSignoutClick);

      document.getElementById('prev-month')?.addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() - 1); renderCalendar(); });
      document.getElementById('next-month')?.addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() + 1); renderCalendar(); });

      document.getElementById('calendar-grid')?.addEventListener('click', e => {
        const cell = e.target.closest('.calendar-day'); if (!cell?.dataset.date) return;
        const date = cell.dataset.date;
        const idx = selectedDates.indexOf(date);
        if (idx > -1) selectedDates.splice(idx, 1); else selectedDates.push(date);
        selectedDates.sort();
        renderCalendar(); updateSelectedPeriodDisplay();
        renderShootingList(); // Show existing shootings for selected date
        displayAvailableCasts();
      });

      document.body.addEventListener('input', e => { if (e.target.closest('#cast-filters-container')) displayAvailableCasts(); });

      document.body.addEventListener('click', e => {
        const btn = e.target.closest('.add-to-cart-btn'); if (!btn) return;
        addToCart(btn.getAttribute('data-cast-id'));
      });

      // D-2: ビューモード切り替えボタンのイベント
      document.getElementById('view-mode-comfort')?.addEventListener('click', () => {
        if (viewMode === 'comfort') return;
        viewMode = 'comfort';
        displayAvailableCasts();
      });
      document.getElementById('view-mode-dense')?.addEventListener('click', () => {
        if (viewMode === 'dense') return;
        viewMode = 'dense';
        displayAvailableCasts();
      });

      // Load GAPI & GIS
      const gapiScript = document.createElement('script'); gapiScript.src = 'https://apis.google.com/js/api.js'; gapiScript.async = true; gapiScript.defer = true; gapiScript.onload = gapiLoaded;
      const gisScript = document.createElement('script'); gisScript.src = 'https://accounts.google.com/gsi/client'; gisScript.async = true; gisScript.defer = true; gisScript.onload = gisLoaded;

      document.head.appendChild(gapiScript);
      document.head.appendChild(gisScript); // ★ここを修正しました
    });

  </script>
</body>

</html>