<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="google-client-id" content="{{ GOOGLE_CLIENT_ID }}">
  <meta name="google-api-key" content="{{ GOOGLE_API_KEY }}">
  <meta name="spreadsheet-id" content="{{ SPREADSHEET_ID }}">

  <title>キャスト管理システム v1.4</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    .view {
      display: none;
    }

    .view.active {
      display: block;
    }

    .modal-backdrop {
      background-color: rgba(0, 0, 0, 0.5);
    }

    .gemini-output {
      background-color: #f0f9ff;
      border-left: 4px solid #0284c7;
      padding: 8px;
      font-size: 0.875rem;
      line-height: 1.5;
      color: #0c4a6e;
    }
  </style>
</head>

<body class="bg-gray-100 text-gray-800">

  <header class="bg-white shadow-md sticky top-0 z-40">
    <nav class="container mx-auto px-4 sm:px-6 py-3">
      <div class="flex justify-between items-center">
        <!-- Logo -->
        <h1 class="text-xl sm:text-2xl font-bold text-gray-800">キャスト管理システム ✨</h1>

        <!-- Desktop Navigation -->
        <div class="hidden md:flex items-center space-x-4">
          <button id="nav-casting"
            class="nav-btn text-blue-600 border-b-2 border-blue-600 font-medium px-2 py-1">キャストを探す</button>
          <button id="nav-status"
            class="nav-btn text-gray-600 hover:text-blue-600 font-medium px-2 py-1">キャスティング状況</button>
          <button id="nav-management"
            class="nav-btn text-gray-600 hover:text-blue-600 font-medium px-2 py-1">管理画面</button>
        </div>

        <!-- Right Side: Cart + Auth + Hamburger -->
        <div class="flex items-center space-x-2 md:space-x-4">
          <!-- Cart Button (Visible on Mobile & Desktop) -->
          <button id="nav-cart" class="relative text-gray-600 hover:text-blue-600 p-1">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round"
                d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
            </svg>
            <span id="cart-count"
              class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">0</span>
          </button>

          <!-- Desktop Auth -->
          <div id="auth-container" class="hidden md:flex items-center">
            <span id="user-name" class="hidden text-sm text-gray-700 mr-4"></span>
            <button id="authorize_button"
              class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition">サインイン</button>
            <button id="signout_button"
              class="hidden bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">サインアウト</button>
          </div>

          <!-- Mobile Hamburger Button -->
          <button id="mobile-menu-btn" class="md:hidden text-gray-600 hover:text-blue-600 focus:outline-none p-1">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
            </svg>
          </button>
        </div>
      </div>

      <!-- Mobile Menu (Hidden by default) -->
      <div id="mobile-menu" class="hidden md:hidden mt-4 pb-4 border-t pt-4">
        <div class="flex flex-col space-y-3">
          <button id="mobile-nav-casting"
            class="text-left font-medium text-blue-600 px-2 py-1 bg-blue-50 rounded">キャストを探す</button>
          <button id="mobile-nav-status"
            class="text-left font-medium text-gray-600 hover:text-blue-600 px-2 py-1 hover:bg-gray-50 rounded">キャスティング状況</button>
          <button id="mobile-nav-management"
            class="text-left font-medium text-gray-600 hover:text-blue-600 px-2 py-1 hover:bg-gray-50 rounded">管理画面</button>

          <hr class="border-gray-200 my-2">

          <!-- Mobile Auth Buttons -->
          <div id="mobile-auth-container" class="flex flex-col space-y-2">
            <span id="mobile-user-name" class="hidden text-sm text-gray-700 px-2"></span>
            <button id="mobile-authorize_button"
              class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition w-full text-center">サインイン</button>
            <button id="mobile-signout_button"
              class="hidden bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg w-full text-center">サインアウト</button>
          </div>
        </div>
      </div>
    </nav>
  </header>

  <main class="container mx-auto p-4 sm:p-6">
    <div id="loader" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50">
      <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-blue-500"></div>
      <p class="text-white text-lg ml-4">データを読み込んでいます...</p>
    </div>
    <div id="message-box"
      class="hidden fixed top-20 right-5 bg-green-500 text-white py-2 px-4 rounded-lg shadow-lg z-50"></div>

    <div id="casting-view" class="view">
      <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
        <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-md h-fit">
          <h2 class="text-2xl font-bold mb-4">1. 日付を選択</h2>
          <div id="calendar-container">
            <div class="flex justify-between items-center mb-4">
              <button id="prev-month" class="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">&lt;</button>
              <h3 id="current-month-year" class="text-lg font-semibold"></h3>
              <button id="next-month" class="px-3 py-1 bg-gray-200 rounded-md hover:bg-gray-300">&gt;</button>
            </div>
            <div id="calendar-grid" class="grid grid-cols-7 gap-1 text-center text-sm"></div>
          </div>

          <hr class="my-6">
          <h2 class="text-2xl font-bold mb-4">2. 撮影を選択</h2>
          <div id="shooting-list-container" class="space-y-2 max-h-[60vh] overflow-y-auto">
            <p class="text-gray-500 text-sm">日付を選択すると、候補の撮影が表示されます。</p>
          </div>
        </div>

        <div class="lg:col-span-3">
          <div class="flex items-center justify-between mb-2">
            <h2 class="text-2xl font-bold">3. キャストを選択</h2>
            <div class="inline-flex rounded-lg border text-xs overflow-hidden">
              <button id="view-mode-comfort" class="px-3 py-1 min-w-[3rem] text-center">3列</button>
              <button id="view-mode-dense" class="px-3 py-1 min-w-[3rem] text-center">5列</button>
            </div>
          </div>

          <!-- New Filters Area -->
          <!-- Existing Shootings (Additional Casting) -->
          <div id="shooting-list-container" class="mb-4 hidden"></div>

          <div id="cast-filters-container" class="bg-gray-50 p-4 rounded-lg mb-4 flex flex-wrap gap-4 items-end">
            <!-- Filters will be injected here -->
          </div>

          <p id="selected-period-display" class="text-gray-600 mb-4">カレンダーから日付を選択してください</p>
          <div id="cast-list"
            class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 max-h-[75vh] overflow-y-auto p-2"></div>
        </div>
      </div>
    </div>

    <div id="status-view" class="view">
      <h2 class="text-3xl font-bold mb-4">キャスティング状況</h2>
    </div>

    <div id="management-view" class="view">
      <div id="main-view">
        <!-- content will be injected here -->
      </div>
    </div>
  </main>

  <div id="cart-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="confirmation-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="edit-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="status-quick-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>
  <div id="new-external-cast-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop">
  </div>
  <div id="shoot-mail-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop"></div>

  <!-- No Shooting Selection Popup -->
  <div id="no-shooting-popup"
    class="hidden fixed inset-0 z-[70] flex items-center justify-center modal-backdrop bg-black bg-opacity-50">
    <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm text-center">
      <h3 class="text-lg font-bold text-gray-800 mb-4">撮影案件が選択されていません</h3>
      <div class="flex flex-col gap-3">
        <button id="btn-order-external"
          class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">外部案件としてオーダーする</button>
        <button id="btn-order-internal"
          class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">社内イベント用にオーダーする</button>
        <button id="btn-popup-back"
          class="px-4 py-2 bg-gray-300 text-gray-700 rounded hover:bg-gray-400">撮影選択に戻る</button>
      </div>
    </div>
  </div>

  <!-- Special Order Modal -->
  <div id="special-order-modal"
    class="hidden fixed inset-0 z-[80] flex items-center justify-center modal-backdrop bg-black bg-opacity-50">
    <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg">
      <h3 id="special-order-title" class="text-xl font-bold text-gray-800 mb-4">特別オーダー</h3>

      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-1">タイトル (案件/イベント内容)</label>
        <input type="text" id="special-order-name" class="w-full border rounded px-3 py-2"
          placeholder="例: 〇〇CM撮影、〇〇イベント">
      </div>

      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-1">選択中の日付</label>
        <div id="special-order-date-list" class="text-sm text-gray-600 bg-gray-50 p-2 rounded max-h-24 overflow-y-auto">
        </div>
        <input type="hidden" id="special-order-dates-json">
      </div>

      <div class="grid grid-cols-2 gap-4 mb-4">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">開始時間</label>
          <input type="time" id="special-order-start" class="w-full border rounded px-3 py-2">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">終了時間</label>
          <input type="time" id="special-order-end" class="w-full border rounded px-3 py-2">
        </div>
      </div>

      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-1">選択中のキャスト</label>
        <div id="special-order-cast-list" class="text-sm text-gray-600 bg-gray-50 p-2 rounded"></div>
      </div>

      <div class="flex justify-end gap-3 mt-6">
        <button id="btn-special-cancel" class="px-4 py-2 border rounded hover:bg-gray-50">キャンセル</button>
        <button id="btn-special-submit"
          class="px-6 py-2 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700">送信</button>
      </div>
    </div>
  </div>

  <div id="progress-modal"
    class="hidden fixed inset-0 z-[60] flex items-center justify-center modal-backdrop bg-black bg-opacity-50">
    <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm text-center">
      <h3 id="progress-title" class="text-lg font-bold text-gray-800 mb-2">処理中...</h3>
      <p id="progress-message" class="text-sm text-gray-600 mb-4">しばらくお待ちください</p>

      <div class="w-full bg-gray-200 rounded-full h-4 mb-2 overflow-hidden">
        <div id="progress-bar-fill" class="bg-blue-600 h-4 rounded-full transition-all duration-300" style="width: 0%">
        </div>
      </div>
      <div id="progress-percent" class="text-xs font-bold text-blue-600">0%</div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // ========= Config =========
      const CLIENT_ID = document.querySelector('meta[name="google-client-id"]')?.content || '';
      const SPREADSHEET_ID = document.querySelector('meta[name="spreadsheet-id"]')?.content || '';
      const API_KEY = document.querySelector('meta[name="google-api-key"]')?.content || '';
      const DISCOVERY_DOCS = [
        "https://sheets.googleapis.com/$discovery/rest?version=v4",
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest",
        "https://www.googleapis.com/discovery/v1/apis/oauth2/v2/rest"
      ];
      const SCOPES = 'https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/documents';

      // ========= State =========
      let tokenClient, gapiInited = false, gisInited = false;
      let currentUser = null, isAdmin = false;
      let castData = [], castingData = [], adminUsers = [];
      let shootingScheduleData = new Map(); // Map<castId, Set<dateString>>
      let cart = {}; // { [castId]: { cast, dates: string[], roleName?: string } }
      let cartMeta = {
        account: '',
        notionUrl: '',
        projectNames: ['', '', ''],
        combinedProjectNames: []
      };
      let cartStep = 1; // 1: STEP1（ヘッダー入力）, 2: STEP2（キャスト紐付け）
      let selectedDates = [];
      let calendarDate = new Date();
      let statusMonth = loadStatusMonth() || new Date();
      let showPast = false;
      let statusOrderWaitOnly = false;
      const ORDER_WAIT_STATUSES = ['オーダー待ち', 'オーダー待ち（仮キャスティング）'];
      let viewMode = 'comfort'; // 'comfort' or 'dense'
      let isAdditionalOrderMode = false;
      let additionalOrderContext = null;
      let shootingContactRows = [];
      let INTERNAL_HOLD_CALENDAR_ID = '';

      const loader = document.getElementById('loader');

      // ========= Helpers =========
      const groupBy = (array, key) => {
        return array.reduce((result, currentValue) => {
          (result[key(currentValue)] = result[key(currentValue)] || []).push(currentValue);
          return result;
        }, {});
      };

      const pad2 = n => String(n).padStart(2, '0');
      const d2str = d => `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
      const TODAY_STR = d2str(new Date());
      const TODAY_EPOCH = toEpochDay(TODAY_STR);

      async function loadConfig() {
        try {
          const res = await fetch('/config');
          if (!res.ok) return;
          const conf = await res.json();
          INTERNAL_HOLD_CALENDAR_ID = conf.calendar_id_internal_hold || '';
        } catch (e) {
          console.warn('Failed to load config', e);
        }
      }

      function showLoader(show) { if (loader) loader.style.display = show ? 'flex' : 'none'; }
      function showMessage(message, type = 'success') {
        const box = document.getElementById('message-box'); if (!box) return;
        box.textContent = message;
        box.className = 'fixed top-20 right-5 text-white py-2 px-4 rounded-lg shadow-lg z-50';
        box.classList.add(type === 'success' ? 'bg-green-500' : (type === 'error' ? 'bg-red-500' : 'bg-blue-500'));
        box.style.display = 'block'; setTimeout(() => { box.style.display = 'none'; }, 3000);
      }
      function updateCartCount() { const el = document.getElementById('cart-count'); if (el) el.textContent = Object.keys(cart).length; }

      function normalizeDateString(input) {
        if (!input) return null; if (typeof input !== 'string') input = String(input);

        // New: Handle MM/DD format
        const md = input.match(/^(\d{1,2})\/(\d{1,2})$/);
        if (md) {
          const year = new Date().getFullYear();
          return `${year}-${pad2(md[1])}-${pad2(md[2])}`;
        }

        const m = input.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})(?:[T\s].*)?$/);
        if (m) return `${m[1]}-${pad2(m[2])}-${pad2(m[3])}`;
        const n = Number(input);
        if (!Number.isNaN(n) && n > 20000 && n < 60000) {
          const epoch = new Date(Date.UTC(1899, 11, 30)); const d = new Date(epoch.getTime() + n * 86400000);
          return d2str(new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate())));
        }
        const t = Date.parse(input); if (!Number.isNaN(t)) { const d = new Date(t); return d2str(d); }
        return null;
      }
      function toEpochDay(ymd) {
        if (!ymd) return null;
        const [y, m, d] = ymd.split('-').map(x => parseInt(x, 10));
        return Date.UTC(y, m - 1, d) / 86400000;
      }
      function groupDatesIntoRanges(dates) {
        if (!dates || dates.length === 0) return [];
        const arr = dates.map(normalizeDateString).filter(Boolean).sort();
        const res = []; let start = arr[0], prev = arr[0];
        const next = (s) => { const [y, m, d] = s.split('-').map(n => parseInt(n, 10)); const dt = new Date(Date.UTC(y, m - 1, d) + 86400000); return d2str(new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()))); };
        for (let i = 1; i < arr.length; i++) { if (arr[i] !== next(prev)) { res.push({ start, end: prev }); start = arr[i]; } prev = arr[i]; }
        res.push({ start, end: prev }); return res;
      }
      function overlaps(aStart, aEnd, bStart, bEnd) {
        const as = toEpochDay(aStart), ae = toEpochDay(aEnd), bs = toEpochDay(bStart), be = toEpochDay(bEnd);
        if (as == null || ae == null || bs == null || be == null) return false;
        return !(ae < bs || be < as);
      }
      function saveStatusMonth(d) { localStorage.setItem('status_month', `${d.getFullYear()}-${pad2(d.getMonth() + 1)}`); }
      function loadStatusMonth() {
        const s = localStorage.getItem('status_month'); if (!s) return null;
        const m = s.match(/^(\d{4})[-/](\d{2})$/); if (!m) return null;
        return new Date(parseInt(m[1]), parseInt(m[2]) - 1, 1);
      }

      function calculateAge(dateString) {
        if (!dateString) return null;
        const bd = new Date(dateString), today = new Date();
        let age = today.getFullYear() - bd.getFullYear();
        const mm = today.getMonth() - bd.getMonth();
        if (mm < 0 || (mm === 0 && today.getDate() < bd.getDate())) age--;
        return age;
      }

      function extractNotionPageId(url) {
        if (!url) return "";
        const m = String(url).match(/[0-9a-f]{32}/i);
        if (!m) return "";
        const s = m[0].toLowerCase();
        return `${s.substring(0, 8)}-${s.substring(8, 12)}-${s.substring(12, 16)}-${s.substring(16, 20)}-${s.substring(20)}`;
      }

      function findExistingThreadForOrder(accountName, projectId, dateRanges) {
        // projectId が空の場合は、別案件とみなしてスレッドを再利用しない
        if (!projectId) return null;

        // projectId と accountName が一致し、かつ slackThreadTs を持つレコードを探す
        // 日付の重なりはチェックせず、案件単位でざっくり探す
        const cand = castingData.find(c =>
          c.accountName === accountName &&
          c.projectId === projectId &&
          c.slackThreadTs
        );
        return cand || null;
      }

      function switchView(viewId) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById(viewId)?.classList.add('active');
        document.querySelectorAll('.nav-btn').forEach(b => {
          b.classList.remove('text-blue-600', 'border-b-2', 'border-blue-600');
          if (b.id.includes(viewId.split('-')[0])) b.classList.add('text-blue-600', 'border-b-2', 'border-blue-600');
        });

        // Render content for specific views
        if (viewId === 'status-view') {
          renderCastingStatusView(false);
        } else if (viewId === 'management-view') {
          showShootContactPage();
        }
      }
      function updateSelectedPeriodDisplay() {
        const el = document.getElementById('selected-period-display'); if (!el) return;
        if (selectedDates.length === 0) el.textContent = 'カレンダーから日付を選択してください';
        else if (selectedDates.length === 1) el.textContent = `選択中の日付: ${selectedDates[0]}`;
        else el.textContent = `選択中の期間: ${selectedDates[0]} ~ ${selectedDates[selectedDates.length - 1]} (${selectedDates.length}日間)`;
      }

      // ========= Auth State =========
      let codeClient;     // ←追加: Code Flow用

      // ========= Auth Functions =========
      function gapiLoaded() { gapi.load('client', initializeGapiClient); }
      async function initializeGapiClient() {
        await gapi.client.init({ apiKey: API_KEY, discoveryDocs: DISCOVERY_DOCS });
        gapiInited = true;
        maybeCheckSession(); // ロード時にセッションチェック
      }

      function gisLoaded() {
        // ★変更: initCodeClient を使用
        codeClient = google.accounts.oauth2.initCodeClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          ux_mode: 'popup',
          callback: async (response) => {
            if (response.code) {
              // 1. サーバーにコードを送り、Cookie(Refresh Token)をセットしてもらう
              showLoader(true);
              try {
                const res = await fetch('/api/auth/login', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ code: response.code })
                });

                if (res.ok) {
                  const data = await res.json();
                  // 2. 返ってきたアクセストークンをgapiにセット
                  gapi.client.setToken({ access_token: data.access_token });
                  updateUI(true);
                  showMessage('サインインしました');
                } else {
                  throw new Error('Server login failed');
                }
              } catch (e) {
                console.error(e);
                showMessage('ログインに失敗しました', 'error');
                updateUI(false);
              } finally {
                showLoader(false);
              }
            }
          },
        });
        gisInited = true;
        maybeCheckSession();
      }

      // ★追加: ページロード時にサーバーのCookieを使ってトークン再発行を試みる
      async function maybeCheckSession() {
        if (!gapiInited || !gisInited) return;

        // すでにトークンがあるなら何もしない
        if (gapi.client.getToken()) return;

        console.log("Checking session...");
        try {
          const res = await fetch('/api/auth/refresh');
          if (res.ok) {
            const data = await res.json();
            if (data.access_token) {
              console.log("Session restored!");
              gapi.client.setToken({ access_token: data.access_token });
              updateUI(true);
              return;
            }
          }
        } catch (e) {
          console.warn("Session check failed", e);
        }
        // セッションがなければ未ログイン状態
        updateUI(false);
      }

      function handleAuthClick() {
        // ポップアップを出して認証コードを取得
        codeClient.requestCode();
      }

      async function handleSignoutClick() {
        const token = gapi.client.getToken();
        if (token !== null) {
          gapi.client.setToken('');
        }
        // サーバー側のCookie削除
        try { await fetch('/api/auth/logout', { method: 'POST' }); } catch (e) { }

        updateUI(false);
        showMessage('サインアウトしました', 'info');
      }

      // Mobile Menu Logic
      const mobileMenuBtn = document.getElementById('mobile-menu-btn');
      const mobileMenu = document.getElementById('mobile-menu');

      if (mobileMenuBtn && mobileMenu) {
        mobileMenuBtn.addEventListener('click', () => {
          mobileMenu.classList.toggle('hidden');
        });
      }

      function closeMobileMenu() {
        if (mobileMenu) mobileMenu.classList.add('hidden');
      }

      document.getElementById('mobile-nav-casting')?.addEventListener('click', () => { switchView('casting-view'); closeMobileMenu(); });
      document.getElementById('mobile-nav-status')?.addEventListener('click', () => { switchView('status-view'); closeMobileMenu(); });
      document.getElementById('mobile-nav-management')?.addEventListener('click', () => { switchView('management-view'); closeMobileMenu(); });

      document.getElementById('mobile-authorize_button')?.addEventListener('click', () => { handleAuthClick(); closeMobileMenu(); });
      document.getElementById('mobile-signout_button')?.addEventListener('click', () => { handleSignoutClick(); closeMobileMenu(); });


      // APIコールの前に確実にトークンがあるかチェックする関数
      async function ensureAuth() {
        const token = gapi.client.getToken();
        if (token && token.access_token) return true;

        // トークンがない場合、裏でリフレッシュを試みる
        try {
          const res = await fetch('/api/auth/refresh');
          if (res.ok) {
            const data = await res.json();
            gapi.client.setToken({ access_token: data.access_token });
            return true;
          }
        } catch (e) {
          console.error(e);
        }
        return false;
      }

      async function updateUI(isAuthorized) {
        const auth = document.getElementById('authorize_button'), out = document.getElementById('signout_button');
        const mAuth = document.getElementById('mobile-authorize_button'), mOut = document.getElementById('mobile-signout_button');

        if (auth) auth.style.display = isAuthorized ? 'none' : 'block';
        if (out) out.style.display = isAuthorized ? 'block' : 'none';
        if (mAuth) mAuth.style.display = isAuthorized ? 'none' : 'block';
        if (mOut) mOut.style.display = isAuthorized ? 'block' : 'none';

        // Update Mobile User Name
        const mUser = document.getElementById('mobile-user-name');
        if (mUser) {
          if (isAuthorized && currentUser) {
            mUser.textContent = `ようこそ ${currentUser.name} さん`;
            mUser.classList.remove('hidden');
          } else {
            mUser.classList.add('hidden');
          }
        }

        if (isAuthorized) {
          try {
            await getUserProfile();
            await loadConfig();
            await loadAllData();

            // 9. 管理者のみ操作可能にする
            if (isAdmin) {
              document.querySelectorAll('.admin-only').forEach(el => el.classList.remove('hidden'));
            }

            switchView('casting-view');
          } catch (err) {
            console.error('Auth/Data failed', err);
            const msg = err.result?.error?.message || err.message || JSON.stringify(err);
            alert(`データ読み込みに失敗しました。\nエラー: ${msg}\n\nOKを押すとサインアウトします。`);
            handleSignoutClick();
          }
        } else {
          currentUser = null; isAdmin = false;
          document.getElementById('user-name')?.classList.add('hidden');
          document.querySelectorAll('.admin-only').forEach(el => el.classList.add('hidden'));
          document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
          showMessage('サインインして、キャスト管理を始めましょう。', 'info');
          showLoader(false);
        }
      }
      async function getUserProfile() {
        const res = await gapi.client.oauth2.userinfo.get(); currentUser = res.result;
        const el = document.getElementById('user-name'); if (el) { el.textContent = `ようこそ ${currentUser.name} さん`; el.classList.remove('hidden'); }
      }

      // ========= Data =========
      async function loadAllData() {
        showLoader(true);
        try {
          const res = await gapi.client.sheets.spreadsheets.values.batchGet({
            spreadsheetId: SPREADSHEET_ID,
            ranges: [
              'キャストリスト!A2:N',
              'キャスティングリスト!A2:T',
              '権限管理リスト!A2:B',
              '撮影スケ_キャスト!A2:Z', // 修正: 範囲を広めに確保
              '新香盤撮影リスト!A2:F',
              '内部キャストDB!A2:E'
            ],
          });
          const vr = res.result.valueRanges;

          if (!vr || vr.length < 3) throw new Error('必要なシートが見つかりません。');

          // Casts (No change needed here, reusing existing logic below)
          const castValues = vr[0].values || [];
          castData = castValues
            .filter(r => r && (r[1]?.trim() || r[0]?.trim()))
            .map((row, idx) => {
              const id = row[0]?.trim() || `cast_${idx + 1}`;
              const name = row[1]?.trim() || `未登録キャスト${idx + 1}`;
              const gender = row[2]?.trim() || '';
              const dob = row[3]?.trim() || '';
              const agency = row[4]?.trim() || 'フリー';
              let imageUrl = row[5]?.trim() || '';
              if (imageUrl && !imageUrl.toLowerCase().startsWith('http')) {
                imageUrl = '';
              }
              const appearance = Number.parseInt(row[6], 10);
              const email = row[7]?.trim() || '';
              const notes = row[8]?.trim() || '';
              const castType = row[9]?.trim() || '';

              const isInternal = castType === '内部';
              const slackMentionId = row[10]?.trim() || '';

              const snsX = row[11]?.trim() || '';
              const snsInsta = row[12]?.trim() || '';
              const snsTiktok = row[13]?.trim() || '';

              return {
                castId: id, name, gender, dateOfBirth: dob, age: dob ? calculateAge(dob) : null,
                agency, imageUrl, appearanceCount: Number.isFinite(appearance) ? appearance : 0, email, notes,
                castType,
                isInternal,
                internalType: castType,
                slackMentionId,
                snsX, snsInsta, snsTiktok
              };
            });

          // Casting
          const castMap = new Map(castData.map(c => [c.castId, c]));
          const castingValues = vr[1].values || [];

          castingData = castingValues.map(row => {
            const start = normalizeDateString(row?.[6] || '');
            const end = normalizeDateString(row?.[7] || '');
            const castId = row?.[4] || '';
            const base = castMap.get(castId);
            const isInternal = base?.isInternal ?? false;

            let slackThreadTs = row?.[11] || '';
            const slackPermalink = row?.[12] || '';
            if ((!slackThreadTs || /^\d{10}$/.test(slackThreadTs)) && slackPermalink) {
              const m = slackPermalink.match(/p(\d{16})/);
              if (m) {
                const raw = m[1];
                slackThreadTs = raw.slice(0, 10) + "." + raw.slice(10);
              }
            }

            return {
              castingId: row?.[0] || '',
              accountName: row?.[1] || '',
              projectName: row?.[2] || '',
              roleName: row?.[3] || '',
              castId: castId,
              castName: row?.[5] || '',
              startDate: start, endDate: end,
              startDay: toEpochDay(start), endDay: toEpochDay(end),
              rank: row?.[8] || '',
              status: row?.[9] || '',
              note: row?.[10] || '',
              slackThreadTs: slackThreadTs,
              slackPermalink: slackPermalink,
              mainSub: row?.[13] || 'その他',
              calendarEventId: row?.[14] || '',
              projectId: row?.[15] || '',
              lastUpdated: row?.[16] || '',
              updatedBy: row?.[17] || '',
              castPriority: Number.parseInt(row?.[18], 10),
              isInternal,
              castType: row?.[19] || (isInternal ? '内部' : '外部'),
              email: row?.[20] || '',
              cost: row?.[21] || '',
              structureData: row?.[22] ? JSON.parse(row[22]) : null
            };
          });

          // Roles
          const perm = vr[2].values || [];
          const roleByEmail = new Map();
          for (const row of (perm || [])) {
            const email = (row?.[0] || '').trim().toLowerCase();
            const role = (row?.[1] || '').trim().toLowerCase() || 'viewer';
            if (email) roleByEmail.set(email, role);
          }
          const myEmail = (currentUser?.email || '').toLowerCase();
          isAdmin = (roleByEmail.get(myEmail) === 'admin');

          // 4. Shooting Schedule (撮影スケ_キャスト) の復旧
          // 4. Shooting Schedule (撮影スケ_キャスト) の修正
          if (vr.length > 3 && vr[3].values) {
            const scheduleValues = vr[3].values || [];

            // ★修正: A列=キャスト名, B列以降=日付
            shootingScheduleData.clear(); // Map<castId, Set<dateString>>

            scheduleValues.forEach(row => {
              const castName = row[0]?.trim(); // A列: キャスト名
              if (!castName) return;

              // 名前からキャストIDを逆引き
              const cast = castData.find(c => c.name === castName);
              if (cast) {
                if (!shootingScheduleData.has(cast.castId)) {
                  shootingScheduleData.set(cast.castId, new Set());
                }

                // B列(インデックス1)以降をすべて日付としてチェック
                for (let i = 1; i < row.length; i++) {
                  const dateRaw = row[i];
                  if (!dateRaw) continue;

                  const date = normalizeDateString(dateRaw);
                  if (date) {
                    shootingScheduleData.get(cast.castId).add(date);
                  }
                }
              }
            });
            console.log("Shooting Schedule Loaded:", shootingScheduleData.size, "casts active.");
          }

          // New Shooting List (新香盤撮影リスト)
          if (vr.length > 4 && vr[4].values) {
            const slValues = vr[4].values || [];
            window.shootingListData = slValues.map(row => ({
              pageId: row[0] || '',
              title: row[1] || '',
              date: normalizeDateString(row[2]),
              team: row[3] || '',
              cd: row[4] || '',
              fd: row[5] || ''
            })).filter(item => item.date);
          } else {
            window.shootingListData = [];
          }

          // Internal Cast DB
          window.internalCastMap = new Map();
          if (vr.length > 5 && vr[5].values) {
            const icValues = vr[5].values || [];
            icValues.forEach(row => {
              const name = row[0]?.trim();
              const uid = row[4]?.trim();
              if (name && uid) {
                window.internalCastMap.set(name, uid);
              }
            });
          }

          renderCalendar();
          renderFilters();
          renderShootingList();
          displayAvailableCasts();

        } catch (err) {
          console.error('Data loading error:', err);
          showMessage('データの取得に失敗しました。再ログインしてください。', 'error');
          // エラー時はログアウト扱いにする
          handleSignoutClick();
        } finally { showLoader(false); }
      }

      // シート「キャスティングリスト」から最新を再取得
      async function fetchCastingDataFromSheet() {
        const getRes = await gapi.client.sheets.spreadsheets.values.get({
          spreadsheetId: SPREADSHEET_ID,
          range: 'キャスティングリスト!A2:W' // A-W列まで取得 (U:Email, V:Cost, W:Structure)
        });
        const rows = getRes.result.values || [];

        const castMap = new Map(castData.map(c => [c.castId, c])); // マップ再作成

        castingData = rows.map(row => {
          const start = normalizeDateString(row?.[6] || '');
          const end = normalizeDateString(row?.[7] || '');
          const priority = Number.parseInt(row?.[17], 10);
          const castId = row?.[4] || '';

          // ★修正: isInternal の判定
          const base = castMap.get(castId);
          const isInternal = base?.isInternal ?? false;

          let slackThreadTs = row?.[11] || '';
          const slackPermalink = row?.[12] || '';

          // もし thread_ts が空 or 10桁の整数っぽい場合は、permalink から復元を試みる
          if ((!slackThreadTs || /^\d{10}$/.test(slackThreadTs)) && slackPermalink) {
            // 例: https://.../p1763537866119239 から 1763537866.119239 を復元
            // クエリパラメータがあってもマッチするように $ を削除
            const m = slackPermalink.match(/p(\d{16})/);
            if (m) {
              const raw = m[1]; // "1763537866119239"
              slackThreadTs = raw.slice(0, 10) + "." + raw.slice(10); // "1763537866.119239"
            }
          }

          // JSONパース (W列)
          let structureData = [];
          try {
            if (row?.[22]) {
              structureData = JSON.parse(row[22]);
            }
          } catch (e) {
            console.warn("Failed to parse structureData", e);
          }

          return {
            castingId: row?.[0] || '',
            accountName: row?.[1] || '',
            projectName: row?.[2] || '',
            roleName: row?.[3] || '',
            castId: castId,
            castName: row?.[5] || '',
            startDate: start,
            endDate: end,
            startDay: toEpochDay(start),
            endDay: toEpochDay(end),
            rank: row?.[8] || '',
            status: row?.[9] || '',
            note: row?.[10] || '',
            slackThreadTs,
            slackPermalink,
            mainSub: row?.[13] || 'その他',     // N列
            calendarEventId: row?.[14] || '', // O列
            projectId: row?.[15] || '',       // P列
            lastUpdated: row?.[16] || '',     // 旧15 -> 16 (Q列)
            updatedBy: row?.[17] || '',       // 旧16 -> 17 (R列)
            castPriority: Number.parseInt(row?.[18], 10), // 旧17 -> 18 (S列)
            // T列(19) is unused or reserved?
            email: row?.[20] || '',           // U列: Email
            cost: row?.[21] || '',            // V列: Cost
            structureData: structureData,     // W列: Structure
            isInternal,
          };
        });
      }

      // ========= Casting view =========
      // 修正: チーム名を返すように変更
      function getCastStatusForDates(castId, dates) {
        if (!dates || dates.length === 0) return {
          isProvisional: false, isConfirmed: false, isShooting: false, isNG: false,
          holdingTeams: []
        };

        const targetDates = dates.map(normalizeDateString).filter(v => v != null);
        const targetEpochs = targetDates.map(toEpochDay);

        let isProv = false, isConf = false, isShooting = false, isNG = false;
        let is1st = false, is2nd = false;
        const holdingTeams = new Set(); // 仮押さえしているチーム名

        const CONFIRM_STATUS = ['決定', 'OK'];
        const NG_STATUS = ['NG'];
        const PROV_STATUS = [
          '仮キャスティング', 'オーダー待ち', 'オーダー待ち（仮キャスティング）',
          '打診中', '条件つきOK'
        ];

        const bookings = castingData.filter(c => c.castId === castId && c.startDay != null && c.endDay != null);

        for (const day of targetEpochs) {
          if (isConf) break; // 決定済みならループ終了

          for (const b of bookings) {
            if (day >= b.startDay && day <= b.endDay) {
              if (CONFIRM_STATUS.includes(b.status)) {
                isConf = true;
              } else if (NG_STATUS.includes(b.status)) {
                isNG = true;
              } else if (PROV_STATUS.includes(b.status)) {
                isProv = true;
                // チーム名（アカウント名）を記録
                if (b.accountName) {
                  holdingTeams.add(b.accountName);
                }
              }

              // 順位チェック
              if (b.status.includes('第1候補')) is1st = true;
              if (b.status.includes('第2候補')) is2nd = true;
            }
          }
        }

        // 撮影スケジュールのチェック
        if (!isConf) {
          const schedule = shootingScheduleData.get(castId);
          if (schedule) {
            for (const d of targetDates) {
              if (schedule.has(d)) {
                isShooting = true;
                break;
              }
            }
          }
        }

        return {
          isProvisional: isProv,
          isConfirmed: isConf,
          isShooting: isShooting,
          isNG: isNG,
          is1st, is2nd,
          holdingTeams: Array.from(holdingTeams) // 配列にして返す
        };
      }

      // 修正: チーム名を表示するようにバッジ生成ロジックを変更
      function displayAvailableCasts() {
        const list = document.getElementById('cast-list'); if (!list) return;
        list.innerHTML = '';

        // D-2: viewMode に応じて CSS クラスを切り替え
        if (viewMode === 'comfort') {
          list.className = 'grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6 max-h-[75vh] overflow-y-auto p-2';
        } else { // dense
          list.className = 'grid grid-cols-2 md:grid-cols-3 xl:grid-cols-5 gap-4 max-h-[75vh] overflow-y-auto p-2';
        }

        // ボタンのスタイル更新
        const comfortBtn = document.getElementById('view-mode-comfort');
        const denseBtn = document.getElementById('view-mode-dense');
        if (comfortBtn && denseBtn) {
          if (viewMode === 'comfort') {
            comfortBtn.classList.add('bg-blue-500', 'text-white');
            comfortBtn.classList.remove('bg-white', 'text-gray-700');
            denseBtn.classList.add('bg-white', 'text-gray-700');
            denseBtn.classList.remove('bg-blue-500', 'text-white');
          } else {
            denseBtn.classList.add('bg-blue-500', 'text-white');
            denseBtn.classList.remove('bg-white', 'text-gray-700');
            comfortBtn.classList.add('bg-white', 'text-gray-700');
            comfortBtn.classList.remove('bg-blue-500', 'text-white');
          }
        }

        if (selectedDates.length === 0) {
          list.innerHTML = `<p class="col-span-full text-center text-gray-500 pt-10">日付を選択すると、キャストが表示されます。</p>`;
          return;
        }

        const filtered = getFilteredCasts();

        // C-1: 「＋新規外部キャスト」カードを常駐
        if (selectedDates.length > 0) {
          const newCard = document.createElement('div');
          newCard.className = 'bg-white rounded-lg shadow-md flex flex-col items-center justify-center border-2 border-dashed border-blue-400 cursor-pointer hover:bg-blue-50';
          newCard.innerHTML = `
        <div class="p-6 flex flex-col items-center justify-center">
          <div class="w-12 h-12 rounded-full border-2 border-blue-400 flex items-center justify-center mb-3">
            <span class="text-2xl text-blue-500">＋</span>
          </div>
          <p class="font-semibold text-blue-600">新規外部キャストを追加</p>
          <p class="text-xs text-gray-500 mt-1 text-center">DBに存在しない外部キャストを作成してからオーダー</p>
        </div>`;
          newCard.addEventListener('click', () => {
            openNewExternalCastModal();
          });
          list.appendChild(newCard);
        }

        if (filtered.length === 0) {
          list.innerHTML += `<p class="col-span-full text-center text-gray-500 pt-10">条件に合うキャストがいません。</p>`;
          return;
        }

        filtered.forEach(cast => {
          const stat = getCastStatusForDates(cast.castId, selectedDates);
          const inCart = !!cart[cast.castId];

          let badges = [];
          let solid = false;

          if (stat.isConfirmed) {
            solid = true;
            badges.push(`<span class="bg-red-500 text-white text-xs font-semibold px-2 py-1 rounded-full">決定</span>`);
          } else if (stat.isNG) {
            solid = true;
            badges.push(`<span class="bg-gray-600 text-white text-xs font-semibold px-2 py-1 rounded-full">NG</span>`);
          } else {
            // 仮キャスティングの場合、チーム名を表示
            if (stat.isProvisional) {
              if (stat.holdingTeams.length > 0) {
                // 例: "TeamA 仮キャス中"
                stat.holdingTeams.forEach(team => {
                  badges.push(`<span class="bg-yellow-400 text-yellow-900 text-xs font-semibold px-2 py-1 rounded-full shadow-sm border border-yellow-500">${team} 仮押さえ</span>`);
                });
              } else {
                badges.push(`<span class="bg-yellow-400 text-yellow-800 text-xs font-semibold px-2 py-1 rounded-full">仮キャスティング中</span>`);
              }
            }
            if (stat.isShooting) {
              badges.push(`<span class="bg-cyan-400 text-cyan-900 text-xs font-semibold px-2 py-1 rounded-full border border-cyan-500">撮影稼働あり</span>`);
            }
          }

          const badgeHtml = badges.length > 0 ? `<div class="absolute top-2 right-2 flex flex-col gap-1 items-end z-10">${badges.join('')}</div>` : '';

          const disabled = solid || inCart;
          const buttonLabel = stat.isConfirmed ? 'キャスティング不可' : (stat.isNG ? 'NG' : (inCart ? '追加済み' : '仮キャスティング'));

          const meta = []; if (cast.gender) meta.push(cast.gender); if (Number.isFinite(cast.age)) meta.push(`${cast.age}歳`); meta.push(`出演: ${cast.appearanceCount}回`);

          // Helper to format Drive URL for embedding
          function formatDriveUrl(url) {
            if (!url) return "";
            if (url.includes("drive.google.com")) {
              let id = "";
              const idMatch = url.match(/id=([^&]+)/);
              const fileMatch = url.match(/\/file\/d\/([^/]+)/);
              if (idMatch) id = idMatch[1];
              else if (fileMatch) id = fileMatch[1];
              if (id) {
                return `https://drive.google.com/thumbnail?id=${id}&sz=w800`;
              }
            }
            return url;
          }

          const card = document.createElement('div');
          card.className = `bg-white rounded-lg shadow-md overflow-hidden flex flex-col relative ${(solid || inCart) ? 'opacity-50' : ''} cursor-pointer hover:shadow-lg transition-shadow group`;

          card.addEventListener('click', (e) => {
            if (e.target.closest('.add-to-cart-btn')) return;
            openCastDetailModal(cast.castId);
          });

          const displayUrl = cast.imageUrl ? formatDriveUrl(cast.imageUrl) : '';

          card.innerHTML = `
        ${displayUrl ? `<img src="${displayUrl}" alt="${cast.name}" class="w-full h-48 object-cover" referrerpolicy="no-referrer">`
              : `<div class="w-full h-48 bg-gray-300 flex items-center justify-center">
                              <svg class="w-12 h-12 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                            </div>`}
        ${badgeHtml}
        <div class="p-4 flex-grow flex flex-col">
          <h3 class="text-lg font-bold">${cast.name}</h3>
          <p class="text-sm text-gray-600">${(cast.agency?.trim()) || 'フリー'}</p>
          <div class="mt-2 text-xs text-gray-500">${meta.join(' / ')}</div>
        </div>
        <div class="p-4 pt-0 mt-auto">
          <button data-cast-id="${cast.castId}" class="add-to-cart-btn w-full ${disabled ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600'} text-white font-bold py-2 px-4 rounded-lg transition" ${disabled ? 'disabled' : ''}>${buttonLabel}</button>
          ${(!solid && stat.isShooting) ? '<p class="mt-2 text-xs text-cyan-700 font-bold">※別件の撮影が入っています。</p>' : ''}
          ${(!solid && stat.isProvisional) ? '<p class="mt-2 text-xs text-amber-700 font-bold">※仮キャスティングが入っています。</p>' : ''}
        </div>`;
          list.appendChild(card);
        });
      }

      function getFilteredCasts() {
        const kw = document.getElementById('filter-keyword')?.value?.trim()?.toLowerCase() || '';
        const m = document.getElementById('filter-gender-male')?.checked;
        const f = document.getElementById('filter-gender-female')?.checked;
        const minApp = parseInt(document.getElementById('filter-appearance')?.value, 10) || 0;
        const avail = document.getElementById('filter-available-only')?.checked;
        const agencies = Array.from(document.querySelectorAll('#agency-filter-dropdown input[type="checkbox"]:checked')).map(el => el.value);

        const filtered = castData.filter(c => {
          if (kw) {
            const hay = `${c.name || ''}\n${c.agency || ''}\n${c.notes || ''}`.toLowerCase();
            if (!hay.includes(kw)) return false;
          }
          if (m || f) {
            if (m && c.gender === '男性') {/* ok */ }
            else if (f && c.gender === '女性') {/* ok */ }
            else return false;
          }
          if (agencies.length > 0 && !agencies.includes(c.agency || 'フリー')) return false;
          if (c.appearanceCount < minApp) return false;
          if (avail && selectedDates.length > 0) {
            const s = getCastStatusForDates(c.castId, selectedDates);
            if (s.isProvisional || s.isConfirmed) return false;
          }
          return true;
        });

        const byApp = document.getElementById('sort-appearance')?.checked;
        const byKana = document.getElementById('sort-kana')?.checked;
        if (byApp) filtered.sort((a, b) => (b.appearanceCount ?? 0) - (a.appearanceCount ?? 0));
        else if (byKana) filtered.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'ja', { sensitivity: 'base' }));
        return filtered;
      }

      // ========= Status view =========
      // refresh=true: 描画前に必ずシートから再取得
      window.currentStatusTab = 'casting'; // 'casting' (通常) | 'special' (外部/社内)

      async function renderCastingStatusView(refresh = false) {
        const view = document.getElementById('status-view');
        if (!view) return;

        // Expose to window for onclick handlers
        window.renderCastingStatusView = renderCastingStatusView;

        if (refresh) {
          try { showLoader(true); await fetchCastingDataFromSheet(); }
          catch (e) { console.error(e); showMessage('ステータスの再取得に失敗しました', 'error'); }
          finally { showLoader(false); }
        }

        const y = statusMonth.getFullYear(), m = statusMonth.getMonth();
        const monthStart = new Date(y, m, 1), monthEnd = new Date(y, m + 1, 0);

        const header = `
          <div class="flex space-x-1 border-b mb-4">
            <button class="px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors ${window.currentStatusTab === 'casting' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700'}"
              onclick="window.currentStatusTab = 'casting'; renderCastingStatusView(false);">
              🎬 通常キャスティング
            </button>
            <button class="px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors ${window.currentStatusTab === 'special' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700'}"
              onclick="window.currentStatusTab = 'special'; renderCastingStatusView(false);">
              🏢 外部案件・社内イベント
            </button>
          </div>
          <div class="flex items-center justify-between mb-3">
            <div class="flex items-center gap-2">
              <button id="status-prev-month" class="px-2 py-1 rounded border bg-white">&lt;</button>
              <div class="font-semibold">${y}年${m + 1}月</div>
              <button id="status-next-month" class="px-2 py-1 rounded border bg-white">&gt;</button>
            </div>
            <div class="flex items-center gap-3">
              <label class="inline-flex items-center gap-1 text-sm">
                <input id="status-show-order-wait" type="checkbox" ${statusOrderWaitOnly ? 'checked' : ''} />
                <span>オーダー待ちのみ</span>
              </label>
              <label class="inline-flex items-center gap-1 text-sm">
                <input id="status-show-past" type="checkbox" ${showPast ? 'checked' : ''} />
                <span>過去を表示</span>
              </label>
              <button id="status-reload" class="px-2 py-1 rounded border bg-white text-sm">再読込</button>
            </div>
          </div>`;

        // const ORDER_WAIT_STATUSES = ['オーダー待ち', 'オーダー待ち（仮キャスティング）']; // Moved to global scope

        const grouped = new Map();
        for (const c of castingData) {
          if (!c.startDate || !c.endDate) continue;
          const from = new Date(c.startDate);
          const to = new Date(c.endDate);
          let d = new Date(Math.max(from, monthStart));
          const lastDayInScope = new Date(Math.min(to, monthEnd));

          while (d <= lastDayInScope) {
            const dateKey = d2str(d);
            const epoch = toEpochDay(dateKey);
            if (!showPast && epoch < TODAY_EPOCH) {
              d.setDate(d.getDate() + 1);
              continue;
            }
            if (!grouped.has(dateKey)) grouped.set(dateKey, new Map());
            const dateGroup = grouped.get(dateKey);
            const accountName = c.accountName || 'N/A';
            if (!dateGroup.has(accountName)) dateGroup.set(accountName, new Map());
            const accountGroup = dateGroup.get(accountName);

            // Expand structureData if available
            if (c.structureData && Array.isArray(c.structureData) && c.structureData.length > 0) {
              c.structureData.forEach(item => {
                const pName = item.project || '未定';
                if (!accountGroup.has(pName)) accountGroup.set(pName, []);
                // Create a virtual record for display
                accountGroup.get(pName).push({
                  ...c,
                  projectName: pName,
                  roleName: item.role || c.roleName,
                  rank: item.rank || c.rank,
                  mainSub: item.type || c.mainSub,
                  note: item.note || c.note
                });
              });
            } else {
              // Fallback for old data (merged)
              const projectName = c.projectName || 'N/A';
              if (!accountGroup.has(projectName)) accountGroup.set(projectName, []);
              accountGroup.get(projectName).push(c);
            }

            d.setDate(d.getDate() + 1);
          }
        }

        const sortedDates = Array.from(grouped.keys()).sort();
        let html = header;
        const SPECIAL_ACCOUNTS = ['外部案件', '社内イベント'];

        if (sortedDates.length === 0) {
          html += `<p class="text-gray-600">該当月のキャスティング登録はありません。</p>`;
        } else {
          for (const date of sortedDates) {
            const dateGroup = grouped.get(date);
            let allRecordsInDate = Array.from(dateGroup.values()).flatMap(acc => Array.from(acc.values()).flat());
            const hasOrderWait = allRecordsInDate.some(it => ORDER_WAIT_STATUSES.includes(it.status));
            if (statusOrderWaitOnly && !hasOrderWait) continue;

            // ★フィルタリング判定 (日付単位で表示するかどうかは、その日付に含まれるアカウントがフィルタに合致するかで決める？
            // いや、日付ブロックは表示して、その中のアカウントをフィルタリングすべきか？
            // ユーザー要望: "表示分け（タブ化）" -> タブ切り替えで表示内容が変わる。
            // 日付ブロックの中にアカウントごとのブロックがある構造。
            // なので、日付ブロック自体を表示するかどうかは、"フィルタリング後のアカウントが1つでもあるか" で決めるべき。

            const sortedAccounts = Array.from(dateGroup.keys()).sort();
            const visibleAccounts = sortedAccounts.filter(acc => {
              const isSpecial = SPECIAL_ACCOUNTS.includes(acc);

              if (window.currentStatusTab === 'special') {
                // 特別タブ: 特別案件だけを表示
                return isSpecial;
              } else {
                // 通常タブ: 特別案件以外を表示
                return !isSpecial;
              }
            });

            if (visibleAccounts.length === 0) continue; // 表示するアカウントがなければ次の日付へ

            html += `
          <div class="mt-6 border rounded-lg overflow-hidden status-date-group" data-date-block="${date}">
            <div class="flex items-center justify-between p-2 cursor-pointer date-header ${hasOrderWait ? 'bg-orange-50' : 'bg-gray-200'}" data-date-header="${date}">
              <h3 class="text-xl font-bold">${date}</h3>
              <button type="button" class="toggle-day flex items-center text-sm text-gray-700" data-toggle-date="${date}">
                <span class="toggle-icon mr-1">▼</span>
                <span>詳細</span>
              </button>
            </div>
            <div class="date-body p-2 bg-white" data-date-body="${date}">`;

            // ★追加確認: accountHtml生成時のレコードチェック
            for (const account of visibleAccounts) {
              const accountGroup = dateGroup.get(account);

              // 特別オーダーの場合、project名は1つしかないことが多いが念の為ループ
              const sortedProjects = Array.from(accountGroup.keys()).sort();

              // アカウント内のレコード有無チェック
              let hasRecordsInAccount = false;

              // 仮のHTMLバッファ
              let tempAccountHtml = `<div class="ml-2 border-l-2 border-gray-300 pl-4 py-2">
                  <div class="flex items-center justify-between mb-1">
                    <h4 class="text-lg font-semibold text-gray-800">${account}</h4>
                  </div>`;

              for (const project of sortedProjects) {
                let records = accountGroup.get(project);

                // オーダー待ちフィルタ
                if (statusOrderWaitOnly) {
                  records = records.filter(it => ORDER_WAIT_STATUSES.includes(it.status));
                }

                if (records.length === 0) continue;
                hasRecordsInAccount = true;

                // ★追加: 更新者の表示
                const updaters = [...new Set(records.map(r => r.updatedBy).filter(Boolean))];
                const updaterLabel = updaters.length > 0
                  ? `<span class="ml-2 text-xs text-gray-500 font-normal">by ${updaters.join(', ')}</span>`
                  : '';

                tempAccountHtml += `<div class="ml-4 mt-2">
                    <h5 class="font-medium text-gray-700 mb-1">${project}${updaterLabel}</h5>`;

                const tableRows = records.map(it => {
                  const cast = castData.find(c => c.castId === it.castId);
                  const castName = cast?.name || it.castId;
                  const [badgeClass, rowMutedClass] = (() => {
                    const s = it.status;
                    if (s === '決定') return ['bg-red-100 text-red-700', ''];
                    if (s === 'キャンセル') return ['bg-gray-200 text-gray-700', ''];
                    if (s === '打診中') return ['bg-blue-100 text-blue-700', ''];
                    if (s === '条件つきOK') return ['bg-emerald-100 text-emerald-700', ''];
                    if (s === 'NG') return ['bg-gray-300 text-gray-800', 'opacity-50'];
                    if (ORDER_WAIT_STATUSES.includes(s)) return ['bg-amber-100 text-amber-800', ''];
                    return ['bg-yellow-100 text-yellow-800', ''];
                  })();

                  // Order Wait の場合は金額編集可能に
                  let costDisplay = it.cost ? '¥' + Number(it.cost).toLocaleString() : '-';
                  let actionCol = '';

                  if (ORDER_WAIT_STATUSES.includes(it.status)) {
                    costDisplay = `
                      <input type="text" class="status-cost-input border rounded px-1 py-0.5 text-xs w-20 text-right bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                             value="${it.cost || ''}" placeholder="¥">
                    `;
                    actionCol = `
                      <button class="px-2 py-1 bg-emerald-600 text-white rounded text-xs hover:bg-emerald-700 shadow-sm whitespace-nowrap"
                          onclick="saveCastingCost('${it.castingId}', '${it.status}', this)">
                          保存
                      </button>
                    `;
                  }

                  return `
                <tr class="border-b hover:bg-gray-50 casting-row ${rowMutedClass}" data-casting-id="${it.castingId}">
                  <td class="py-2 px-2">${it.roleName || '-'}</td>
                  <td class="py-2 px-2 text-center">${it.rank || '-'}</td>
                  <td class="py-2 px-2 text-center">${it.mainSub || '-'}</td>
                  <td class="py-2 px-2">${castName}</td>
                  <td class="py-2 px-2"><span class="inline-block text-xs px-2 py-1 rounded-full ${badgeClass}">${it.status || '-'}</span></td>
                  <td class="py-2 px-2 text-right">${costDisplay}</td>
                  <td class="py-2 px-2 text-xs text-gray-600">${it.note || ''}</td>
                  <td class="py-2 px-2 text-center">${actionCol}</td>
                </tr>`;
                }).join('');

                tempAccountHtml += `
              <div class="overflow-x-auto bg-white rounded-lg shadow-sm">
                <table class="min-w-full text-sm table-fixed">
                  <thead class="bg-gray-100">
                    <tr>
                      <th class="text-left py-2 px-2 w-24">役名</th>
                      <th class="text-center py-2 px-2 w-12">役候補</th>
                      <th class="text-center py-2 px-2 w-16">区分</th>
                      <th class="text-left py-2 px-2 w-32">キャスト</th>
                      <th class="text-left py-2 px-2 w-40">ステータス</th>
                      <th class="text-right py-2 px-2 w-24">金額</th>
                      <th class="text-left py-2 px-2">備考</th>
                      <th class="text-center py-2 px-2 w-16">保存</th>
                    </tr>
                  </thead>
                  <tbody>${tableRows}</tbody>
                </table>
              </div></div>`;
              }

              tempAccountHtml += `</div>`;

              // レコードが1つでもあればHTMLに追加
              if (hasRecordsInAccount) {
                html += tempAccountHtml;
              }
            }
            html += `</div></div>`;
          }
        }

        view.innerHTML = html;

        view.querySelector('#status-prev-month')?.addEventListener('click', async () => { statusMonth.setMonth(statusMonth.getMonth() - 1); saveStatusMonth(statusMonth); await renderCastingStatusView(true); });
        view.querySelector('#status-next-month')?.addEventListener('click', async () => { statusMonth.setMonth(statusMonth.getMonth() + 1); saveStatusMonth(statusMonth); await renderCastingStatusView(true); });
        view.querySelector('#status-show-past')?.addEventListener('change', async e => { showPast = !!e.target.checked; await renderCastingStatusView(false); });
        view.querySelector('#status-show-order-wait')?.addEventListener('change', async e => { statusOrderWaitOnly = !!e.target.checked; await renderCastingStatusView(false); });
        view.querySelector('#status-reload')?.addEventListener('click', async () => { await renderCastingStatusView(true); });

        view.querySelectorAll('.date-header, .toggle-day').forEach(el => {
          el.addEventListener('click', (e) => {
            if (e.target.closest('button, a, input, select, textarea')) {
              if (e.target.closest('.toggle-day')) { } else { return; }
            }
            const date = el.getAttribute('data-date-header') || el.getAttribute('data-toggle-date');
            if (!date) return;
            const body = view.querySelector(`.date-body[data-date-body="${date}"]`);
            const icon = view.querySelector(`.toggle-day[data-toggle-date="${date}"] .toggle-icon`);
            if (!body) return;
            body.classList.toggle('hidden');
            if (icon) icon.textContent = body.classList.contains('hidden') ? '▶' : '▼';
          });
        });

        if (isAdmin) {
          view.querySelectorAll('.casting-row').forEach(row => {
            row.addEventListener('click', e => {
              if (e.target.closest('button, input')) return;
              const id = row.getAttribute('data-casting-id');
              if (id) handleCastingRowClick(id);
            });
          });
          view.querySelectorAll('[data-add-order="1"]').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const ds = e.currentTarget.dataset;
              // Rename startAdditionalOrder to openAdditionalOrderModal
              startAdditionalOrder({
                date: ds.date,
                accountName: ds.account,
                projectId: ds.projectId,
                slackThreadTs: ds.threadTs,
                slackPermalink: ds.permalink,
              });
            });
          });
        }
      }

      // ==== Admin: status change & edit ====

      // 2-3. postStatusUpdateToSlack の修正
      async function postStatusUpdateToSlack(rec, newStatus, extraMessage) {
        try {
          // 内部キャストはSlack通知しないが、Notion連携のためにAPIは叩く
          // if (rec.isInternal) return; // Removed to allow Notion sync

          const payload = {
            castingId: rec.castingId,
            newStatus,
            castName: rec.castName || rec.castId || "",
            slackThreadTs: rec.slackThreadTs,
            slackPermalink: rec.slackPermalink || "",
            extraMessage: extraMessage || "",
            isInternal: !!rec.isInternal,
            projectId: rec.projectId || "", // Notion Page ID
            mainSub: rec.mainSub || "その他", // Cast Type
            orderDetails: rec.structureData || [] // ★追加: W列のデータを送る
          };

          const res = await fetch("/api/notify/status_update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            console.error("Slack status update notify failed", err);
            showMessage("Slackへのステータス更新通知に失敗しました。", "error");
            return;
          }

        } catch (e) {
          console.error("Slack status update notify exception", e);
          showMessage("Slackへのステータス更新通知でエラーが発生しました。", "error");
        }
      }
      // ★ 差し替え：changeCastingStatus 全体
      async function changeCastingStatus(castingId, newStatus, extraArg = "") {
        if (!isAdmin) {
          showMessage('権限がありません。', 'error');
          return;
        }

        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) {
          showMessage('対象が見つかりません。', 'error');
          return;
        }

        // ★ 修正ポイント1: 引数がオブジェクトの場合（クイックモード）と文字列の場合でメッセージを抽出
        let finalExtraMessage = "";
        let options = {}; // Define options to avoid ReferenceError

        if (typeof extraArg === 'object' && extraArg !== null) {
          finalExtraMessage = extraArg.extraMessage || "";
          options = extraArg; // Assign extraArg to options
        } else {
          finalExtraMessage = extraArg || "";
        }

        // 変更前ステータスを保持
        const prevStatus = rec.status;

        showLoader(true);
        try {
          // 行番号取得
          const getRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID,
            range: 'キャスティングリスト!A2:R'
          });
          const rows = getRes.result.values || [];
          let rowIdx = -1;
          for (let i = 0; i < rows.length; i++) {
            if (rows[i]?.[0] === castingId) {
              rowIdx = i;
              break;
            }
          }
          if (rowIdx === -1) {
            showMessage('対象が見つかりません。', 'error');
            return;
          }
          const targetRow = rowIdx + 2;

          // ステータス(J列) と 金額(V列) を更新
          const updates = [
            {
              range: `キャスティングリスト!J${targetRow}`,
              values: [[newStatus]]
            }
          ];

          // options.cost があれば V列も更新
          if (options && options.cost !== undefined) {
            updates.push({
              range: `キャスティングリスト!V${targetRow}`,
              values: [[options.cost]]
            });
            // ローカルも更新
            rec.cost = options.cost;
          }

          await gapi.client.sheets.spreadsheets.values.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: {
              valueInputOption: 'USER_ENTERED',
              data: updates
            }
          });

          // ローカルデータ更新
          rec.status = newStatus;

          // カレンダー側も同期
          await updateCalendarEventOnStatusChange(rec, newStatus, targetRow);

          // ===== Slack 通知ロジック =====
          // 内部/外部フラグ（rec.isInternal プロパティを使用）
          const isInternalCast = rec.isInternal;
          const isExternal = !isInternalCast;

          const isFromDashing = (prevStatus === '打診中');
          const isFinal = ['決定', 'NG', '条件つきOK'].includes(newStatus);

          // 外部キャストかつ、「打診中」→「最終ステータス」への変更時のみ通知
          if (isExternal && isFromDashing && isFinal && rec.slackThreadTs) {
            const statusForSlack = newStatus === '決定' ? 'OK' : newStatus;
            await postStatusUpdateToSlack(rec, statusForSlack, finalExtraMessage);
          }

          // 「決定」の時、キャスト（内部含む）を撮影連絡DBへ追加
          if (newStatus === "決定" || newStatus === "OK") {
            const updaterEmail = currentUser?.email || '';

            try {
              const addRes = await fetch("/api/shooting_contact/add", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  castingId: rec.castingId,
                  account: rec.accountName,
                  projectName: rec.projectName,
                  notionId: rec.projectId, // Use original Project ID (Notion Page ID)
                  roleName: rec.roleName,
                  castName: rec.castName,
                  castType: rec.isInternal ? "内部" : "外部",
                  shootDate: rec.startDate,
                  note: rec.note || "",
                  updatedBy: updaterEmail,
                  updatedAt: new Date().toISOString(),
                  mainSub: rec.mainSub || "その他",
                  cost: rec.cost || "" // ★追加: 金額
                })
              });
              if (!addRes.ok) {
                console.error("Failed to add to shooting contact DB", await addRes.text());
              } else {
              }
            } catch (err) {
              console.error("Exception calling shooting_contact/add", err);
            }
          }

          showMessage('ステータスを更新しました。');
          await renderCastingStatusView(false);
          displayAvailableCasts();
        } catch (e) {
          console.error(e);
          showMessage('更新に失敗しました。', 'error');
        } finally {
          showLoader(false);
        }
      }
      async function openEditModal(castingId) {
        if (!isAdmin) { showMessage('権限がありません。', 'error'); return; }
        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) { showMessage('対象が見つかりません。', 'error'); return; }

        const modal = document.getElementById('edit-modal'); if (!modal) return;
        modal.innerHTML = `
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full p-5">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-bold">キャスティング編集</h3>
          <button id="edit-close" class="text-gray-600 hover:text-gray-800">&times;</button>
        </div>
        <div class="space-y-3">
          <div>
            <label class="text-sm text-gray-700">作品名</label>
            <input id="edit-project" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.projectName || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">役名</label>
            <input id="edit-role" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.roleName || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">区分</label>
            <select id="edit-mainsub" class="mt-1 w-full p-2 border rounded-md">
              <option value="その他" ${rec.mainSub === 'その他' ? 'selected' : ''}>その他</option>
              <option value="メイン" ${rec.mainSub === 'メイン' ? 'selected' : ''}>メイン</option>
            </select>
          </div>
          <div>
            <label class="text-sm text-gray-700">キャス優先度</label>
            <input id="edit-priority" type="number" min="1" class="mt-1 w-full p-2 border rounded-md" value="${rec.castPriority || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">担当者</label>
            <input id="edit-bookedby" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.updatedBy || currentUser?.email || ''}">
          </div>
          <div>
            <label class="text-sm text-gray-700">金額</label>
            <input id="edit-cost" type="text" class="mt-1 w-full p-2 border rounded-md" value="${rec.cost || ''}" placeholder="金額を入力">
          </div>
          <div>
            <label class="text-sm text-gray-700">ステータス</label>
            <select id="edit-status" class="mt-1 w-full p-2 border rounded-md">
              ${[
            'オーダー待ち',
            '打診中',
            '決定',
            'NG',
            '条件つきOK',
            '仮キャスティング',
          ].map(s => `<option value="${s}" ${rec.status === s ? 'selected' : ''}>${s}</option>`).join('')}
            </select>
             <p class="text-xs text-gray-500 mt-1">
              ※「条件つきOK」を選んだ場合、下のコメント欄も入力できます。
            </p>
          </div>
          <div id="edit-status-comment-wrap" class="mt-2 ${rec.status === '条件つきOK' ? '' : 'hidden'}">
            <label class="text-sm text-gray-700">条件つきOKコメント</label>
            <textarea id="edit-status-comment" class="mt-1 w-full p-2 border rounded-md" rows="3"
              placeholder="条件や注意事項などを入力してください"></textarea>
          </div>
        </div>
        <div class="mt-4 flex justify-end gap-3">
          <button id="edit-cancel" class="px-4 py-2 rounded-md border border-gray-300">閉じる</button>
          <button id="edit-save" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">保存</button>
        </div>
      </div>`;
        modal.classList.remove('hidden');

        const statusSelect = modal.querySelector('#edit-status');
        const commentWrap = modal.querySelector('#edit-status-comment-wrap');
        if (statusSelect && commentWrap) {
          statusSelect.addEventListener('change', () => {
            if (statusSelect.value === '条件つきOK') {
              commentWrap.classList.remove('hidden');
            } else {
              commentWrap.classList.add('hidden');
            }
          });
        }

        modal.querySelector('#edit-close')?.addEventListener('click', closeEditModal);
        modal.querySelector('#edit-cancel')?.addEventListener('click', closeEditModal);
        modal.querySelector('#edit-save')?.addEventListener('click', async () => {
          await saveEdit(castingId);
        });
      }
      function closeEditModal() { const modal = document.getElementById('edit-modal'); if (!modal) return; modal.classList.add('hidden'); modal.innerHTML = ''; }

      function startAdditionalOrder(context) {
        const { date, accountName, projectId, slackThreadTs, slackPermalink } = context;
        if (!slackThreadTs) {
          showMessage('追加オーダーの元となる有効なオーダーが見つかりません。', 'error');
          return;
        }

        // 代表レコードを探して、プロジェクト名などを取得
        const rec = castingData.find(c => c.accountName === accountName && c.projectId === projectId && c.slackThreadTs === slackThreadTs);
        if (!rec) {
          showMessage('追加オーダーの元となる代表レコードが見つかりません。', 'error');
          return;
        }

        // ★追加: 前回のファイルが残っている可能性があるのでクリア
        if (cartMeta && cartMeta.pdfFiles) delete cartMeta.pdfFiles;

        isAdditionalOrderMode = true;
        additionalOrderContext = {
          accountName: accountName,
          projectName: rec.projectName, // 代表レコードのプロジェクト名を使う
          projectId: projectId,
          slackThreadTs: slackThreadTs,
          slackPermalink: slackPermalink,
          startDate: date, // この日のオーダー
          endDate: date,
        };

        // cart = {}; // Do NOT clear cart (User might have selected casts)
        const projectNames = rec.projectName.split('/');
        const notionPageId = projectId.replace(/-/g, '');
        cartMeta = {
          account: accountName,
          notionUrl: notionPageId ? `https://www.notion.so/${notionPageId}` : '',
          projectNames: [projectNames[0] || '', projectNames[1] || '', projectNames[2] || ''],
          combinedProjectNames: rec.projectName.includes('/') ? [rec.projectName] : []
        };

        // Populate cartProjects with inherited project name
        // If cartProjects is empty (or default), replace it?
        // Or just add?
        // "その作品名...を引き継いで" -> likely we want to start with that project.
        cartProjects = [{
          id: 'proj_' + Date.now(),
          title: rec.projectName, // Inherit Project Name
          roles: []
        }];
        // Add default roles
        for (let i = 0; i < 3; i++) {
          cartProjects[0].roles.push({
            id: 'role_' + Date.now() + '_' + i,
            name: '',
            type: 'その他',
            note: '',
            castIds: []
          });
        }

        updateCartCount();

        selectedDates = [date];

        switchView('casting-view');

        renderCalendar();
        updateSelectedPeriodDisplay();
        displayAvailableCasts();

        showMessage(`追加オーダーモードを開始しました：${accountName} / ${date}`, 'info');
      }

      function handleCastingRowClick(castingId) {
        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) return;

        // 内部キャストは常に「編集モーダル」を開く（今まで通り）
        if (rec.isInternal) {
          openStatusQuickModal(castingId);
          return;
        }

        // 外部キャスト ＋ ステータスが「オーダー待ち」のときだけ
        // 1回目のクリックで「打診メール作成ポップアップ」を開く
        if (rec.status === "オーダー待ち") {
          openShootMailModal(castingId); // Use the new unified mail modal
          return;
        }

        // 外部キャスト ＋ 「打診中 / 決定 / NG / 条件つきOK など」
        // → ステータス更新用のクイックモーダルを開く
        openStatusQuickModal(castingId);
      }
      function openExternalOrderMailModal(rec) {
        const modal = document.getElementById('edit-modal');
        modal.innerHTML = `
    <div class="bg-white rounded-lg shadow-xl max-w-lg w-full p-6">
      <h3 class="text-xl font-bold mb-4">外部キャスト：打診メール作成</h3>

      <textarea id="external-mail-body" class="w-full h-48 p-2 border rounded-md text-sm leading-relaxed">
${buildExternalMailBody(rec)}
      </textarea>

      <div class="mt-6 flex justify-end gap-3">
        <button id="external-mail-cancel" class="px-4 py-2 rounded-md border border-gray-300">閉じる</button>
        <button id="external-mail-send" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">打診メール送信済みにする</button>
      </div>
    </div>
  `;
        modal.classList.remove("hidden");

        document.getElementById("external-mail-cancel")?.addEventListener("click", closeEditModal);
        document.getElementById("external-mail-send")?.addEventListener("click", async () => {
          await changeCastingStatus(rec.castingId, "打診中");
          closeEditModal();
        });
      }

      function buildExternalMailBody(rec) {
        return `お世話になっております、直前のご依頼申し訳ございません。
以下作品にて、ご出演いただきたく
${rec.startDate || 'MM/DD'}(曜日)のスケジュールについてお伺いできますでしょうか。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
【撮影概要】
撮影日　：${rec.startDate || 'MM/DD'}(曜日)
作品名：「${rec.projectName}」
役柄　：${rec.roleName || ''}役

クライアント：なし
競合：なし

投稿先：ごっこ倶楽部tik tokアカウント
https://www.tiktok.com/@gokko5club
投稿先：daikaiアカウント
https://www.tiktok.com/@daikai_55
投稿先：ウミガメごっこアカウント
https://www.tiktok.com/@gokko5club.umigame
投稿先：docomo
https://www.tiktok.com/@docomo.official

※その他ごっこ倶楽部運営の各種SNSなどでも投稿予定。
https://www.youtube.com/@gokko5club/
https://x.com/gokko5club
https://www.instagram.com/gokko5club/

※docomoさまの各種SNSなどで投稿予定
https://www.youtube.com/user/docomoOfficial
その他ごっこ倶楽部運営の各種SNSなどでも投稿予定。
https://www.youtube.com/@gokko5club/
https://x.com/gokko5club
https://www.instagram.com/gokko5club/

投稿アカウント：まいはにTikTokアカウント、および各種SNS予定
https://www.tiktok.com/@maihani.4
https://www.youtube.com/channel/UCTStisbrmEM6oIX9Yaq9-NA
https://www.instagram.com/maihani.4/

※作品認知向上のため、
プレスリリースや各種SNSでの告知発信の可能性もございます。

使用期間：無期限

二次使用：予定あり
・ドラマ素材を活用した各種SNSでの広告配信
X、Instagram、YouTube
・今回の施策用のキャンペーンページ(Webサイト)
二次使用期間は3ヶ月

ご出演料：￥${rec.cost ? Number(rec.cost).toLocaleString() : '18,000'}〜/day
※出演時間確定次第となりますが上記を想定しております
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
大変恐れ入りますが、
取り急ぎスケジュールの有無についてご確認いただけますと幸いです。

何卒よろしくお願い申し上げます。`.trim();
      }

      async function updateCalendarEventOnStatusChange(rec, newStatus, rowNumber) {
        try {
          if (!INTERNAL_HOLD_CALENDAR_ID) return;
          if (!rec.calendarEventId) return;

          // ---- NG の場合は予定を削除する -------------------------
          if (newStatus === 'NG') {
            try {
              await gapi.client.calendar.events.delete({
                calendarId: INTERNAL_HOLD_CALENDAR_ID,
                eventId: rec.calendarEventId,
              });
            } catch (e) {
              // 404（すでに削除済み）の場合は無視、それ以外はログだけ残す
              if (!(e && e.status === 404)) {
                console.error('カレンダー予定削除に失敗:', e);
              }
            }

            // シートの N列(calendarEventId)を空にする
            if (rowNumber) {
              try {
                await gapi.client.sheets.spreadsheets.values.batchUpdate({
                  spreadsheetId: SPREADSHEET_ID,
                  resource: {
                    valueInputOption: 'USER_ENTERED',
                    data: [
                      {
                        range: `キャスティングリスト!N${rowNumber}`,
                        values: [['']],
                      },
                    ],
                  },
                });
              } catch (e) {
                console.error('calendarEventId のクリアに失敗:', e);
              }
            }

            // ローカルデータもクリア
            rec.calendarEventId = '';
            return; // ここで終了（決定タイトルなどの更新は行わない）
          }

          // ---- それ以外のステータスは既存通り「更新」ロジック ----

          // 現在のイベント取得
          const getRes = await gapi.client.calendar.events.get({
            calendarId: INTERNAL_HOLD_CALENDAR_ID,
            eventId: rec.calendarEventId,
          });
          const event = getRes.result;

          // サマリー：決定のときだけ特別な文言
          const summary =
            newStatus === '決定'
              ? `${rec.accountName || 'アカウント未設定'}_決定キャスティング`
              : (event.summary ||
                `${rec.accountName || 'アカウント未設定'}_${rec.rank || ''}候補_${newStatus}`);

          // 説明文の「ステータス」行を差し替え
          let description = event.description || '';
          const statusLineRe = /・ステータス: .*/;
          if (statusLineRe.test(description)) {
            description = description.replace(statusLineRe, `・ステータス: ${newStatus}`);
          } else {
            description += (description ? '\n' : '') + `・ステータス: ${newStatus}`;
          }

          await gapi.client.calendar.events.patch({
            calendarId: INTERNAL_HOLD_CALENDAR_ID,
            eventId: rec.calendarEventId,
            resource: {
              summary,
              description,
            },
          });
        } catch (e) {
          console.error('カレンダー予定更新に失敗:', e);
          // UI側の挙動は継続させたいので、ここでは例外を投げずログのみにする
        }
      }

      async function saveEdit(castingId) {
        if (!isAdmin) { showMessage('権限がありません。', 'error'); return; }
        const rec = castingData.find(c => c.castingId === castingId); if (!rec) { showMessage('対象が見つかりません。', 'error'); return; }
        const prevStatus = rec.status; // 変更前のステータスを保持

        const modal = document.getElementById('edit-modal');
        const newProject = modal.querySelector('#edit-project')?.value?.trim() || '';
        const newRole = modal.querySelector('#edit-role')?.value?.trim() || '';
        const newMainSub = modal.querySelector('#edit-mainsub')?.value || 'その他';
        const newPriorityRaw = modal.querySelector('#edit-priority')?.value;
        const newPriority = Number.isFinite(parseInt(newPriorityRaw, 10)) ? parseInt(newPriorityRaw, 10) : '';
        const newCost = modal.querySelector('#edit-cost')?.value?.trim() || ''; // Cost
        const newBooked = modal.querySelector('#edit-bookedby')?.value?.trim() || ''; // This is now 'updater'
        const newStatus = modal.querySelector('#edit-status')?.value || rec.status;
        const commentEl = modal.querySelector('#edit-status-comment');
        const commentText = commentEl ? (commentEl.value || '') : '';

        showLoader(true);
        try {
          // 行番号探索
          const getRes = await gapi.client.sheets.spreadsheets.values.get({
            spreadsheetId: SPREADSHEET_ID, range: 'キャスティングリスト!A2:R'
          });
          const rows = getRes.result.values || [];
          let rowIdx = -1; for (let i = 0; i < rows.length; i++) { if (rows[i]?.[0] === castingId) { rowIdx = i; break; } }
          if (rowIdx === -1) { showMessage('対象が見つかりません。', 'error'); return; }
          const targetRow = rowIdx + 2;

          const updates = [
            { range: `キャスティングリスト!C${targetRow}`, values: [[newProject]] },
            { range: `キャスティングリスト!D${targetRow}`, values: [[newRole]] },
            { range: `キャスティングリスト!J${targetRow}`, values: [[newStatus]] },
            { range: `キャスティングリスト!N${targetRow}`, values: [[newMainSub]] }, // N列: mainSub
            { range: `キャスティングリスト!Q${targetRow}`, values: [[newBooked]] }, // Updater
            { range: `キャスティングリスト!R${targetRow}`, values: [[newPriority]] }, // Cast Priority
            { range: `キャスティングリスト!V${targetRow}`, values: [[newCost]] }, // V列: Cost
          ];

          await gapi.client.sheets.spreadsheets.values.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: { valueInputOption: 'USER_ENTERED', data: updates }
          });

          // ローカル反映
          rec.projectName = newProject; rec.roleName = newRole; rec.updatedBy = newBooked; rec.status = newStatus; rec.castPriority = newPriority; rec.mainSub = newMainSub; rec.cost = newCost;

          // Slack 通知は外部キャストかつ「打診中 → 最終ステータス」への遷移だけ
          const isExternal = !rec.isInternal;
          const isFromDashing = (prevStatus === "打診中");
          const isFinal = ["決定", "NG", "条件つきOK"].includes(newStatus);

          if (isExternal && isFromDashing && isFinal) {
            const statusForSlack = newStatus === '決定' ? 'OK' : newStatus;
            await postStatusUpdateToSlack(rec, statusForSlack, commentText);
          }

          await updateCalendarEventOnStatusChange(rec, newStatus, targetRow);

          closeEditModal();
          showMessage('更新しました。');
          await renderCastingStatusView(false); // Do not force reload, just re-render
          displayAvailableCasts();
        } catch (e) {
          console.error(e); showMessage('更新に失敗しました。', 'error');
        } finally { showLoader(false); }
      }


      function openStatusQuickModal(castingId) {
        if (!isAdmin) { showMessage('権限がありません。', 'error'); return; }
        const rec = castingData.find(c => c.castingId === castingId);
        if (!rec) { showMessage('対象が見つかりません。', 'error'); return; }

        const modal = document.getElementById('status-quick-modal');
        if (!modal) return;

        const cast = castData.find(c => c.castId === rec.castId);
        const castName = cast?.name || rec.castName || rec.castId || '';
        const currentStatus = rec.status || '';

        // ★修正: シンプルなセレクトボックス形式のHTMLに差し替え
        modal.innerHTML = `
      <div class="bg-white rounded-lg shadow-xl max-w-md w-full p-5">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-bold">ステータス更新</h3>
          <button id="status-quick-close" class="text-gray-600 hover:text-gray-800">&times;</button>
        </div>
        
        <div class="text-sm text-gray-700 mb-4 border-b pb-3">
          <div>作品：${rec.projectName || '-'}</div>
          <div>役名：${rec.roleName || '-'}</div>
          <div>氏名：${castName}</div>
          <div class="mt-1 text-xs text-gray-500">現在：${currentStatus}</div>
        </div>

        <div class="space-y-3 text-sm">
          <div>
            <label class="block text-xs font-medium text-gray-600 mb-1">
              ステータス
            </label>
            <select
              id="status-edit-status"
              class="w-full border rounded px-2 py-1 text-sm"
            >
              <option value="決定" ${currentStatus === '決定' || currentStatus === 'OK' ? 'selected' : ''}>OK（決定）</option>
              <option value="NG" ${currentStatus === 'NG' ? 'selected' : ''}>NG</option>
              <option value="条件つきOK" ${currentStatus === '条件つきOK' ? 'selected' : ''}>条件つきOK</option>
              <option value="オーダー待ち" ${currentStatus === 'オーダー待ち' ? 'selected' : ''}>オーダー待ち</option>
              <option value="打診中" ${currentStatus === '打診中' ? 'selected' : ''}>打診中</option>
            </select>
          </div>

          <div>
            <label class="block text-xs font-medium text-gray-600 mb-1">
              金額
            </label>
            <input
              type="text"
              id="status-edit-cost"
              class="w-full border rounded px-2 py-1 text-sm text-right"
              placeholder="¥"
              value="${rec.cost || ''}"
            >
          </div>

          <div
            id="status-edit-extra-message-wrapper"
            class="space-y-1 ${currentStatus === "条件つきOK" ? "" : "hidden"}"
          >
            <label class="block text-xs font-medium text-gray-600">
              条件メモ（Slackに一緒に送信されます）
            </label>
            <textarea
              id="status-edit-extra-message"
              rows="3"
              class="w-full border rounded px-2 py-1 text-xs"
              placeholder="例）・条件：◯◯はNG、△△の場合のみ出演可能 など"
            ></textarea>
          </div>
        </div>

        <div class="mt-6 flex justify-end gap-3">
          <button id="status-quick-cancel" class="px-4 py-2 rounded-md border border-gray-300">キャンセル</button>
          <button id="status-quick-save" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">更新</button>
        </div>
      </div>`;

        modal.classList.remove('hidden');

        // ★イベントリスナー設定
        const statusSelect = modal.querySelector("#status-edit-status");
        const costInput = modal.querySelector("#status-edit-cost");
        const extraMessageWrapper = modal.querySelector("#status-edit-extra-message-wrapper");
        const extraMessageInput = modal.querySelector("#status-edit-extra-message");

        // ステータス変更時の表示切り替え
        statusSelect.addEventListener("change", () => {
          if (statusSelect.value === "条件つきOK") {
            extraMessageWrapper.classList.remove("hidden");
          } else {
            extraMessageWrapper.classList.add("hidden");
          }
        });

        // 閉じる・キャンセルボタン
        modal.querySelector('#status-quick-close')?.addEventListener('click', closeStatusQuickModal);
        modal.querySelector('#status-quick-cancel')?.addEventListener('click', closeStatusQuickModal);

        // 更新ボタン（シンプル化した取得ロジック）
        modal.querySelector('#status-quick-save')?.addEventListener('click', async () => {
          const newStatus = statusSelect.value;
          const newCost = costInput.value.trim();
          const extraMessage = extraMessageInput.value || "";

          // API呼び出し
          // changeCastingStatus needs to support cost update.
          // Currently it calls /api/notify/status_update AND updates sheet.
          // But changeCastingStatus implementation (lines 1200+) might not handle Cost update to sheet.
          // Let's check changeCastingStatus.
          // If it doesn't, we might need to call saveEdit logic or update changeCastingStatus.
          // For now, let's pass cost to changeCastingStatus and ensure it handles it.
          await changeCastingStatus(rec.castingId, newStatus, {
            quick: true,
            extraMessage: extraMessage,
            cost: newCost
          });

          closeStatusQuickModal();
        });
      }

      function closeStatusQuickModal() {
        const modal = document.getElementById('status-quick-modal');
        if (!modal) return;
        modal.classList.add('hidden');
        modal.innerHTML = '';
      }

      // ========= Calendar (today red) =========
      function renderCalendar() {
        const monthYearEl = document.getElementById('current-month-year');
        const grid = document.getElementById('calendar-grid');
        if (!monthYearEl || !grid) return;

        // header
        monthYearEl.textContent = `${calendarDate.getFullYear()}年${calendarDate.getMonth() + 1}月`;

        // clear & rebuild
        grid.innerHTML = '';
        const frag = document.createDocumentFragment();

        // weekday header
        ['日', '月', '火', '水', '木', '金', '土'].forEach(d => {
          const h = document.createElement('div');
          h.textContent = d; h.className = 'font-bold text-gray-600';
          frag.appendChild(h);
        });

        const y = calendarDate.getFullYear(), m = calendarDate.getMonth();
        const first = new Date(y, m, 1), last = new Date(y, m + 1, 0);

        // leading blanks
        for (let i = 0; i < first.getDay(); i++) {
          const blank = document.createElement('div'); blank.className = 'p-2';
          frag.appendChild(blank);
        }

        // days
        for (let day = 1; day <= last.getDate(); day++) {
          const d = new Date(y, m, day);
          const ymd = d2str(d);
          const cell = document.createElement('div');
          const isToday = (ymd === TODAY_STR);
          const isSelected = selectedDates.includes(ymd);
          const isPast = toEpochDay(ymd) < TODAY_EPOCH;

          cell.dataset.date = ymd;
          cell.textContent = String(day);

          if (isPast) {
            cell.className = 'p-2 rounded-md text-gray-400 cursor-not-allowed';
          } else {
            cell.className = 'p-2 rounded-md cursor-pointer hover:bg-blue-200 calendar-day';
            if (isSelected) { cell.classList.add('bg-blue-500', 'text-white'); }
            else if (isToday) { cell.classList.add('text-red-600', 'font-semibold'); }
          }
          frag.appendChild(cell);
        }
        grid.appendChild(frag);
      }

      // ========= Additional Casting List =========
      function renderShootingList() {
        const container = document.getElementById('shooting-list-container');
        if (!container) return;

        if (selectedDates.length !== 1) {
          container.innerHTML = '';
          container.classList.add('hidden');
          return;
        }

        const date = selectedDates[0];
        // Find existing shootings for this date
        // Group by Account + Project Name
        const shootings = castingData.filter(c => c.startDate === date && c.slackThreadTs);

        if (shootings.length === 0) {
          container.innerHTML = '';
          container.classList.add('hidden');
          return;
        }

        const uniqueShootings = new Map();
        shootings.forEach(s => {
          const key = `${s.accountName}__${s.projectName}`;
          if (!uniqueShootings.has(key)) {
            uniqueShootings.set(key, s);
          }
        });

        container.classList.remove('hidden');
        container.innerHTML = `
          <div class="text-sm font-bold text-gray-700 mb-2">この日の既存撮影（追加キャスティング）:</div>
          <div class="flex flex-wrap gap-2">
            ${Array.from(uniqueShootings.values()).map(s => `
              <button onclick="startAdditionalOrder({
                date: '${s.startDate}',
                accountName: '${s.accountName}',
                projectId: '${s.projectId}',
                slackThreadTs: '${s.slackThreadTs}',
                slackPermalink: '${s.slackPermalink}'
              })" class="px-3 py-2 bg-blue-100 text-blue-800 rounded hover:bg-blue-200 text-sm font-semibold flex items-center gap-2">
                <span>${s.accountName} / ${s.projectName}</span>
                <span class="text-xs bg-white px-1 rounded border">追加</span>
              </button>
            `).join('')}
          </div>
        `;
      }

      // ========= Filters =========
      function renderFilters() {
        const container = document.getElementById('cast-filters-container'); if (!container) return;

        // Horizontal Layout: Gender | Agency | Keyword | AvailableOnly | Sort
        container.innerHTML = `
    <!-- Gender -->
    <div class="flex flex-col">
      <span class="text-xs font-bold text-gray-500 mb-1">性別</span>
      <div class="flex items-center space-x-3 bg-white border rounded px-3 py-2 h-10">
        <label class="inline-flex items-center space-x-1 cursor-pointer">
          <input id="filter-gender-male" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
          <span class="text-sm">男性</span>
        </label>
        <label class="inline-flex items-center space-x-1 cursor-pointer">
          <input id="filter-gender-female" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
          <span class="text-sm">女性</span>
        </label>
      </div>
    </div>

    <!-- Agency -->
    <div class="flex flex-col relative w-48">
      <label class="text-xs font-bold text-gray-500 mb-1">事務所</label>
      <button id="agency-filter-btn" class="w-full px-3 py-2 border rounded bg-white text-left text-sm flex justify-between items-center h-10">
        <span class="truncate">選択...</span>
        <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
      </button>
      <div id="agency-filter-dropdown" class="hidden absolute top-full left-0 w-full mt-1 bg-white border rounded shadow-lg z-20 max-h-60 overflow-y-auto"></div>
    </div>

    <!-- Keyword -->
    <div class="flex flex-col flex-grow min-w-[200px]">
      <label for="filter-keyword" class="text-xs font-bold text-gray-500 mb-1">フリーワード</label>
      <input id="filter-keyword" type="text" placeholder="名前・事務所・メモ" class="w-full px-3 py-2 border rounded text-sm h-10">
    </div>

    <!-- Extra Options (Available Only / Appearance) -->
    <div class="flex flex-col justify-end pb-1 gap-2">
       <div class="flex items-center">
          <input id="filter-available-only" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
          <label for="filter-available-only" class="ml-2 text-sm text-gray-700 cursor-pointer">未仮キャスのみ</label>
       </div>
    </div>
    
    <!-- Sort (Compact) -->
    <div class="flex flex-col justify-end pb-1 gap-2 ml-auto">
       <div class="flex items-center space-x-3 text-sm">
          <label class="inline-flex items-center space-x-1 cursor-pointer">
            <input id="sort-appearance" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
            <span>出演回数順</span>
          </label>
          <label class="inline-flex items-center space-x-1 cursor-pointer">
            <input id="sort-kana" type="checkbox" class="h-4 w-4 text-blue-600 border-gray-300 rounded">
            <span>50音順</span>
          </label>
       </div>
    </div>
  `;

        renderAgencyFilter();

        // dropdown
        const btn = document.getElementById('agency-filter-btn');
        const dd = document.getElementById('agency-filter-dropdown');
        btn?.addEventListener('click', e => { e.stopPropagation(); dd?.classList.toggle('hidden'); });
        document.addEventListener('click', e => { if (!dd || dd.classList.contains('hidden')) return; if (!dd.contains(e.target) && e.target !== btn) dd.classList.add('hidden'); });

        // sort exclusive
        const sA = document.getElementById('sort-appearance');
        const sK = document.getElementById('sort-kana');
        sA?.addEventListener('change', () => { if (sA.checked) sK.checked = false; displayAvailableCasts(); });
        sK?.addEventListener('change', () => { if (sK.checked) sA.checked = false; displayAvailableCasts(); });

        // Add listeners for new inputs
        document.getElementById('filter-keyword')?.addEventListener('input', displayAvailableCasts);
        document.getElementById('filter-gender-male')?.addEventListener('change', displayAvailableCasts);
        document.getElementById('filter-gender-female')?.addEventListener('change', displayAvailableCasts);

        document.getElementById('filter-available-only')?.addEventListener('change', displayAvailableCasts);
      }
      function renderAgencyFilter() {
        const dd = document.getElementById('agency-filter-dropdown'); if (!dd) return;
        const agencies = [...new Set(castData.map(c => c.agency?.trim() || 'フリー'))].sort((a, b) => a.localeCompare(b, 'ja'));

        dd.innerHTML = agencies.map(a => `
          <label class="flex items-center px-3 py-2 hover:bg-gray-100 cursor-pointer">
            <input type="checkbox" value="${a}" class="h-4 w-4 text-blue-600 border-gray-300 rounded mr-2" onchange="updateAgencyButton(); displayAvailableCasts();">
            <span class="text-sm text-gray-700">${a}</span>
          </label>
        `).join('');
      }

      function updateAgencyButton() {
        const btn = document.getElementById('agency-filter-btn');
        if (!btn) return;
        const checked = document.querySelectorAll('#agency-filter-dropdown input[type="checkbox"]:checked');
        if (checked.length === 0) {
          btn.firstElementChild.textContent = '選択...';
        } else if (checked.length === 1) {
          btn.firstElementChild.textContent = checked[0].value;
        } else {
          btn.firstElementChild.textContent = `選択中 (${checked.length})`;
        }
      }

      // ========= Shooting List (Area 2) =========
      let selectedShooting = null; // { pageId, title, date }

      function renderShootingList() {
        const container = document.getElementById('shooting-list-container');
        if (!container) return;

        container.innerHTML = '';

        if (selectedDates.length === 0) {
          container.innerHTML = `<p class="text-gray-500 text-sm">日付を選択すると、候補の撮影が表示されます。</p>`;
          selectedShooting = null;
          updateCartFromShooting();
          return;
        }

        // Filter shootingListData by selectedDates
        // shootingListData has { pageId, title, date, team, cd, fd }
        // We want to show titles that match ANY of the selected dates?
        // User said: "1で選ばれた撮影日に対して、該当する撮影のタイトルを2の場所に表示"
        // "複数日選択された場合は、全てに引っかかっているものではなく、引っかかった撮影日全てのタイトルを出力するイメージ"
        // So union of shootings on selected dates.

        const matchedShootings = (window.shootingListData || []).filter(item => selectedDates.includes(item.date));

        if (matchedShootings.length === 0) {
          container.innerHTML = `<p class="text-gray-500 text-sm">選択された日付の撮影予定はありません。</p>`;
          selectedShooting = null;
          updateCartFromShooting();
          return;
        }

        // Deduplicate by PageID or Title?
        // User said "PageID タイトル...". Let's assume PageID is unique.
        // If same title appears on multiple dates, do we show it once or multiple times?
        // "引っかかった撮影日全てのタイトルを出力するイメージ" -> List all occurrences or unique titles?
        // Usually you select a specific "Shooting Day" which is bound to a date.
        // If I select Dec 1 and Dec 2, and Project A shoots on both, maybe I want to select "Project A (Dec 1)"?
        // But the cart input is "Project Name" and "Notion URL".
        // If I select a shooting, I probably want to set the Project Name and Notion URL for the order.
        // Let's list all items found.

        matchedShootings.forEach(item => {
          const btn = document.createElement('div');
          // Style: Card-like button
          const isSelected = selectedShooting && selectedShooting.pageId === item.pageId && selectedShooting.date === item.date;

          btn.className = `p-3 border rounded-md cursor-pointer transition flex flex-col gap-1 ${isSelected ? 'bg-blue-100 border-blue-500 ring-1 ring-blue-500' : 'bg-white hover:bg-gray-50 border-gray-200'}`;

          btn.innerHTML = `
            <div class="font-bold text-sm text-gray-800">${item.title}</div>
            <div class="text-xs text-gray-500 flex justify-between">
              <span>${item.date}</span>
              <span>${item.team || ''}</span>
            </div>
          `;

          btn.addEventListener('click', () => {
            if (isSelected) {
              // Deselect
              selectedShooting = null;
            } else {
              selectedShooting = item;
            }
            renderShootingList(); // Re-render to update selection state
            updateCartFromShooting();
          });

          container.appendChild(btn);
        });
      }

      function updateCartFromShooting() {
        // 選択された撮影情報をメタデータにセット（確認画面や古いフローでの互換性のため）
        if (selectedShooting) {
          cartMeta.account = selectedShooting.team;
          cartMeta.notionUrl = selectedShooting.pageId ? `https://www.notion.so/${selectedShooting.pageId.replace(/-/g, '')}` : '';
          cartMeta.projectNames[0] = selectedShooting.title;

          // カートプロジェクトがまだ空なら、このタイトルで初期化する
          if (cartProjects.length === 0) {
            window.addCartProject();
            cartProjects[0].title = selectedShooting.title;
          } else if (cartProjects.length === 1 && !cartProjects[0].title) {
            cartProjects[0].title = selectedShooting.title;
          }
        }
      }

      // ========= Cart =========
      async function submitNewOrder() {
        // 1. Auth Check (Auto-Login)
        const isAuth = await ensureAuth();
        if (!isAuth) {
          alert("ログアウト状態のため送信できません。再ログインしてください。");
          handleAuthClick();
          return;
        }

        if (Object.keys(cart).length === 0) {
          showMessage('カートが空です。', 'info');
          return;
        }

        // Show Custom Confirmation Modal instead of native confirm
        const modal = document.getElementById('special-confirmation-modal');
        if (modal) {
          modal.classList.remove('hidden');

          // Reset checkboxes
          document.getElementById('confirm-intimacy').checked = false;
          document.getElementById('confirm-child').checked = false;

          // Setup one-time event listener for OK button
          const okBtn = document.getElementById('special-confirm-ok');
          // Clone button to remove old listeners
          const newOkBtn = okBtn.cloneNode(true);
          okBtn.parentNode.replaceChild(newOkBtn, okBtn);

          newOkBtn.addEventListener('click', async () => {
            modal.classList.add('hidden');

            // Handle Intimacy Check
            const isIntimacy = document.getElementById('confirm-intimacy').checked;
            if (isIntimacy) {
              // Append to note for all items in cart
              for (const key in cart) {
                if (cart[key].note) {
                  cart[key].note += "\n【インティマシーシーンあり】";
                } else {
                  cart[key].note = "【インティマシーシーンあり】";
                }
              }
            }

            // Call submission
            await confirmProvisionalBookings();
          });
        } else {
          // Fallback if modal missing
          if (!confirm('この内容でオーダーを送信しますか？')) return;
          await confirmProvisionalBookings();
        }
      }



      // Make handleAddToCart global
      window.handleAddToCart = function (castId) {
        addToCart(castId);
        const modal = document.getElementById('cast-detail-modal');
        if (modal) modal.remove();
      };

      function addToCart(castId) {
        if (!castId) return;
        if (selectedDates.length === 0) {
          showMessage('まず日付を選択してください。', 'info');
          return;
        }
        const cast = castData.find(c => c.castId === castId);
        if (!cast) return;

        const existing = cart[castId] || {};
        const baseTitles = (cartMeta.projectNames || []).map(t => t.trim()).filter(t => t);

        cart[castId] = {
          cast,
          dates: [...selectedDates],
          roleName: existing.roleName || '',
          rank: existing.rank || 1,
          dates: [...selectedDates],
          roleName: existing.roleName || '',
          rank: existing.rank || 1,
          mainSub: existing.mainSub || 'その他', // Default to 'その他'
          note: existing.note || '',
          projectName: existing.projectName || baseTitles[0] || '',
          note: existing.note || '',
          projectName: existing.projectName || baseTitles[0] || '',
        };

        updateCartCount();
        showMessage(`${cast.name} をカートに追加しました（${selectedDates.length}日）。`);
        displayAvailableCasts();
      }

      function getNextCastPriority(castId, rangeStart, rangeEnd, tempAssignments) {
        let maxPriority = 0;
        const STATUS_BLOCK = ['決定', '仮キャスティング', 'オーダー待ち', '打診中', 'オーダー待ち（仮キャスティング）', '条件つきOK'];
        for (const c of castingData) {
          if (c.castId !== castId || !STATUS_BLOCK.includes(c.status) || !overlaps(rangeStart, rangeEnd, c.startDate, c.endDate)) continue;
          const p = parseInt(c.castPriority, 10);
          if (Number.isFinite(p) && p > maxPriority) maxPriority = p;
        }
        for (const key in tempAssignments) {
          if (key.startsWith(castId + '_')) {
            const [_, tempStart, tempEnd] = key.split('_');
            if (overlaps(rangeStart, rangeEnd, tempStart, tempEnd)) {
              if (tempAssignments[key] > maxPriority) maxPriority = tempAssignments[key];
            }
          }
        }
        return maxPriority + 1;
      }

      async function confirmProvisionalBookings(confirmationData) {
        const items = Object.values(cart); if (items.length === 0) { showMessage('カートが空です。', 'info'); return; }

        // ★追加: 確認モーダルで待機している間にセッションが切れている可能性があるため再チェック
        const isAuth = await ensureAuth();
        if (!isAuth) {
          alert("認証セッションが切れました。再ログインしてください。");
          handleAuthClick();
          return;
        }

        const accountName = cartMeta.account || '';
        const notionUrl = cartMeta.notionUrl || '';
        const projectNames = cartMeta.projectNames || [];
        const updaterEmail = currentUser?.email || '';
        const projectId = extractNotionPageId(notionUrl);

        if (!accountName) { showMessage('アカウント名を入力してください。', 'error'); return; }
        if (!projectNames[0]) { showMessage('作品名1を入力してください。', 'error'); return; }
        if (!updaterEmail) { showMessage('更新者情報が取得できませんでした。', 'error'); return; }

        showLoader(true);
        const internalEvents = [];

        try {
          // 【重要】送信直前に最新データを強制取得（排他制御のため）
          await fetchCastingDataFromSheet();

          // コンフリクトチェック
          const errors = [];
          for (const it of items) {
            const workTitle = it.projectName || projectNames[0];
            const duplicate = castingData.find(c =>
              c.projectName === workTitle &&
              c.castId === it.cast.castId &&
              !['キャンセル', 'NG'].includes(c.status)
            );
            if (duplicate) {
              errors.push(`・${it.cast.name} は、作品「${workTitle}」で既に登録されています（ステータス: ${duplicate.status} / 担当: ${duplicate.updatedBy || '不明'}）`);
            }
          }

          if (errors.length > 0) {
            showLoader(false);
            alert("【エラー：重複オーダー】\n以下のキャストは、タッチの差で既に同作品に登録されました。\n\n" + errors.join("\n"));
            return;
          }

          const values = []; const nowISO = new Date().toISOString();
          const castingIdPrefix = `pc_${Date.now()}`; let seq = 1;
          const ordersForSlack = [];
          const allDateRanges = new Set();
          const tempAssignments = {};
          const allTitlesSet = new Set(); // Slack表示用に作品名を収集

          for (const it of items) {
            const ranges = groupDatesIntoRanges(it.dates);
            const workTitle = it.projectName || projectNames[0];

            // 作品名リスト作成（Slack表示用）
            if (!allTitlesSet.has(workTitle)) {
              allTitlesSet.add(workTitle);
            }

            // キャスト情報（内部/外部・メール・SlackメンションID）
            const castFull = castData.find(c => c.castId === it.cast.castId) || null;
            const internalType = castFull?.internalType || '';
            const internalLabel =
              internalType === '内部' ? '内部' :
                internalType === '外部' ? '外部' :
                  '';
            const emailForRow = internalType === '内部' ? (castFull?.email || '') : '';
            const slackMentionId = internalType === '内部' ? (castFull?.slackMentionId || '') : '';
            const isInternal = internalType === '内部';

            // ステータス初期値
            const statusValue = isInternal
              ? '仮キャスティング'
              : 'オーダー待ち';

            // Slack 通知用の注文情報
            // ★追加: 競合チェック (Conflict Check)
            // ★★★ 修正箇所: 競合チェックロジックの強化 ★★★
            let conflictMsg = null;

            // it.dates は ['2025-01-01', '2025-01-02'...] の形式
            for (const d of it.dates) {
              // 比較対象の日付 Epoch
              const targetEpoch = toEpochDay(d);

              const conflict = castingData.find(c => {
                // 自分自身のカート内の重複は除外（同じプロジェクトへの追加などはOKとする場合）
                if (c.projectName === workTitle) return false;

                // キャンセルやNGは競合とみなさない
                if (['キャンセル', 'NG', 'キャスティング完了'].includes(c.status)) return false;

                // キャストID一致
                if (c.castId !== it.cast.castId) return false;

                // 日付重複チェック (Epoch変換して比較)
                // c.startDate / c.endDate は "YYYY-MM-DD"
                const startEpoch = toEpochDay(c.startDate);
                const endEpoch = toEpochDay(c.endDate);

                if (startEpoch === null || endEpoch === null || targetEpoch === null) return false;

                // 範囲が重なるか check
                return (targetEpoch >= startEpoch && targetEpoch <= endEpoch);
              });

              if (conflict) {
                const holder = conflict.accountName || '他チーム';
                conflictMsg = `※先に【${holder}】がキャスティングしています（${conflict.status}）。`;
                console.log("Conflict found:", conflictMsg, conflict); // デバッグ用ログ
                break;
              }
            }
            // ★★★ 修正ここまで ★★★

            ordersForSlack.push({
              castingId: `${castingIdPrefix}_${seq}`,
              roleName: it.roleName || '',
              castName: it.cast.name,
              rank: it.rank,
              mainSub: it.mainSub,
              note: it.note || '',
              projectName: workTitle,
              slack_user_id: slackMentionId || null,
              conflictInfo: conflictMsg // ★追加
            });

            for (const rg of ranges) {
              const castingId = `${castingIdPrefix}_${seq++}`;
              allDateRanges.add(`${rg.start}〜${rg.end}`);

              const castPriority = getNextCastPriority(it.cast.castId, rg.start, rg.end, tempAssignments);
              tempAssignments[`${it.cast.castId}_${rg.start}_${rg.end}`] = castPriority;

              // キャスティングリスト 1 行分
              // A: castingId (0)
              // B: accountName (1)
              // C: projectName (2)
              // D: roleName (3)
              // E: castId (4)
              // F: castName (5)
              // G: startDate (6)
              // H: endDate (7)
              // I: rank (8)
              // J: status (9)
              // K: note (10)
              // L: slackThreadTs (11)
              // M: slackPermalink (12)
              // N: mainSub (13)
              // O: calendarEventId (14)
              // P: projectId (15)
              // Q: lastUpdated (16)
              // R: updatedBy (17)
              // S: castPriority (18)
              values.push([
                castingId,         // A (0)
                accountName,       // B (1)
                workTitle,         // C (2)
                it.roleName || '', // D (3)
                it.cast.castId,    // E (4)
                it.cast.name,      // F (5)
                rg.start,          // G (6)
                rg.end,            // H (7)
                it.rank,           // I (8)
                statusValue,       // J (9)
                it.note || '',     // K (10)
                "",                // L (11) slackThreadTs (あとでまとめて更新)
                "",                // M (12) slackPermalink (あとでまとめて更新)
                it.mainSub || 'その他', // N (13) mainSub
                "",                // O (14) calendarEventId (あとでカレンダー作成時に更新)
                projectId,         // P (15)
                nowISO,            // Q (16)
                updaterEmail,      // R (17)
                castPriority,      // S (18)
                isInternal ? '内部' : '外部', // T (19) internalType
              ]);

              // 内部キャストのみカレンダー仮ホールド対象にする
              if (isInternal) {
                internalEvents.push({
                  castingId,
                  cast: it.cast,
                  roleName: it.roleName || '',
                  rank: it.rank,
                  mainSub: it.mainSub,
                  accountName,
                  projectName: workTitle,
                  start: rg.start,
                  end: rg.end,
                  castPriority,
                  email: emailForRow,   // カレンダー招待用
                  status: statusValue,  // ディスクリプション用
                  rowNumber: null,      // 後で埋める
                });
              }
            }
          }
          if (values.length === 0) { showMessage('追加対象の日付がありません。', 'info'); return; }

          const appendResult = await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID, range: 'キャスティングリスト!A2',
            valueInputOption: 'USER_ENTERED', insertDataOption: 'INSERT_ROWS',
            resource: { values }
          });

          // B-2 -> A-2: 初回オーダーか追加オーダーかを判定
          const isAdditionalOrder = isAdditionalOrderMode;
          const finalContext = isAdditionalOrder ? additionalOrderContext : null;

          let slackTs = "", slackLink = "";

          if (!isAdditionalOrder) {
            // --- 初回オーダー：今まで通り /api/notify/order_created を呼ぶ ---
            const existingThread = findExistingThreadForOrder(accountName, projectId, Array.from(allDateRanges));
            if (existingThread) {
              // 既存スレッドが見つかった場合は、追加オーダーとして扱う
              slackTs = existingThread.slackThreadTs;
              slackLink = existingThread.slackPermalink;
              // 通知ロジックは後続の status_update に任せる
            } else {
              try {
                const payload = {
                  accountName: cartMeta.account,
                  projectName: "複数のオーダー",
                  projectId: extractNotionPageId(cartMeta.notionUrl) || "00000000-0000-0000-0000-000000000000",
                  dateRanges: Array.from(allDateRanges),
                  orders: ordersForSlack,
                  orderType: "test" // Default
                };

                // Use FormData to send file and payload
                const formData = new FormData();
                formData.append('payload_str', JSON.stringify(payload));
                if (cartMeta.pdfFiles && cartMeta.pdfFiles.length > 0) {
                  for (let i = 0; i < cartMeta.pdfFiles.length; i++) {
                    formData.append('files', cartMeta.pdfFiles[i]);
                  }
                }

                try {
                  const res = await fetch('/api/notify/order_created', {
                    method: 'POST',
                    body: formData // Content-Type header is set automatically
                  });
                  if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || '送信エラー');
                  }
                  const data = await res.json();
                  if (data.upload_error) {
                    showMessage(`オーダーは送信されましたが、PDFの添付に失敗しました: ${data.upload_error}`, 'error');
                  } else {
                    showMessage('オーダーを送信しました！');
                  }

                  // Set Slack info for sheet update
                  slackTs = data.ts;
                  slackLink = data.permalink;
                  cart = {};
                  cartMeta = { account: '', notionUrl: '', projectNames: ['', '', ''], combinedProjectNames: [] };
                  cartStep = 1;
                  updateCartCount();
                  closeCartModal();
                  closeConfirmationModal();
                  displayAvailableCasts();

                  // Reload data to reflect new status
                  setTimeout(() => {
                    loadAllData();
                  }, 2000);

                } catch (e) {
                  console.error(e);
                  showMessage(`送信失敗: ${e.message}`, 'error');
                } finally {
                  showLoader(false);
                }
              } catch (e) {
                console.error("Slack notification failed:", e);
                showMessage('Slack通知APIの呼び出しに失敗しました。', 'error');
              }
            }
          } else {
            // --- 追加オーダー：既存 thread に status_update を飛ばす ---
            const threadTs = finalContext.slackThreadTs;
            if (threadTs) {
              const blockLines = items.map(item => {
                const workTitle = item.projectName || finalContext.projectName;
                const roleName = item.roleName || '役名未定';
                return `${workTitle}
${roleName}：${item.cast.name}`;
              });
              const extraMessage = blockLines.join("\n");

              const mockRec = {
                castingId: values[0]?.[0] || '',
                castName: items.map(it => it.cast.name).join(', '),
                slackThreadTs: threadTs,
                slackPermalink: finalContext.slackPermalink,
                isInternal: false,
              };

              await postStatusUpdateToSlack(mockRec, '追加オーダー', extraMessage);

              // Set slackTs and slackLink for the new rows
              slackTs = finalContext.slackThreadTs;
              slackLink = finalContext.slackPermalink;
            }
          }

          if (slackTs && slackLink) {
            const updatedRange = appendResult.result.updates.updatedRange;
            const match = updatedRange.match(/!A(\d+):/);
            if (match) {
              const startRow = parseInt(match[1], 10);

              // 1) castingId ごとのシート行番号をマッピング
              const rowNumberByCastingId = new Map();
              for (let i = 0; i < values.length; i++) {
                const castingId = values[i][0]; // A列
                const rowNum = startRow + i;
                if (castingId) {
                  rowNumberByCastingId.set(castingId, rowNum);
                }
              }

              // 2) Slack の L/M 列更新
              const updates = [];
              for (let i = 0; i < values.length; i++) {
                const rowNum = startRow + i;
                // 先頭に ' を付けてテキストとして保存（小数点以下を保持するため）
                updates.push({
                  range: `キャスティングリスト!L${rowNum}`,
                  values: [[`'${slackTs}`]],
                });
                updates.push({
                  range: `キャスティングリスト!M${rowNum}`,
                  values: [[slackLink]],
                });
              }

              await gapi.client.sheets.spreadsheets.values.batchUpdate({
                spreadsheetId: SPREADSHEET_ID,
                resource: { valueInputOption: 'USER_ENTERED', data: updates }
              });

              // 3) internalEvents に行番号を埋める
              internalEvents.forEach(ev => {
                ev.rowNumber = rowNumberByCastingId.get(ev.castingId) || null;
              });
            }
          }

          values.forEach(r => {
            const s = normalizeDateString(r[6]), e = normalizeDateString(r[7]);
            if (!castingData.find(c => c.castingId === r[0])) {
              castingData.push({
                castingId: r[0], accountName: r[1], projectName: r[2], roleName: r[3],
                castId: r[4], castName: r[5], startDate: s, endDate: e, startDay: toEpochDay(s), endDay: toEpochDay(e),
                rank: r[8], status: r[9], note: r[10], slackThreadTs: slackTs, slackPermalink: slackLink,
                mainSub: r[13], calendarEventId: r[14], projectId: r[15], lastUpdated: r[16], updatedBy: r[17],
                castPriority: r[18]
              });
            }
          });

          await createInternalHoldEvents(internalEvents);

          cart = {}; cartMeta = { account: '', notionUrl: '', projectNames: ['', '', ''], combinedProjectNames: [] }; cartStep = 1;
          updateCartCount(); closeCartModal(); closeConfirmationModal(); displayAvailableCasts();
          await renderCastingStatusView(true);
          showMessage('仮キャスティングを登録し、Slackに通知しました。');

          // A-2: 追加オーダーモードをリセット
          if (isAdditionalOrderMode) {
            isAdditionalOrderMode = false;
            additionalOrderContext = null;
          }
        } catch (e) {
          console.error(e);
          showMessage('仮キャスティングの登録またはSlack通知の連携に失敗しました。', 'error');
        } finally {
          showLoader(false);
        }
      }

      async function createInternalHoldEvents(events) {
        if (!events || events.length === 0) return;
        if (!INTERNAL_HOLD_CALENDAR_ID) {
          console.warn('INTERNAL_HOLD_CALENDAR_ID が設定されていないため、仮ホールド作成をスキップします。');
          return;
        }

        const calUpdates = [];

        for (const ev of events) {
          // サマリー（仮ホールド時点）
          const summary = `${ev.accountName || 'アカウント未設定'}_${ev.rank || ''}候補_仮キャスティング`;

          // 説明文（ステータス付き）
          const descriptionLines = [];
          descriptionLines.push('【キャスティング仮ホールド】');
          descriptionLines.push('');
          descriptionLines.push(`・アカウント: ${ev.accountName || '未設定'}`);
          descriptionLines.push(`・作品名: ${ev.projectName || '未設定'}`);
          descriptionLines.push(`・役名: ${ev.roleName || '未設定'}`);
          descriptionLines.push(`・区分: ${ev.mainSub || 'その他'}`);
          descriptionLines.push(`・キャスティングID: ${ev.castingId}`);
          descriptionLines.push(`・ステータス: ${ev.status || '仮キャスティング'}`);
          descriptionLines.push('');
          descriptionLines.push('この予定はキャスティング管理システムから自動作成されています。');
          descriptionLines.push('ステータス変更時にはシステム側で更新される場合があります。');

          // 終日イベント用（end は翌日）
          const startDateStr = ev.start;
          const endDateObj = new Date(ev.end);
          endDateObj.setDate(endDateObj.getDate() + 1);
          const endDateStr = d2str(endDateObj);

          const resource = {
            summary,
            description: descriptionLines.join('\n'),
            start: { date: startDateStr, timeZone: 'Asia/Tokyo' },
            end: { date: endDateStr, timeZone: 'Asia/Tokyo' },
          };

          // 内部キャストメールがあれば出席者として招待
          if (ev.email) {
            resource.attendees = [{ email: ev.email }];
          }

          try {
            const res = await gapi.client.calendar.events.insert({
              calendarId: INTERNAL_HOLD_CALENDAR_ID,
              resource,
            });

            const eventId = res.result.id;
            if (eventId && ev.rowNumber) {
              calUpdates.push({
                range: `キャスティングリスト!O${ev.rowNumber}`, // O列: calendarEventId
                values: [[eventId]],
              });
            }
          } catch (e) {
            console.error('内部キャストの仮ホールド作成に失敗:', e);
            showMessage('内部キャストの仮ホールド登録に失敗しました。', 'error');
          }
        }

        // まとめて N 列に eventId を書き戻し
        if (calUpdates.length) {
          try {
            await gapi.client.sheets.spreadsheets.values.batchUpdate({
              spreadsheetId: SPREADSHEET_ID,
              resource: {
                valueInputOption: 'USER_ENTERED',
                data: calUpdates,
              },
            });
          } catch (e) {
            console.error('calendarEventId の書き込みに失敗:', e);
          }
        }
      }




      // ========= Shooting Contact Page =========

      let currentContactTab = '香盤連絡待ち'; // '香盤連絡待ち' | 'メイキング共有待ち' | '投稿日連絡待ち'

      async function showShootContactPage() {
        const view = document.getElementById("main-view");
        if (!view) return;

        view.innerHTML = `
      <div class="p-4">
        <h2 class="text-2xl font-bold mb-6 text-gray-800">撮影連絡管理</h2>
        
        <div class="flex space-x-1 border-b mb-6 overflow-x-auto">
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === '香盤連絡待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="香盤連絡待ち">
                1. 香盤連絡待ち
            </button>
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === '発注書送信待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="発注書送信待ち">
                2. 発注書送信待ち
            </button>
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === 'メイキング共有待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="メイキング共有待ち">
                3. メイキング共有待ち
            </button>
            <button class="contact-tab px-4 py-2 font-medium text-sm rounded-t-lg border-b-2 transition-colors whitespace-nowrap ${currentContactTab === '投稿日連絡待ち' ? 'border-blue-500 text-blue-600 bg-blue-50' : 'border-transparent text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-tab="投稿日連絡待ち">
                4. 投稿日連絡待ち
            </button>
        </div>

        <div id="shoot-contact-loading" class="text-gray-500 mb-4 hidden">読み込み中...</div>
        <div id="shoot-contact-container" class="overflow-x-auto"></div>
      </div>
    `;
        // Event Listeners
        view.querySelectorAll('.contact-tab').forEach(btn => {
          btn.addEventListener('click', () => {
            currentContactTab = btn.dataset.tab;
            showShootContactPage();
          });
        });

        await loadShootingContactPage();
      }

      async function loadShootingContactPage() {
        const loading = document.getElementById("shoot-contact-loading");
        const container = document.getElementById("shoot-contact-container");
        if (!loading || !container) return;

        try {
          loading.classList.remove('hidden');
          const res = await fetch("/api/shooting_contact/list");
          if (!res.ok) {
            container.innerHTML = `<p class="text-red-500">データ取得に失敗しました (APIエラー)</p>`;
            return;
          }

          const allItems = await res.json();
          window.shootingContactData = allItems; // Store globally

          // Filter by current tab
          const items = allItems.filter(item => item.status === currentContactTab);

          // Header with Sync Button (Dynamic based on tab)
          let syncBtnHtml = "";
          if (currentContactTab === '香盤連絡待ち') {
            syncBtnHtml = `
            <button onclick="syncShootingSchedule(this, 'schedule')" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded flex items-center gap-2 shadow transition">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                香盤DBと同期
            </button>`;
          } else if (currentContactTab === 'メイキング共有待ち') {
            syncBtnHtml = `
            <button onclick="syncShootingSchedule(this, 'making')" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded flex items-center gap-2 shadow transition">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                メイキングDBと同期
            </button>`;
          } else if (currentContactTab === '投稿日連絡待ち') {
            syncBtnHtml = `
            <button onclick="syncShootingSchedule(this, 'post_date')" class="bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-4 rounded flex items-center gap-2 shadow transition">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                投稿日DBと同期
            </button>`;
          }

          let headerHtml = `
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold">撮影連絡管理</h2>
            ${syncBtnHtml}
        </div>
      `;

          if (!items || items.length === 0) {
            container.innerHTML = headerHtml + `<div class="p-8 text-center text-gray-500 bg-gray-50 rounded-lg border border-dashed border-gray-300">
            <p class="text-lg">「${currentContactTab}」の対象はありません</p>
        </div>`;
            return;
          }

          // Grouping: Date -> Account+NotionID
          // We want to display Account Name / Project Name in the header.
          const grouped = {};
          items.forEach(item => {
            let dateKey = item.shootDate || "未定";
            if (currentContactTab === '投稿日連絡待ち') {
              dateKey = item.postDate || "未定";
            }

            const notionId = item.notionId || "NoID";
            const account = item.accountName || "未設定";
            const project = item.projectName || "未設定";

            if (!grouped[dateKey]) grouped[dateKey] = {};

            // Create a unique key for the group
            // If NotionID exists, use it. If not, use Project Name to avoid grouping unrelated "NoID" items.
            // Also include Account Name to prevent cross-account merging.
            const groupKey = `${account}_${notionId !== "NoID" ? notionId : project}`;

            if (!grouped[dateKey][groupKey]) {
              grouped[dateKey][groupKey] = {
                accountName: account,
                projectName: project,
                items: []
              };
            }
            grouped[dateKey][groupKey].items.push(item);
          });

          // Render Accordion
          let html = '<div class="space-y-2">';

          // Sort dates
          const dates = Object.keys(grouped).sort();

          dates.forEach(date => {
            const dateLabel = (currentContactTab === '投稿日連絡待ち') ? `📮 投稿日: ${date}` : `📅 撮影日: ${date}`;
            html += `
            <div class="border rounded-lg bg-white overflow-hidden">
                <button class="w-full px-4 py-3 bg-gray-100 text-left font-bold flex justify-between items-center hover:bg-gray-200 transition" onclick="toggleAccordion(this)">
                    <span>${dateLabel}</span>
                    <span class="text-xs text-gray-500">▼</span>
                </button>
                <div class="hidden border-t">
          `;

            // Sort projects within date (by Account then Project)
            const groupKeys = Object.keys(grouped[date]).sort((a, b) => {
              const groupA = grouped[date][a];
              const groupB = grouped[date][b];
              if (groupA.accountName !== groupB.accountName) {
                return groupA.accountName.localeCompare(groupB.accountName);
              }
              return groupA.projectName.localeCompare(groupB.projectName);
            });

            groupKeys.forEach(key => {
              const group = grouped[date][key];
              const projectItems = group.items;

              html += `
                <div class="border-b last:border-b-0">
                    <button class="w-full px-4 py-2 bg-white text-left font-medium text-sm flex justify-between items-center hover:bg-blue-50 transition pl-8" onclick="toggleAccordion(this)">
                        <span>🏢 ${group.accountName} / 🎬 ${group.projectName} (${projectItems.length}名)</span>
                        <span class="text-xs text-gray-500">▼</span>
                    </button>
                    <div class="hidden border-t p-2 pl-8 bg-gray-50">
                        ${renderProjectTable(projectItems)}
                    </div>
                </div>
              `;
            });

            html += `</div></div>`;
          });

          html += '</div>';
          container.innerHTML = headerHtml + html;

        } catch (err) {
          console.error(err);
          container.innerHTML = `<p class="text-red-500">読み込みエラーが発生しました</p>`;
        } finally {
          loading.classList.add('hidden');
        }
      }

      // Helper for Accordion
      window.toggleAccordion = function (btn) {
        const content = btn.nextElementSibling;
        content.classList.toggle('hidden');
        const icon = btn.querySelector('span:last-child');
        if (icon) icon.textContent = content.classList.contains('hidden') ? '▼' : '▲';
      };

      function renderProjectTable(items) {
        // Dynamic Columns based on Tab
        let extraHeader = "";
        let costHeader = ""; // 金額ヘッダー用

        if (currentContactTab === '香盤連絡待ち') {
          extraHeader = '<th class="px-2 py-2 text-left w-64">時間/場所</th>';
          costHeader = '<th class="px-2 py-2 text-left w-24">金額</th>';
        } else if (currentContactTab === '発注書送信待ち') {
          // ★追加: 発注書送信待ち用のヘッダー（香盤連絡待ちと同様に見せる）
          extraHeader = '<th class="px-2 py-2 text-left w-64">時間/場所</th>';
          costHeader = '<th class="px-2 py-2 text-left w-24">金額</th>';
        } else if (currentContactTab === 'メイキング共有待ち') {
          extraHeader = '<th class="px-2 py-2 text-left w-24">メイキングURL</th>';
        } else if (currentContactTab === '投稿日連絡待ち') {
          extraHeader = '<th class="px-2 py-2 text-left w-24">投稿日</th>';
        }

        let html = `
        <table class="min-w-full bg-white border rounded-lg overflow-hidden table-fixed">
          <thead class="bg-gray-100 text-xs text-gray-500 uppercase">
            <tr>
              <th class="px-2 py-2 text-left w-48">案件名 / 役名</th>
              <th class="px-2 py-2 text-left w-24">キャスト</th>
              <th class="px-2 py-2 text-left w-12">M/S</th>
              <th class="px-2 py-2 text-left w-24">日時/場所</th>
              ${costHeader ? '<th class="px-2 py-2 text-left w-12">金額</th>' : ''}
              ${!costHeader && extraHeader ? extraHeader : ''}
              <th class="px-2 py-2 text-center w-20">アクション</th>
            </tr>
          </thead>
          <tbody class="divide-y divide-gray-200">
      `;

        items.forEach(item => {
          let extraCol = "";
          let costCol = "";
          let actionBtns = "";

          // メール作成ボタン（共通）
          const mailBtn = `
            <button class="px-2 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700 shadow-sm whitespace-nowrap w-full"
                onclick="openShootMailModal('${item.castingId}')">
                ✉️ 作成
            </button>`;

          if (currentContactTab === '香盤連絡待ち') {
            // 時間・場所を編集可能な input に変更
            extraCol = `
            <td class="px-2 py-2 align-top">
              <div class="flex flex-col gap-1">
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">IN</span>
                   <input type="text" class="shoot-in border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.inTime || ''}" placeholder="00:00">
                </div>
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">OUT</span>
                   <input type="text" class="shoot-out border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.outTime || ''}" placeholder="00:00">
                </div>
                <input type="text" class="shoot-location border rounded px-1 py-0.5 text-xs w-full mt-1 bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                       value="${item.location || ''}" placeholder="場所">
              </div>
            </td>`;

            // 金額入力欄 (P列)
            costCol = `
            <td class="px-2 py-2 align-top">
              <input type="text" class="shoot-cost border rounded px-1 py-0.5 text-xs w-full text-right bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                     value="${item.cost || ''}" placeholder="¥">
            </td>`;

            // 保存ボタンを追加
            actionBtns = `
            <div class="flex flex-col gap-2 items-center">
                <button class="px-2 py-1 bg-emerald-600 text-white rounded text-xs hover:bg-emerald-700 shadow-sm whitespace-nowrap w-full"
                    onclick="saveShootingRow('${item.castingId}', this)">
                    💾 保存
                </button>
                ${mailBtn}
            </div>`;

          } else if (currentContactTab === '発注書送信待ち') {
            // ★追加: 発注書送信待ちのロジック
            // 香盤連絡待ちと同様に編集可能にする
            extraCol = `
            <td class="px-2 py-2 align-top">
              <div class="flex flex-col gap-1">
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">IN</span>
                   <input type="text" class="shoot-in border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.inTime || ''}" placeholder="00:00">
                </div>
                <div class="flex items-center gap-1">
                   <span class="text-xs text-gray-400 w-6">OUT</span>
                   <input type="text" class="shoot-out border rounded px-1 py-0.5 text-xs w-full bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                          value="${item.outTime || ''}" placeholder="00:00">
                </div>
                <input type="text" class="shoot-location border rounded px-1 py-0.5 text-xs w-full mt-1 bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                       value="${item.location || ''}" placeholder="場所">
              </div>
            </td>`;

            costCol = `
            <td class="px-2 py-2 align-top">
              <input type="text" class="shoot-cost border rounded px-1 py-0.5 text-xs w-full text-right bg-gray-50 focus:bg-white focus:ring-1 focus:ring-blue-300" 
                     value="${item.cost || ''}" placeholder="¥">
            </td>`;

            // アクションボタン: 保存、発注書作成、メール
            actionBtns = `
            <div class="flex flex-col gap-2 items-center">
                <button class="px-2 py-1 bg-emerald-600 text-white rounded text-xs hover:bg-emerald-700 shadow-sm whitespace-nowrap w-full"
                    onclick="saveShootingRow('${item.castingId}', this)">
                    💾 保存
                </button>
                <button class="px-2 py-1 bg-indigo-600 text-white rounded text-xs hover:bg-indigo-700 shadow-sm whitespace-nowrap w-full"
                    onclick="openOrderDocModal('${item.castingId}')">
                    📄 発注書
                </button>
                ${mailBtn}
            </div>`;

          } else if (currentContactTab === 'メイキング共有待ち') {
            extraCol = `<td class="px-2 py-2 text-xs text-blue-600 truncate max-w-xs"><a href="${item.makingUrl}" target="_blank">${item.makingUrl || '-'}</a></td>`;
            costCol = `<td class="px-2 py-2 text-xs text-right">${item.cost || '-'}</td>`;
            actionBtns = mailBtn;
          } else if (currentContactTab === '投稿日連絡待ち') {
            extraCol = `<td class="px-2 py-2 text-xs">${item.postDate || '-'}</td>`;
            costCol = `<td class="px-2 py-2 text-xs text-right">${item.cost || '-'}</td>`;
            actionBtns = mailBtn;
          }

          html += `
            <tr class="hover:bg-gray-50">
              <td class="px-2 py-2 align-top">
                <div class="text-sm font-bold text-gray-900">${item.projectName}</div>
                <div class="text-xs text-gray-500">${item.roleName}</div>
              </td>
              <td class="px-2 py-2 align-top">
                <div class="text-sm text-gray-900">${item.castName}</div>
              </td>
              <td class="px-2 py-2 align-top">
                <div class="text-xs text-gray-500">${item.mainSub || '-'}</div>
              </td>
              ${extraCol ? extraCol : `<td class="px-2 py-2 align-top text-sm text-gray-500">${item.date}</td>`}
              ${costCol ? costCol : (costHeader ? `<td class="px-2 py-2 align-top text-sm text-gray-500">${item.cost || ''}</td>` : '')}
              ${!costHeader && extraHeader ? `<td class="px-2 py-2 align-top text-sm text-gray-500">${item.makingUrl || item.postDate || ''}</td>` : ''}
              <td class="px-2 py-2 align-top text-center">
                ${actionBtns}
              </td>
            </tr>
          `;
        });

        html += `</tbody></table>`;
        return html;
      }

      // Make functions global
      // 行ごとの保存処理
      window.saveCastingCost = async function (castingId, currentStatus, btn) {
        const row = btn.closest('tr');
        if (!row) return;
        const costInput = row.querySelector('.status-cost-input');
        if (!costInput) return;

        const newCost = costInput.value.trim();
        const originalText = btn.innerText;
        btn.innerText = '...';
        btn.disabled = true;

        try {
          // Reuse changeCastingStatus to update Cost (and Status, which is unchanged)
          await changeCastingStatus(castingId, currentStatus, {
            cost: newCost,
            quick: true // Suppress some UI feedback if needed, or just standard
          });
          // changeCastingStatus already shows message and re-renders if needed
          // But we might want to avoid full re-render if possible?
          // changeCastingStatus calls renderCastingStatusView(false) at the end.
        } catch (e) {
          console.error(e);
          showMessage('保存に失敗しました', 'error');
        } finally {
          btn.innerText = originalText;
          btn.disabled = false;
        }
      };

      window.saveShootingRow = async function (castingId, btn) {
        const row = btn.closest('tr');
        if (!row) return;

        const inTime = row.querySelector('.shoot-in')?.value || '';
        const outTime = row.querySelector('.shoot-out')?.value || '';
        const location = row.querySelector('.shoot-location')?.value || '';
        const cost = row.querySelector('.shoot-cost')?.value || '';

        // ボタンをローディング状態に
        const originalText = btn.innerHTML;
        btn.innerHTML = '...';
        btn.disabled = true;

        try {
          // updateShootingContactFields を呼ぶ (API: /api/shooting_contact/update)
          // 既存の updateShootingContactFields (汎用) を使います

          const res = await fetch("/api/shooting_contact/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              castingId: castingId,
              inTime: inTime,
              outTime: outTime,
              location: location,
              cost: cost  // 新規追加: P列
            })
          });

          if (res.ok) {
            showMessage('情報を更新しました');
            // フロントエンドのデータも更新しておく（再読み込みまでの表示用）
            const item = (window.shootingContactData || []).find(i => i.castingId === castingId);
            if (item) {
              item.inTime = inTime;
              item.outTime = outTime;
              item.location = location;
              item.cost = cost;
            }
          } else {
            throw new Error('Update failed');
          }
        } catch (e) {
          console.error(e);
          showMessage('更新に失敗しました', 'error');
        } finally {
          btn.innerHTML = originalText;
          btn.disabled = false;
        }
      };

      // ========= Cast Detail Modal =========
      function openCastDetailModal(castId) {
        const cast = castData.find(c => c.castId === castId);
        if (!cast) return;

        const modal = document.getElementById('cart-modal'); // Reusing cart-modal container for simplicity or create new one?
        // Using a dedicated modal container is better to avoid conflict.
        // Let's use a new one dynamically or reuse 'new-external-cast-modal' structure?
        // Creating a new one in HTML structure is best, but I can inject it dynamically.

        let detailModal = document.getElementById('cast-detail-modal');
        if (!detailModal) {
          detailModal = document.createElement('div');
          detailModal.id = 'cast-detail-modal';
          detailModal.className = 'hidden fixed inset-0 z-50 flex items-center justify-center modal-backdrop';
          document.body.appendChild(detailModal);
        }

        const inCart = !!cart[cast.castId];
        const stat = getCastStatusForDates(cast.castId, selectedDates);
        const isNG = stat.isNG;
        const isConfirmed = stat.isConfirmed;
        const disabled = isNG || isConfirmed || inCart;
        const btnText = isConfirmed ? 'キャスティング不可' : (isNG ? 'NG' : (inCart ? '追加済み' : '仮キャスティングリストに追加'));
        const btnClass = disabled ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700';

        // SNS Links
        const snsLinks = [];
        if (cast.snsX) {
          snsLinks.push(`<a href="${cast.snsX}" target="_blank" class="text-gray-500 hover:text-black"><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg></a>`);
        }
        if (cast.snsInsta) {
          snsLinks.push(`<a href="${cast.snsInsta}" target="_blank" class="text-gray-500 hover:text-pink-600"><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg></a>`);
        }
        if (cast.snsTiktok) {
          snsLinks.push(`<a href="${cast.snsTiktok}" target="_blank" class="text-gray-500 hover:text-black"><svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12.525.02c1.31-.02 2.61-.01 3.91-.02.08 1.53.63 3.09 1.75 4.17 1.12 1.11 2.7 1.62 4.24 1.79v4.03c-1.44-.05-2.89-.35-4.2-.97-.57-.26-1.1-.59-1.62-.93-.01 2.92.01 5.84-.02 8.75-.08 1.4-.54 2.79-1.35 3.94-1.31 1.92-3.58 3.17-5.91 3.21-1.43.08-2.86-.31-4.08-1.03-2.02-1.19-3.44-3.37-3.65-5.71-.02-.5-.03-1-.01-1.49.18-1.9 1.12-3.72 2.58-4.96 1.66-1.44 3.98-2.13 6.15-1.72.02 1.48-.04 2.96-.04 4.44-.99-.32-2.15-.23-3.02.37-.63.35-1.17 1.09-1.07 1.93.03.58.01 1.16.44 1.57.89.97 2.55.88 3.4-.14.57-.71.79-1.6.78-2.49-.01-4.22.01-8.43.01-12.65-.02-.03-.03-.07-.05-.1z"/></svg></a>`);
        }

        // Helper to format Drive URL
        function formatDriveUrl(url) {
          if (!url) return "";
          if (url.includes("drive.google.com")) {
            let id = "";
            const idMatch = url.match(/id=([^&]+)/);
            const fileMatch = url.match(/\/file\/d\/([^/]+)/);
            if (idMatch) id = idMatch[1];
            else if (fileMatch) id = fileMatch[1];
            if (id) return `https://drive.google.com/thumbnail?id=${id}&sz=w800`;
          }
          return url;
        }
        const displayUrl = formatDriveUrl(cast.imageUrl);

        // Purchase Order Button Condition
        const relevantCasting = castingData.find(c => c.castId === castId && overlaps(selectedDates[0], selectedDates[selectedDates.length - 1], c.startDate, c.endDate));
        const canDownloadOrder = relevantCasting && ['OK', '香盤連絡待ち', '決定'].includes(relevantCasting.status);

        detailModal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] overflow-y-auto relative flex flex-col md:flex-row">
             <button onclick="document.getElementById('cast-detail-modal').remove()" class="absolute top-4 right-4 text-gray-500 hover:text-gray-700 z-10 bg-white/50 rounded-full p-1">
               <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
             
             <!-- Left: Image -->
             <div class="w-full md:w-1/2 bg-gray-100 flex items-center justify-center p-4">
               ${cast.imageUrl ? `<img src="${formatDriveUrl(cast.imageUrl)}" class="max-w-full max-h-[50vh] md:max-h-[70vh] object-contain rounded shadow-sm" referrerpolicy="no-referrer">`
            : `<div class="text-gray-400">No Image</div>`}
             </div>

             <!-- Right: Info -->
             <div class="w-full md:w-1/2 p-4 md:p-8 flex flex-col">
               <h2 class="text-2xl md:text-3xl font-bold mb-2 break-words">${cast.name}</h2>
               <p class="text-lg text-gray-600 mb-4">${cast.agency || 'フリー'}</p>
               
               <div class="flex space-x-4 mb-6">
                 ${snsLinks.join('')}
               </div>


               <div class="space-y-3 text-sm text-gray-700 mb-8">
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">年齢</span>
                   <span>${cast.age ? cast.age + '歳' : '-'}</span>
                 </div>
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">性別</span>
                   <span>${cast.gender || '-'}</span>
                 </div>
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">連絡先</span>
                   <span class="break-all">${cast.email || '-'}</span>
                 </div>
                 <div class="flex border-b pb-2">
                   <span class="w-24 font-bold text-gray-500">備考</span>
                   <span class="whitespace-pre-wrap">${cast.notes || '-'}</span>
                 </div>
               </div>

               <div class="mt-auto">
                 <button onclick="handleAddToCart('${cast.castId}')" 
                   class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow transition ${disabled ? 'opacity-50 cursor-not-allowed' : ''}" ${disabled ? 'disabled' : ''}>
                   ${btnText}
                 </button>
               </div>
             </div>
          </div>
        `;

        detailModal.classList.remove('hidden');

        // Event Listeners
        detailModal.addEventListener('click', (e) => {
          if (e.target === detailModal) detailModal.classList.add('hidden');
        });
      }

      // ========== PDF生成ロジック (Google Docs廃止版) ==========

      // 日本語フォントを読み込むためのヘルパー
      async function loadJapaneseFont(doc) {
        // 今回はhtml2canvas方式のため、この関数は実質未使用ですが、将来のために残します
      }

      // ========== 発注書作成モーダル & PDF生成 ==========

      // 1. モーダルを開く関数
      window.openOrderDocModal = function (castingId) {
        // データ取得
        let targetCasting = null;
        if (window.shootingContactData) {
          targetCasting = window.shootingContactData.find(item => item.castingId === castingId);
        }
        if (!targetCasting) {
          targetCasting = castingData.find(c => c.castingId === castingId);
        }
        if (!targetCasting) {
          showMessage('対象データが見つかりません', 'error');
          return;
        }

        // 初期値セット
        const data = {
          date: new Date().toLocaleDateString(),
          castName: targetCasting.castName || targetCasting.name || '',
          project: targetCasting.projectName || '',
          role: targetCasting.roleName || '',
          shootDate: targetCasting.date || targetCasting.startDate || targetCasting.shootDate || '',
          cost: targetCasting.cost || '',
          note: targetCasting.note || ''
        };

        const modal = document.getElementById('edit-modal'); // 既存の汎用モーダルを流用
        if (!modal) return;

        modal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl max-w-lg w-full p-6">
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-xl font-bold">発注書作成（編集）</h3>
              <button onclick="document.getElementById('edit-modal').classList.add('hidden')" class="text-gray-500 hover:text-gray-700">&times;</button>
            </div>
            
            <div class="space-y-3 text-sm">
              <p class="text-xs text-gray-500">PDFに記載する内容を編集できます。</p>
              
              <div>
                <label class="block font-bold text-gray-700">日付</label>
                <input type="text" id="pdf-date" class="w-full border rounded p-2" value="${data.date}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">宛名（キャスト様）</label>
                <input type="text" id="pdf-castname" class="w-full border rounded p-2" value="${data.castName}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">案件名</label>
                <input type="text" id="pdf-project" class="w-full border rounded p-2" value="${data.project}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">役名</label>
                <input type="text" id="pdf-role" class="w-full border rounded p-2" value="${data.role}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">撮影日</label>
                <input type="text" id="pdf-shootdate" class="w-full border rounded p-2" value="${data.shootDate}">
              </div>
              <div>
                <label class="block font-bold text-gray-700">金額</label>
                <input type="text" id="pdf-cost" class="w-full border rounded p-2" value="${data.cost}" placeholder="数値のみ入力すると自動フォーマットされます">
              </div>
              <div>
                <label class="block font-bold text-gray-700">備考</label>
                <textarea id="pdf-note" class="w-full border rounded p-2" rows="3">${data.note}</textarea>
              </div>
            </div>

            <div class="mt-6 flex justify-end gap-3">
              <button onclick="document.getElementById('edit-modal').classList.add('hidden')" class="px-4 py-2 border rounded hover:bg-gray-50">キャンセル</button>
              <button id="btn-generate-pdf" class="px-6 py-2 bg-indigo-600 text-white font-bold rounded hover:bg-indigo-700">
                PDFを作成
              </button>
            </div>
          </div>
        `;

        modal.classList.remove('hidden');

        // 生成ボタンイベント
        document.getElementById('btn-generate-pdf').addEventListener('click', async () => {
          // UUID生成 (既存があればそれを使う、なければ新規生成)
          const uuid = targetCasting.poUuid || crypto.randomUUID();

          // Save UUID to Backend
          try {
            await fetch('/api/shooting_contact/update', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                castingId: castingId,
                poUuid: uuid
              })
            });
            // Update local data
            targetCasting.poUuid = uuid;
          } catch (e) {
            console.error("Failed to save PO UUID", e);
            // Continue anyway? Or stop? User said "save to sheet".
            // We should probably alert but continue or stop.
            // For now, log and continue.
          }

          const finalData = {
            date: document.getElementById('pdf-date').value,
            castName: document.getElementById('pdf-castname').value,
            project: document.getElementById('pdf-project').value,
            role: document.getElementById('pdf-role').value,
            shootDate: document.getElementById('pdf-shootdate').value,
            cost: document.getElementById('pdf-cost').value,
            note: document.getElementById('pdf-note').value,
            uuid: uuid
          };
          generatePDFFromData(finalData);
          modal.classList.add('hidden');
        });
      };



      // 季節の挨拶を取得する関数
      function getSeasonalGreeting() {
        const month = new Date().getMonth() + 1;
        const greetings = {
          1: "初春", 2: "晩冬", 3: "早春", 4: "陽春", 5: "新緑", 6: "初夏",
          7: "盛夏", 8: "晩夏", 9: "初秋", 10: "秋冷", 11: "晩秋", 12: "初冬"
        };
        return greetings[month] || "時下";
      }

      // 2. 実際のPDF生成処理（データを引数で受け取るように変更）
      window.generatePDFFromData = async function (data) {
        // 金額フォーマット
        let costStr = data.cost;
        const numCost = Number(data.cost.replace(/[^0-9]/g, ''));
        if (numCost > 0 && !data.cost.includes('¥')) {
          costStr = `¥${numCost.toLocaleString()}`;
        }

        const tempDiv = document.createElement('div');
        tempDiv.style.width = '210mm';
        tempDiv.style.minHeight = '297mm';
        tempDiv.style.padding = '20mm';
        tempDiv.style.backgroundColor = 'white';
        tempDiv.style.color = 'black';
        tempDiv.style.fontFamily = '"Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif';
        tempDiv.style.position = 'fixed';
        tempDiv.style.top = '-9999px';
        tempDiv.style.left = '-9999px';
        tempDiv.style.zIndex = '-100';
        // ★修正: 線が入る問題を防ぐ
        tempDiv.style.textDecoration = 'none';

        const greeting = getSeasonalGreeting();

        tempDiv.innerHTML = `
          <div style="text-decoration: none !important; font-size: 14px; line-height: 1.6;">
            <h1 style="text-align: center; font-size: 20px; font-weight: bold; margin-bottom: 30px;">GOKKO倶楽部出演発注書</h1>
            
            <div style="text-align: right; margin-bottom: 5px;">${data.date}</div>
            <div style="text-align: right; margin-bottom: 20px; font-size: 10px; color: #666;">No. ${data.uuid || ''}</div>
            
            <div style="font-size: 14px; margin-bottom: 20px;">
              <span style="font-size: 14px;">${data.castName} 様</span>
            </div>

            <p style="margin-bottom: 5px;">ご快諾いただきましたドラマ出演の件につきまして、下記の通り発注申し上げます。<br>
            内容をご確認いただき、ご不明な点がございましたら担当までご連絡ください。</p>

            <div style="margin-bottom: 20px; padding: 10px; width: 100%;">
              <p style="font-weight: bold; margin-bottom: 5px;">【発注元】</p>
              <p style="margin: 0;">〒135-0091</p>
              <p style="margin: 0;">東京都港区台場2-3-1トレードピアお台場12F</p>
              <p style="margin: 0;">株式会社GOKKO</p>
              <p style="margin: 0;">担当：GOKKO倶楽部キャスティング担当</p>
            </div>

            <div style="margin-bottom: 20px;">
              <p style="font-weight: bold; display: inline-block; margin-bottom: 10px;">【お取引条件】</p>
              <p style="margin: 2px 0;">支払条件： 月末締め翌月末払い</p>
              <p style="margin: 2px 0;">支払方法： ご指定の銀行口座へお振込み</p>
              <p style="margin: 2px 0;">秘密保持： 本件に関わる脚本内容、撮影情報、共演者情報等は、公式解禁まで第三者への漏洩（SNS含む）を禁止とさせていただきます。</p>
              <p style="text-align: right; margin: 0;">以上</p>
            </div>

            <div style="text-align: center; margin-bottom: 20px; font-weight: bold;">記</div>

            <table style="width: 100%; border-collapse: collapse; margin-bottom: 20px;">
              <tr style="border: 1px solid #000;">
                <th style="border: 1px solid #000; padding: 8px; background-color: #f0f0f0; width: 30%; text-align: center;">項目</th>
                <th style="border: 1px solid #000; padding: 8px; background-color: #f0f0f0; text-align: center;">内容</th>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">案件名</td>
                <td style="border: 1px solid #000; padding: 8px;">${data.project}</td>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">役名</td>
                <td style="border: 1px solid #000; padding: 8px;">${data.role}</td>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">撮影日</td>
                <td style="border: 1px solid #000; padding: 8px;">${data.shootDate}</td>
              </tr>
              <tr style="border: 1px solid #000;">
                <td style="border: 1px solid #000; padding: 8px; text-align: center;">出演料（金額）</td>
                <td style="border: 1px solid #000; padding: 8px;">${costStr} （税別）</td>
              </tr>
            </table>

          </div>
        `;

        document.body.appendChild(tempDiv);
        showLoader(true);

        try {
          // html2canvas / jsPDF のロード確認
          if (typeof html2canvas === 'undefined') await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
          if (typeof window.jspdf === 'undefined') await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');

          const canvas = await html2canvas(tempDiv, { scale: 2 });
          const imgData = canvas.toDataURL('image/png');

          const { jsPDF } = window.jspdf;
          const pdf = new jsPDF('p', 'mm', 'a4');
          const pdfWidth = pdf.internal.pageSize.getWidth();
          const pdfHeight = (canvas.height * pdfWidth) / canvas.width;

          pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);

          const fileName = `${data.shootDate.replace(/[\/-]/g, '')}_${data.project}_${data.castName}_発注書.pdf`;
          pdf.save(fileName);

          showMessage('発注書PDFをダウンロードしました', 'success');
        } catch (e) {
          console.error(e);
          showMessage('PDF作成に失敗しました: ' + e.message, 'error');
        } finally {
          document.body.removeChild(tempDiv);
          showLoader(false);
        }
      };

      // 旧関数を削除または上書き
      window.createOrderDoc = window.openOrderDocModal;

      // スクリプト読み込みヘルパー
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src;
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }

      window.openShootMailModal = openShootMailModal;
      window.openShootStatusModal = openShootStatusModal;

      {% raw %}
      function openShootMailModal(castingId) {
        // Try to find in shootingContactData first, then castingData
        let item = (window.shootingContactData || []).find(i => i.castingId === castingId);
        let isCastingItem = false;

        if (!item) {
          item = castingData.find(c => c.castingId === castingId);
          isCastingItem = true;
        }

        if (!item) { showMessage("データが見つかりません", "error"); return; }
        console.log(`OpenShootMailModal: ID=${castingId}, Status=${item.status}, Name=${item.castName}`);

        const modal = document.getElementById('shoot-mail-modal');
        if (!modal) return;

        // Store current item ID and status for auto-update
        modal.dataset.castingId = castingId;
        modal.dataset.currentStatus = item.status;
        modal.dataset.isCastingItem = isCastingItem;

        // Template builder functions
        const templates = {};

        // 0. 打診メール (Order Mail)
        templates['打診メール'] = {
          subject: `【ご相談】${item.projectName} / ${item.roleName}役`,
          body: `お世話になっております、直前のご依頼申し訳ございません。
以下作品にて、ご出演いただきたく
{{撮影日}}(曜日)のスケジュールについてお伺いできますでしょうか。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
【撮影概要】
撮影日　：{{撮影日}}(曜日)
作品名：「{{作品名}}」
役柄　：{{役名}}役

クライアント：なし
競合：なし

投稿先：ごっこ倶楽部tik tokアカウント
https://www.tiktok.com/@gokko5club
投稿先：daikaiアカウント
https://www.tiktok.com/@daikai_55
投稿先：ウミガメごっこアカウント
https://www.tiktok.com/@gokko5club.umigame
投稿先：docomo
https://www.tiktok.com/@docomo.official

※その他ごっこ倶楽部運営の各種SNSなどでも投稿予定。
https://www.youtube.com/@gokko5club/
https://x.com/gokko5club
https://www.instagram.com/gokko5club/

※docomoさまの各種SNSなどで投稿予定
https://www.youtube.com/user/docomoOfficial
その他ごっこ倶楽部運営の各種SNSなどでも投稿予定。
https://www.youtube.com/@gokko5club/
https://x.com/gokko5club
https://www.instagram.com/gokko5club/

投稿アカウント：まいはにTikTokアカウント、および各種SNS予定
https://www.tiktok.com/@maihani.4
https://www.youtube.com/channel/UCTStisbrmEM6oIX9Yaq9-NA
https://www.instagram.com/maihani.4/

※作品認知向上のため、
プレスリリースや各種SNSでの告知発信の可能性もございます。

使用期間：無期限

二次使用：予定あり
・ドラマ素材を活用した各種SNSでの広告配信
X、Instagram、YouTube
・今回の施策用のキャンペーンページ(Webサイト)
二次使用期間は3ヶ月

ご出演料：￥{{金額}}〜/day
※出演時間確定次第となりますが上記を想定しております
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
大変恐れ入りますが、
取り急ぎスケジュールの有無についてご確認いただけますと幸いです。

何卒よろしくお願い申し上げます。`
            .replace(/{{撮影日}}/g, item.date || item.startDate || 'MM/DD')
            .replace(/{{作品名}}/g, item.projectName || '')
            .replace(/{{役名}}/g, item.roleName || '')
            .replace(/{{金額}}/g, item.cost ? Number(item.cost).toLocaleString() : '18,000')
        };

        // 1. 香盤連絡
        templates['香盤連絡'] = {
          subject: `【香盤連絡】${item.projectName}`,
          body: `お世話になっております。お待たせして大変申し訳ございません。
{{撮影日}}の香盤が確定しましたのでお伝えいたします。
また今回のご出演料は¥{{金額}}でお願いいたします。
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
【{{撮影日}}　撮影概要】

▼{{キャスト名}} さま
{{撮影日}}　{{時間}}
作品名：「{{作品名1}}」　{{配役1}}役
　　　　「{{作品名2}}」　{{配役2}}役
　　　　「{{作品名3}}」　{{配役3}}役

集合場所：{{集合場所}}
{{住所}}
{{マップ}}

ご持参いただきたい衣装：
{{衣装内容}}

詳細については以下をご確認くださいませ。
{{notion}}

当日の緊急連絡先
{{連絡先}}
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
何卒よろしくお願いいたします。`
            .replace(/{{撮影日}}/g, item.date || item.startDate || 'MM/DD')
            .replace(/{{キャスト名}}/g, item.castName)
            .replace(/{{時間}}/g, (item.inTime && item.outTime) ? `${item.inTime}〜${item.outTime}` : '時間未定')
            .replace(/{{金額}}/g, item.cost ? Number(item.cost).toLocaleString() : '金額')
            .replace(/{{作品名1}}/g, item.projectName || '')
            .replace(/{{配役1}}/g, item.roleName || '')
            .replace(/{{作品名[23]}}/g, '（作品名）')
            .replace(/{{配役[23]}}/g, '（役名）')
            .replace(/{{集合場所}}/g, item.location || '（集合場所）')
            .replace(/{{住所}}/g, '（住所）')
            .replace(/{{マップ}}/g, '（マップURL）')
            .replace(/{{衣装内容}}/g, '（衣装詳細）')
            .replace(/{{notion}}/g, item.notionId ? `https://www.notion.so/${item.notionId.replace(/-/g, '')}` : '(Notion URL)')
            .replace(/{{連絡先}}/g, '090-xxxx-xxxx (担当者)')
        };

        // 2. 発注書 (PDFありをデフォルト)
        templates['発注書'] = {
          subject: `【発注書送付】${item.projectName}`,
          body: `この度は作品へのご参加ありがとうございます。
添付PDFにて発注内容をお伝えいたしますので、ご確認いただきご請求ください。
恐れ入りますが、翌月の3営業日以内迄に、ご請求書をお送りくださいませ。
なお、ご出演料のご請求書発行方法について以下ページにおまとめしております。
※同月中のご出演分であれば、他作品出演分の請求書とまとめての送付でも問題ございません。
請求書送付先：cast-invoice@gokkoclub.jp
【締め支払い日及び請求書発行について】
https://brass-soursop-b4a.notion.site/4f37617875b8400d93a444956ab54fa6
引き続き、何卒よろしくお願いいたします。`
        };

        // 3. オフショット (案件/非案件)
        templates['オフショット_案件'] = {
          subject: `【オフショット共有】${item.projectName}`,
          body: `案件撮影
お世話になっております。
先日{{キャスト名}}さまにご参加いただいた撮影の写真の共有でございます。
NGチェックの意味も含め、Googleドライブにて共有させていただきます。
・作品名『{{作品名1}}』　※{{撮影日}}撮影
{{GドライブURL}}
※編集権限を付与しておりますので、NGはご自由に削除いただけます。
※こちらの写真は2025//()●:00までにNG対応お願いいたします。
※作品投稿後にご活用いただけます。
よろしくお願いいたします。`
            .replace(/{{キャスト名}}/g, item.castName)
            .replace(/{{作品名1}}/g, item.projectName || '')
            .replace(/{{撮影日}}/g, item.date || item.startDate || 'MM/DD')
            .replace(/{{GドライブURL}}/g, '(Goole Drive URL)')
        };
        templates['オフショット_非案件'] = {
          subject: `【オフショット共有】${item.projectName}`,
          body: `お世話になっております。
先日{{キャスト名}}さまにご参加いただいた撮影の写真の共有でございます。
NGチェックの意味も含め、Googleドライブにて共有させていただきます。

・作品名『{{作品名1}}』　※{{撮影日}}撮影
{{GドライブURL}}
※編集権限を付与しておりますので、NGはご自由に削除いただけます。
※こちらの写真は2025//()●:00以降自由にご利用ください。
（全体共有いたしますので、それまでにNG対応お願いいたします。）

よろしくお願いいたします。`
            .replace(/{{キャスト名}}/g, item.castName)
            .replace(/{{作品名1}}/g, item.projectName || '')
            .replace(/{{撮影日}}/g, item.date || item.startDate || 'MM/DD')
            .replace(/{{GドライブURL}}/g, '(Goole Drive URL)')
        };

        // 4. 投稿日連絡
        templates['投稿日連絡'] = {
          subject: `【投稿日連絡】${item.projectName}`,
          body: `お世話になっております。
先日{{キャスト名}} さまにご参加いただいた作品の投稿スケジュールの共有でございます。

作品名　：『{{作品名1}}』
投稿日　：2025//()
アカウント：{{アカウント}}

【TikTok閲覧・シェア時の注意点】
作品出演の告知をいただく際、
TikTokのリンク共有はアルゴリズムでマイナスに働いてしまいます。
告知いただく際は、以下いずれかでご対応くださいませ。
① 投稿当日に告知を行う場合
・URLは記載せず、画像とテキストのみで投稿をお願いします。
・文言例：「ドラマ『●●●●』が、ごっこ倶楽部のTikTokアカウントで投稿されたので、ぜひご覧ください！」

② 投稿翌日以降に告知を行う場合
・URLは記載せず、画像とテキストのみで投稿をお願いします。
・「動画リンク」ではなく、「アカウントのリンク」を記載する形でご投稿ください。

詳細については、以下リンク先をご確認ください。
※一部関係者のみ閲覧可能な限定公開資料となっております。SNSや社外への転載・拡散はご遠慮ください
https://brass-soursop-b4a.notion.site/TikTok-fafa93aeaeaf4bbe947a6713db61757f

よろしくお願いいたします。`
            .replace(/{{キャスト名}}/g, item.castName)
            .replace(/{{作品名1}}/g, item.projectName || '')
            .replace(/{{アカウント}}/g, item.account || '（アカウント名）')
        };
        templates['デフォルト'] = {
          subject: `【連絡】${item.projectName}`,
          body: `${item.castName} 様\n\nお世話になっております。\n株式会社GOKKOです。\n\n（本文）\n\nよろしくお願いいたします。`
        };


        // Available options
        const allOptions = ['打診メール', '香盤連絡', '発注書', 'オフショット_案件', 'オフショット_非案件', '投稿日連絡'];
        let initialKey = 'デフォルト';

        // default selection logic
        if (item.status === "香盤連絡待ち" || item.status === "決定" || item.status === "OK") {
          initialKey = '香盤連絡';
        } else if (item.status === "発注書送信待ち") {
          initialKey = '発注書';
        } else if (item.status === "メイキング共有待ち") {
          initialKey = 'オフショット_案件';
        } else if (item.status === "投稿日連絡待ち") {
          initialKey = '投稿日連絡';
        } else if (item.status === "オーダー待ち" || item.status === "打診中" || item.status === "仮キャスティング" || item.status === "条件つきOK") {
          initialKey = '打診メール';
        }

        const originalRec = castingData.find(c => c.castingId === castingId);
        const castInfo = castData.find(c => c.castId === (originalRec?.castId || item.castId));
        const castEmail = originalRec?.email || item.email || castInfo?.email || "";

        modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-xl w-full max-w-lg mx-4 p-6 relative">
            <h3 class="text-xl font-bold mb-4">メール作成 (ステータス: ${item.status})</h3>
            <button class="absolute top-4 right-4 text-gray-500 hover:text-gray-700 text-2xl z-10" onclick="document.getElementById('shoot-mail-modal').classList.add('hidden')">&times;</button>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">送信先 (To)</label>
                    <div class="flex gap-2">
                        <input type="text" id="mail-to-input" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 bg-gray-50" value="${castEmail}" readonly>
                        <button class="mt-1 px-3 py-2 bg-gray-200 rounded hover:bg-gray-300 text-sm" onclick="navigator.clipboard.writeText(document.getElementById('mail-to-input').value); showMessage('メールアドレスをコピーしました')">コピー</button>
                    </div>
                </div>
                <div>
                   <label class="block text-sm font-medium text-gray-700">テンプレート切替</label>
                   <select id="mail-template-select" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 bg-white">
                      ${allOptions.map(opt => `<option value="${opt}" ${opt === initialKey ? 'selected' : ''}>${opt}</option>`).join('')}
                      <option value="デフォルト" ${initialKey === 'デフォルト' ? 'selected' : ''}>デフォルト (空)</option>
                   </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">件名</label>
                    <input type="text" id="mail-subject" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2" value="${templates[initialKey]?.subject || ''}">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">本文</label>
                    <textarea id="mail-body" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 h-96 font-mono whitespace-pre-wrap">${templates[initialKey]?.body || ''}</textarea>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50" onclick="document.getElementById('shoot-mail-modal').classList.add('hidden')">キャンセル</button>
                <button class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700" onclick="copyToClipboardAndClose()">コピーして閉じる（ステータス更新）</button>
            </div>
        </div>
      `;
        modal.classList.remove('hidden');

        // Add Listener for Select Change
        const select = document.getElementById('mail-template-select');
        select.addEventListener('change', (e) => {
          const val = e.target.value;
          const tmpl = templates[val];
          if (tmpl) {
            document.getElementById('mail-subject').value = tmpl.subject;
            document.getElementById('mail-body').value = tmpl.body;
          }
        });
      };

      window.copyToClipboardAndClose = async function () {
        const modal = document.getElementById('shoot-mail-modal');
        const textarea = modal.querySelector('textarea');

        if (textarea) {
          textarea.select();
          document.execCommand('copy');
          showMessage("本文をクリップボードにコピーしました");
        }

        // Auto Update Status
        const castingId = modal.dataset.castingId;
        const currentStatus = modal.dataset.currentStatus;
        const isCastingItem = modal.dataset.isCastingItem === "true";

        if (castingId && currentStatus) {
          let nextStatus = "";

          if (isCastingItem && ORDER_WAIT_STATUSES.includes(currentStatus)) {
            nextStatus = "打診中";
          } else if (currentStatus === "香盤連絡待ち") {
            nextStatus = "発注書送信待ち";
          } else if (currentStatus === "発注書送信待ち") {
            nextStatus = "メイキング共有待ち";
          } else if (currentStatus === "メイキング共有待ち") {
            nextStatus = "投稿日連絡待ち";
          } else if (currentStatus === "投稿日連絡待ち") {
            nextStatus = "完了";
          }

          if (nextStatus) {
            if (isCastingItem) {
              // Call Casting Status Update API
              await changeCastingStatus(castingId, nextStatus, "メール作成による自動更新");
            } else {
              // Call Shooting Contact Update API
              await updateShootingContactStatus(castingId, nextStatus);
            }
          }
        }

        modal.classList.add('hidden');
      };
      {% endraw %}

      function openShootStatusModal(castingId, currentStatus) {
        // Legacy manual update if needed, but "Copy" is now the primary driver.
        // Keeping this for manual override.
        let nextStatus = "";
        if (currentStatus === "香盤連絡待ち") nextStatus = "メイキング共有待ち";
        else if (currentStatus === "メイキング共有待ち") nextStatus = "投稿日連絡待ち";
        else if (currentStatus === "投稿日連絡待ち") nextStatus = "完了";

        if (!nextStatus) return;

        if (confirm(`ステータスを「${nextStatus}」に進めますか？`)) {
          updateShootingContactStatus(castingId, nextStatus);
        }
      }

      async function updateShootingContactStatus(castingId, newStatus) {
        try {
          const res = await fetch("/api/shooting_contact/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ castingId, status: newStatus })
          });
          if (res.ok) {
            showMessage(`ステータスを「${newStatus}」に更新しました`);
            loadShootingContactPage(); // Reload to reflect changes
          } else {
            showMessage("更新に失敗しました", "error");
          }
        } catch (e) {
          console.error(e);
          showMessage("エラーが発生しました", "error");
        }
      }

      // Generic Update Function for Shooting Contact Fields
      window.updateShootingContactFields = async function (id, fields) {
        try {
          const payload = {
            castingId: id, // API expects 'castingId', not just 'id' depending on backend, but let's match saveShootingRow
            ...fields
          };

          // ★修正: 正しいAPIエンドポイント (/update) を使用する
          const res = await fetch("/api/shooting_contact/update", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
          });

          if (!res.ok) {
            throw new Error("Update failed");
          }
          // Success (optional toast)
        } catch (e) {
          console.error(e);
          showMessage("更新に失敗しました", "error");
        }
      };


      // Sync Function (GAS Trigger)
      window.syncShootingSchedule = async function (btn, syncType = 'schedule') {
        let label = "香盤DB";
        if (syncType === 'making') label = "メイキングDB";
        if (syncType === 'post_date') label = "投稿日DB";

        if (!confirm(`${label}から最新情報を取得して同期しますか？\n(GASスクリプトを実行します)`)) return;

        const originalContent = btn ? btn.innerHTML : `${label}と同期`;
        if (btn) {
          btn.disabled = true;
          btn.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> 同期中...`;
        }

        const loading = document.getElementById("shoot-contact-loading");
        if (loading) loading.classList.remove('hidden');

        try {
          const res = await fetch(`/api/sync/gas?type=${syncType}`, { method: "POST" });
          if (res.ok) {
            const data = await res.json();
            const updatedCount = data.gas_response?.updatedRows ?? 0;
            showMessage(`同期が完了しました（更新: ${updatedCount}件）`, "success");

            await loadShootingContactPage();
          } else {
            const err = await res.json();
            showMessage(`同期に失敗しました: ${err.detail || 'Unknown error'}`, "error");
          }
        } catch (e) {
          console.error(e);
          showMessage("同期リクエスト中にエラーが発生しました", "error");
        } finally {
          if (loading) loading.classList.add('hidden');
          if (btn) {
            btn.disabled = false;
            btn.innerHTML = originalContent;
          }
        }
      };



      // ========= New Cart UI (Drag & Drop) =========
      let cartProjects = []; // Array of { id, title, roles: [{ id, name, type, note, castIds: [] }] }

      function renderCartModal() {
        const modal = document.getElementById('cart-modal');
        if (!modal) return;

        // Initialize cartProjects if empty (first open)
        initCartProjects();

        renderNewCartModal(modal);
      }
      window.submitNewOrder = async function () {
        // 1. Auth Check
        const isAuth = await ensureAuth();
        if (!isAuth) {
          // サイレント更新に失敗した場合は、明示的にログインボタンを押してもらう
          alert("セッションの有効期限が切れました。\nログイン画面を表示しますので、再ログインしてください。");
          handleAuthClick(); // ユーザーのアクション（ボタンクリック）の流れで呼べばポップアップはブロックされません
          return;
        }

        // ■■■ 追加: 画面更新前にファイルを退避 ■■■
        const fileInput = document.getElementById('order-pdf-file');
        if (fileInput && fileInput.files.length > 0) {
          cartMeta.pdfFiles = fileInput.files;
          console.log("Files saved to memory:", cartMeta.pdfFiles.length);
        }
        // ■■■ 追加ここまで ■■■

        // Cleanup: 役名などが空の無効なデータを掃除
        cartProjects = cartProjects.map(p => {
          const validRoles = p.roles.filter(r => r.name.trim() && r.castIds.length > 0);
          return { ...p, roles: validRoles };
        }).filter(p => p.roles.length > 0);

        // カート画面を再描画（掃除後の状態にするため）
        renderCartModal();

        if (cartProjects.length === 0) {
          showMessage('有効なオーダー（役名とキャストが入力されたもの）がありません。', 'error');
          return;
        }

        // Validate
        for (const p of cartProjects) {
          if (!p.title.trim()) {
            showMessage('作品名が入力されていないものがあります。', 'error');
            return;
          }
        }

        // ★ここで確認モーダルを開く
        renderConfirmationModal();
      }

      function renderConfirmationModal() {
        const modal = document.getElementById('confirmation-modal');
        if (!modal) return;

        // 【修正】データソースの優先順位を変更
        // 新しいDrag&Dropカート(cartProjects)がある場合はそこからタイトルを取得
        let mainProjectName = '';
        if (cartProjects && cartProjects.length > 0) {
          mainProjectName = cartProjects[0].title;
        } else if (cartMeta && cartMeta.projectNames && cartMeta.projectNames[0]) {
          // 古いフローのバックアップ
          mainProjectName = cartMeta.projectNames[0];
        }

        const booked = currentUser?.email || '';

        // バリデーション修正
        if (!mainProjectName) {
          showMessage('作品名が入力されていません。', 'error');
          return;
        }
        if (!booked) {
          // ensureAuthでチェック済みのはずだが念の為
          showMessage('ログイン情報が取得できませんでした。もう一度サインインしてください。', 'error');
          return;
        }

        modal.innerHTML = `
      <div class="bg-white rounded-lg shadow-xl w-full max-w-lg mx-4 p-6 relative">
        <h3 class="text-xl font-bold mb-4">最終確認</h3>
        <button class="absolute top-4 right-4 text-gray-500 hover:text-gray-700" onclick="closeConfirmationModal()">&times;</button>
        <p class="text-sm text-gray-600 mb-4">作品名：<span class="font-bold text-black">${mainProjectName}</span> 他</p>
        
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700">インティマシーシーンの有無</label>
            <div class="mt-2 flex space-x-4">
              <label class="inline-flex items-center">
                <input type="radio" name="intimacy" value="あり" class="form-radio">
                <span class="ml-2 font-bold text-red-600">あり</span>
              </label>
              <label class="inline-flex items-center">
                <input type="radio" name="intimacy" value="なし" class="form-radio" checked>
                <span class="ml-2">なし</span>
              </label>
              <label class="inline-flex items-center">
                <input type="radio" name="intimacy" value="未定" class="form-radio">
                <span class="ml-2">未定</span>
              </label>
            </div>
            <p class="text-xs text-gray-500 mt-1">※「あり」を選択すると、備考欄に自動追記されます。</p>
          </div>
          <div class="bg-yellow-50 p-3 rounded border border-yellow-200">
            <label class="flex items-start cursor-pointer">
              <input id="child-actor-check" type="checkbox"
                     class="mt-1 h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
              <span class="ml-3 text-sm text-gray-700 leading-snug">
                <strong>未成年者（18歳未満）</strong>が含まれる場合、<br>
                労働基準法（深夜労働の禁止・労働時間制限など）および関連法規を遵守した撮影計画であることを確認しました。
              </span>
            </label>
          </div>
        </div>
        <div class="mt-6 flex justify-end gap-3">
          <button id="confirm-cancel" class="px-4 py-2 rounded-md border border-gray-300 hover:bg-gray-50">キャンセル</button>
          <button id="confirm-final" class="px-6 py-2 rounded-md bg-blue-600 text-white font-bold shadow hover:bg-blue-700">
            同意して送信
          </button>
        </div>
      </div>
    `;
        modal.classList.remove('hidden');

        // イベント設定
        modal.querySelector('#confirm-cancel').addEventListener('click', closeConfirmationModal);

        // 送信ボタンクリック時
        modal.querySelector('#confirm-final').addEventListener('click', async () => {
          const intimacyValue = modal.querySelector('input[name="intimacy"]:checked').value;
          const childActorConfirmed = modal.querySelector('#child-actor-check').checked;

          // 子役が含まれているか簡易チェック (cart内の全キャストを対象)
          const hasChildActor = Object.values(cart).some(item =>
            item.cast && item.cast.age !== null && item.cast.age < 18
          );

          if (hasChildActor && !childActorConfirmed) {
            showMessage(
              '未成年キャストが含まれています。法令遵守の確認にチェックを入れてください。',
              'error'
            );
            return;
          }

          // ★ここで実際の送信処理 (processNewOrderFromModal) を呼ぶ
          await processNewOrderFromModal({
            intimacy: intimacyValue === 'あり',
            childConfirmed: childActorConfirmed
          });
        });
      }

      function closeConfirmationModal() {
        const modal = document.getElementById('confirmation-modal');
        if (modal) modal.classList.add('hidden');
      }

      // Progress Bar Functions
      function showProgressBar(message = "処理中...", percent = 0) {
        const modal = document.getElementById('progress-modal');
        if (modal) {
          modal.classList.remove('hidden');
          updateProgressBar(message, percent);
        }
      }

      function updateProgressBar(message, percent) {
        const titleEl = document.getElementById('progress-title');
        const msgEl = document.getElementById('progress-message');
        const barEl = document.getElementById('progress-bar-fill');
        const percentEl = document.getElementById('progress-percent');

        if (titleEl) titleEl.textContent = "処理中..."; // Or dynamic title
        if (msgEl) msgEl.textContent = message;
        if (barEl) barEl.style.width = `${percent}%`;
        if (percentEl) percentEl.textContent = `${percent}%`;
      }

      function hideProgressBar() {
        const modal = document.getElementById('progress-modal');
        if (modal) modal.classList.add('hidden');
      }

      // モーダルから呼ばれるラッパー関数
      async function processNewOrderFromModal(options) {
        // ★修正: selectedShooting がない場合は additionalOrderContext を参照
        let teamName = (currentUser?.name || '不明');
        let pageId = '';

        if (selectedShooting) {
          teamName = selectedShooting.team;
          pageId = selectedShooting.pageId;
        } else if (isAdditionalOrderMode && additionalOrderContext) {
          teamName = additionalOrderContext.accountName;
          pageId = additionalOrderContext.projectId; // Notion Page ID
        }

        const notionUrl = pageId ? `https://www.notion.so/${pageId.replace(/-/g, '')}` : '';

        // CC設定
        let ccString = "";
        if (selectedShooting && window.internalCastMap) {
          const names = [];
          if (selectedShooting.cd) names.push(...selectedShooting.cd.split(/[,、]/).map(s => s.trim()));
          if (selectedShooting.fd) names.push(...selectedShooting.fd.split(/[,、]/).map(s => s.trim()));
          const ccIds = new Set();
          names.forEach(name => {
            if (window.internalCastMap.has(name)) ccIds.add(window.internalCastMap.get(name));
          });
          if (ccIds.size > 0) ccString = Array.from(ccIds).map(uid => `<@${uid}>`).join(' ');
        }

        // showLoader(true); // Disable global loader in favor of progress bar
        showProgressBar("処理を開始します...", 10);

        try {
          await processNewOrder({
            accountName: teamName,
            pageId: pageId,
            notionUrl: notionUrl,
            projects: cartProjects,
            ccString: ccString,
            slackThreadTs: isAdditionalOrderMode && additionalOrderContext ? additionalOrderContext.slackThreadTs : null,
            // ★追加オプション
            intimacy: options.intimacy
          });

          updateProgressBar("完了しました", 100);
          await new Promise(r => setTimeout(r, 500)); // Show 100% briefly

          closeCartModal();
          closeConfirmationModal(); // モーダルも閉じる

          // Reset
          cart = {};
          cartProjects = [];
          updateCartCount();
          displayAvailableCasts();

          showMessage('オーダーを送信しました。', 'success');

          // ステータス反映のため少し待って再読み込み
          setTimeout(() => loadAllData(), 2000);

        } catch (e) {
          console.error(e);
          if (e.status === 401 || e.result?.error?.code === 401) {
            // ensureAuthでカバーしているはずだが念の為
            showMessage('認証エラーが発生しました。リロードして再ログインしてください。', 'error');
          } else {
            showMessage('オーダー送信に失敗しました: ' + (e.message || 'Unknown error'), 'error');
          }
        } finally {
          // showLoader(false);
          hideProgressBar();
        }
      }

      // 実際のデータ構築とAPI送信を行う関数
      async function processNewOrder(data) {
        const shootDate = selectedShooting ? selectedShooting.date : (selectedDates[0] || '');
        const nowISO = new Date().toISOString();
        const updaterEmail = currentUser?.email || '';
        const internalEvents = [];
        const tempAssignments = {};

        // Collect all orders & Apply Intimacy Note & Conflict Check
        const allOrders = data.projects.flatMap(proj =>
          proj.roles.flatMap((role, rIdx) =>
            role.castIds.map((cid, cIdx) => {
              const cast = cart[cid]?.cast;
              const isInternal = cast?.isInternal;

              // ★ インティマシーシーンありの場合、備考に追記
              let finalNote = role.note || '';
              if (data.intimacy) {
                finalNote = "【インティマシーシーンあり】\n" + finalNote;
              }

              // ★★★ 追加: 競合チェック (Conflict Check) for Drag & Drop Cart ★★★
              let conflictMsg = null;
              const targetEpoch = toEpochDay(shootDate);

              if (targetEpoch) {
                const conflict = castingData.find(c => {
                  // 1. ステータスチェック（キャンセル・NG・完了は無視）
                  if (['キャンセル', 'NG', 'キャスティング完了'].includes(c.status)) return false;

                  // 2. キャストIDチェック
                  if (c.castId !== cid) return false;

                  // 3. 日付重複チェック
                  const startEpoch = toEpochDay(c.startDate);
                  const endEpoch = toEpochDay(c.endDate);
                  if (startEpoch === null || endEpoch === null) return false;

                  // 範囲外なら無視
                  if (targetEpoch < startEpoch || targetEpoch > endEpoch) return false;

                  // 4. 「自分自身の更新」を除外するロジック
                  const isSameAccount = (c.accountName || '').trim() === (data.accountName || '').trim();
                  const isSameProject = (c.projectName || '').trim() === (proj.title || '').trim();

                  if (isSameAccount && isSameProject) {
                    return false; // 自分自身の追加オーダーなので競合ではない
                  }

                  // ここまで来たら競合
                  return true;
                });

                if (conflict) {
                  const holder = conflict.accountName || '他チーム';
                  conflictMsg = `※先に【${holder}】がキャスティングしています（${conflict.status}）。`;
                  console.warn("🚨 Conflict Detected (D&D):", {
                    me: { account: data.accountName, project: proj.title, date: shootDate },
                    other: { account: conflict.accountName, project: conflict.projectName, status: conflict.status }
                  });
                }
              }
              // ★★★ 追加ここまで ★★★

              return {
                castingId: 'temp_' + Date.now() + '_' + Math.random(),
                roleName: role.name,
                castName: cast?.name || '不明',
                rank: cIdx + 1,
                note: finalNote.trim(),
                projectName: proj.title,
                slack_user_id: isInternal ? cast.slackMentionId : null,
                castId: cid,
                cast: cast,
                type: role.type,
                conflictInfo: conflictMsg // ★追加: これでSlack通知にアラートが含まれます
              };
            })
          )
        );

        if (allOrders.length === 0) return;

        const uniqueProjectNames = [...new Set(data.projects.map(p => p.title))].join(' / ');

        // ★★★ 追加: ProjectIDに基づくスレッド自動引き当てロジック ★★★
        let targetThreadTs = data.slackThreadTs || null;
        let isAdditional = !!targetThreadTs; // 明示的に渡された場合は追加扱い

        // スレッドIDが未指定だが、ProjectID (=PageID) がある場合 -> 過去ログを検索
        // Note: processNewOrderFromModal passes 'pageId', not 'projectId'
        const searchProjectId = data.projectId || data.pageId;

        if (!targetThreadTs && searchProjectId) {
          // castingDataから「同じProjectID」かつ「スレッドIDを持っている」レコードを探す
          const existingRecord = castingData.find(c =>
            c.projectId === searchProjectId && c.slackThreadTs
          );

          if (existingRecord) {
            console.log("Found existing thread for ProjectID:", searchProjectId, existingRecord.slackThreadTs);
            targetThreadTs = existingRecord.slackThreadTs;
            isAdditional = true; // 自動引き当て成功 -> 追加オーダー扱い
          }
        }
        // ★★★ 追加ここまで ★★★

        // 2. Send Slack Notification Payload
        const payload = {
          accountName: data.accountName,
          projectName: uniqueProjectNames,
          projectId: data.pageId,
          dateRanges: [shootDate],
          orders: allOrders.map(o => ({
            castingId: o.castingId,
            roleName: o.roleName,
            castName: o.castName,
            rank: o.rank,
            note: o.note,
            projectName: o.projectName,
            slack_user_id: o.slack_user_id,
            conflictInfo: o.conflictInfo
          })),
          orderType: "pattern_a",
          ccString: data.ccString || "",
          slackThreadTs: targetThreadTs, // ★変更: 自動取得したIDを使用
          isAdditionalOrder: isAdditional // ★追加: フラグを送信
        };

        // PDF Upload - Multiple Files Support
        // まず退避データを確認し、なければDOMから取得（フォールバック）
        let files = cartMeta.pdfFiles;

        if (!files || files.length === 0) {
          const fileInput = document.getElementById('order-pdf-file');
          files = fileInput?.files;
        }

        const formData = new FormData();
        formData.append('payload_str', JSON.stringify(payload));

        if (files && files.length > 0) {
          for (let i = 0; i < files.length; i++) {
            formData.append('files', files[i], files[i].name);
          }
        }

        // Debug Log
        console.log("--- Sending Order ---", {
          threadTs: payload.slackThreadTs,
          conflictCheck: allOrders.map(o => o.conflictInfo).filter(Boolean)
        });

        let slackThreadTs = '';
        let slackPermalink = '';

        updateProgressBar("Slackに通知を送信中...", 30);

        try {
          const slackRes = await fetch('/api/notify/order_created', {
            method: 'POST',
            body: formData
          });

          if (!slackRes.ok) throw new Error('Slack notification failed');
          const slackData = await slackRes.json();

          // 追加オーダーの場合は元のスレッドIDを維持、新規なら新しいIDを採用
          slackThreadTs = data.slackThreadTs || slackData.ts;
          slackPermalink = slackData.permalink;
        } catch (e) {
          console.error("Slack notification error:", e);
        }

        updateProgressBar("スプレッドシートに書き込み中...", 60);

        // 3. Prepare Sheet Rows
        const newRows = [];
        const castGroups = new Map();
        allOrders.forEach(o => {
          if (!castGroups.has(o.castId)) castGroups.set(o.castId, []);
          castGroups.get(o.castId).push(o);
        });

        for (const [castId, orders] of castGroups) {
          const firstOrder = orders[0];
          const cast = firstOrder.cast;

          const mergedProjectName = [...new Set(orders.map(o => o.projectName))].join(' / ');
          const mergedRoleName = orders.map(o => o.roleName).join(' / ');
          const mergedType = [...new Set(orders.map(o => o.type))].join(' / ');
          const mergedNote = orders.map(o => o.note).filter(n => n).join(' / ');

          const minRank = Math.min(...orders.map(o => o.rank));
          const castingId = 'casting_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          const castPriority = getNextCastPriority(castId, shootDate, shootDate, tempAssignments);
          tempAssignments[`${castId}_${shootDate}_${shootDate}`] = castPriority;

          const initialStatus = cast.isInternal ? '打診中' : 'オーダー待ち';

          if (cast.isInternal) {
            internalEvents.push({
              accountName: data.accountName,
              projectName: mergedProjectName,
              roleName: mergedRoleName,
              mainSub: mergedType,
              castingId: castingId,
              status: initialStatus,
              start: shootDate,
              end: shootDate,
              email: cast.email,
            });
          }

          const structureData = orders.map(o => ({
            project: o.projectName,
            role: o.roleName,
            rank: o.rank,
            type: o.type,
            note: o.note
          }));
          const structureJson = JSON.stringify(structureData);

          newRows.push([
            castingId, data.accountName, mergedProjectName, mergedRoleName,
            cast.castId, cast.name, shootDate, shootDate, minRank.toString(),
            initialStatus, mergedNote, slackThreadTs, slackPermalink,
            mergedType, '', data.pageId, nowISO, updaterEmail, castPriority,
            cast.isInternal ? '内部' : '外部', cast.email || '', '', structureJson
          ]);
        }

        // 4. Batch Append
        if (newRows.length > 0) {
          const appendResult = await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID,
            range: 'キャスティングリスト!A2',
            valueInputOption: 'USER_ENTERED',
            insertDataOption: 'INSERT_ROWS',
            resource: { values: newRows }
          });

          const updatedRange = appendResult.result.updates.updatedRange;
          const match = updatedRange.match(/!A(\d+):/);
          if (match) {
            const startRow = parseInt(match[1], 10);
            const rowNumberByCastingId = new Map();
            for (let i = 0; i < newRows.length; i++) {
              if (newRows[i][0]) rowNumberByCastingId.set(newRows[i][0], startRow + i);
            }
            internalEvents.forEach(ev => {
              ev.rowNumber = rowNumberByCastingId.get(ev.castingId) || null;
            });
            await createInternalHoldEvents(internalEvents);
          }
        }
      }

      window.closeCartModal = function () {
        const modal = document.getElementById('cart-modal');
        if (!modal) return;

        // ★追加: カートを閉じる時に、保存されていたPDFファイル情報を確実にクリアする
        if (cartMeta && cartMeta.pdfFiles) {
          delete cartMeta.pdfFiles;
          console.log("PDF files cleared from memory.");
        }

        modal.classList.add('hidden');
        modal.innerHTML = '';
        // Reset state? Maybe keep it if user accidentally closes?
        // For now, let's keep it but maybe we should clear it on successful order.
      }

      function renderNewCartModal(modal) {
        let teamName = (currentUser?.name || '不明');
        let pageId = '未選択';

        if (selectedShooting) {
          teamName = selectedShooting.team;
          pageId = selectedShooting.pageId;
        } else if (isAdditionalOrderMode && additionalOrderContext) {
          teamName = additionalOrderContext.accountName;
          pageId = additionalOrderContext.projectId || '既存案件';
        }

        // Cast Pool: Show ALL casts in cart
        const allCartCastIds = Object.keys(cart);
        const poolCastIds = allCartCastIds;

        modal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl w-full max-w-6xl h-[90vh] flex flex-col">
            <div class="flex items-center justify-between p-4 border-b bg-gray-50">
              <div>
                <div class="text-sm text-gray-500">アカウント名: <span class="font-bold text-gray-800">${teamName}</span></div>
                <div class="text-sm text-gray-500">PageID: <span class="font-mono text-gray-800">${pageId}</span></div>
              </div>
              <button onclick="closeCartModal()" class="text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>

            <div class="flex-grow flex overflow-hidden">
              <div class="w-1/4 border-r bg-gray-50 flex flex-col">
                <div class="p-3 font-bold text-gray-700 border-b">キャストプール</div>
                
                <div id="cart-cast-pool" class="flex-grow overflow-y-auto p-2 space-y-2">
                  ${poolCastIds.map(cid => renderDraggableCast(cid)).join('')}
                  ${poolCastIds.length === 0 ? '<div class="text-xs text-gray-400 text-center mt-4">キャストがいません</div>' : ''}
                </div>

                <div class="p-3 border-t bg-gray-100">
                   <label class="text-xs font-bold text-gray-600 block mb-1">PDF添付 (任意):</label>
                   <input type="file" id="order-pdf-file" accept="application/pdf" multiple class="w-full text-xs text-gray-600 file:mr-2 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                </div>
              </div>

              <div class="w-3/4 flex flex-col bg-white">
                <div id="cart-projects-container" class="flex-grow overflow-y-auto p-4 space-y-6">
                  ${cartProjects.map(p => renderCartProject(p)).join('')}
                </div>
                
                <div class="p-4 border-t bg-gray-50 flex justify-center">
                  <button onclick="addCartProject()" class="flex items-center gap-2 text-blue-600 hover:text-blue-800 font-semibold">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    作品を追加
                  </button>
                </div>
              </div>
            </div>

            <div class="p-4 border-t bg-white flex justify-end items-center">
              <div class="flex gap-3">
                <button onclick="closeCartModal()" class="px-4 py-2 rounded-md border border-gray-300">閉じる</button>
                <button onclick="submitNewOrder()" class="px-6 py-2 rounded-md bg-blue-600 text-white font-bold shadow hover:bg-blue-700">
                  オーダー送信
                </button>
              </div>
            </div>
          </div>
        `;

        // Setup Drag & Drop
        setupDragAndDrop();
      }

      function renderDraggableCast(castId) {
        const c = cart[castId]?.cast;
        if (!c) return '';
        return `
          <div class="draggable-cast bg-white p-2 rounded shadow-sm border cursor-move flex items-center gap-2 hover:bg-blue-50 justify-between" draggable="true" data-cast-id="${castId}">
            <div class="flex items-center gap-2">
              <div class="w-8 h-8 rounded-full bg-gray-200 overflow-hidden flex-shrink-0">
                ${c.imageUrl ? `<img src="${c.imageUrl}" class="w-full h-full object-cover">` : ''}
              </div>
              <div class="text-sm truncate font-medium">${c.name}</div>
            </div>
            <button onclick="removeCastFromCart('${castId}')" class="text-gray-400 hover:text-red-500 text-xs font-bold px-1" title="カートから削除">✕</button>
          </div>
        `;
      }

      window.removeCastFromCart = function (castId) {
        if (cart[castId]) {
          delete cart[castId];

          // ★追加修正: cartProjects (右側の作品・役リスト) からもこのキャストIDを除去する
          if (cartProjects && cartProjects.length > 0) {
            cartProjects.forEach(proj => {
              if (proj.roles) {
                proj.roles.forEach(role => {
                  if (role.castIds) {
                    role.castIds = role.castIds.filter(id => id !== castId);
                  }
                });
              }
            });
          }

          updateCartCount();
          renderCartModal(); // 再描画してプールと配置を更新
          displayAvailableCasts();
        }
      };

      function renderCartProject(project) {
        // ★修正: 作品数が1つしかない場合は削除ボタンを表示しない（または無効化）
        const canDelete = cartProjects.length > 1;

        const deleteButtonHtml = canDelete
          ? `<button onclick="removeCartProject('${project.id}')" class="text-red-400 hover:text-red-600 p-1" title="作品を削除">
               <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
             </button>`
          : `<button class="text-gray-300 p-1 cursor-not-allowed" title="これ以上削除できません" disabled>
               <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
             </button>`;

        return `
          <div class="border rounded-lg p-4 bg-gray-50 relative group" data-project-id="${project.id}">
            <div class="mb-3 flex items-center gap-2">
              <label class="text-sm font-bold text-gray-600 w-16">作品名</label>
              <input type="text" class="flex-grow border rounded px-2 py-1 text-sm font-bold" 
                     value="${project.title}" onchange="updateProjectTitle('${project.id}', this.value)" placeholder="作品名を入力">
              
              ${deleteButtonHtml}
            </div>

            <div class="space-y-3 pl-4 border-l-2 border-gray-200">
              ${project.roles.map((role, idx) => renderCartRole(project.id, role, idx)).join('')}
            </div>

            <div class="mt-3 pl-4">
              <button onclick="addCartRole('${project.id}')" class="text-sm text-blue-600 hover:text-blue-800 flex items-center gap-1">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                役名を追加
              </button>
            </div>
          </div>
        `;
      }

      function renderCartRole(projectId, role, index) {
        const rankLabel = `第${index + 1}候補`; // Or just sequential? User said "左から順に第1候補、第2候補" but UI is vertical list of roles?
        // Wait, "作品名...役名...〇〇 / 〇〇 / 〇〇（ドラッグ&ドロップで追加する形）"
        // Ah, one role can have multiple candidates (1st, 2nd...)?
        // "そのカラムは第１候補となっていて、カートに追加された人をドラッグして追加できる。"
        // "左から順に第1候補、第2候補として保存する。"
        // So: Role Row -> [Candidate 1] [Candidate 2] ...

        return `
          <div class="bg-white border rounded p-3 shadow-sm" data-role-id="${role.id}">
            <div class="flex items-center gap-2 mb-2">
              <input type="text" class="border rounded px-2 py-1 text-sm w-1/3" 
                     value="${role.name}" onchange="updateRoleName('${projectId}', '${role.id}', this.value)" placeholder="役名">
              
              <select class="border rounded px-2 py-1 text-sm w-24" onchange="updateRoleType('${projectId}', '${role.id}', this.value)">
                <option value="メイン" ${role.type === 'メイン' ? 'selected' : ''}>メイン</option>
                <option value="その他" ${role.type === 'その他' ? 'selected' : ''}>その他</option>
              </select>

              <input type="text" class="flex-grow border rounded px-2 py-1 text-sm" 
                     value="${role.note}" onchange="updateRoleNote('${projectId}', '${role.id}', this.value)" placeholder="備考">

              <button onclick="removeCartRole('${projectId}', '${role.id}')" class="text-gray-400 hover:text-red-500">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>

            <!-- Drop Zone for Candidates -->
            <div class="role-drop-zone min-h-[50px] bg-gray-50 border-2 border-dashed border-gray-200 rounded flex items-center gap-2 p-2 overflow-x-auto"
                 data-project-id="${projectId}" data-role-id="${role.id}">
              ${role.castIds.map((cid, cIdx) => `
                <div class="relative group bg-white border rounded px-2 py-1 flex items-center gap-2 shadow-sm min-w-[100px]">
                  <span class="text-xs font-bold text-gray-500 mr-1">${cIdx + 1}</span>
                  <span class="text-sm truncate max-w-[100px]">${cart[cid]?.cast?.name}</span>
                  <button onclick="removeCastFromRole('${projectId}', '${role.id}', '${cid}')" class="ml-auto text-gray-400 hover:text-red-500">
                    &times;
                  </button>
                </div>
              `).join('')}
              <div class="text-xs text-gray-400 italic flex-shrink-0">ここへドラッグ</div>
            </div>
`;
      }

      // --- State Updaters ---
      window.addCartProject = function () {
        const newProj = {
          id: 'proj_' + Date.now(),
          title: '',
          roles: []
        };
        // Default 3 roles
        for (let i = 0; i < 3; i++) {
          newProj.roles.push({
            id: 'role_' + Date.now() + '_' + i,
            name: '',
            type: 'その他',
            note: '',
            castIds: []
          });
        }
        cartProjects.push(newProj);
        renderCartModal();
      };

      // Initialize cartProjects with default state if empty
      function initCartProjects() {
        if (cartProjects.length === 0) {
          for (let i = 0; i < 2; i++) {
            window.addCartProject(); // Use window.addCartProject to ensure it's called correctly
          }
        }
      }
      window.removeCartProject = function (pid) {
        // ★修正: 作品数が1つ以下の場合は削除させない
        if (cartProjects.length <= 1) {
          showMessage('作品はこれ以上削除できません。', 'error');
          return;
        }

        cartProjects = cartProjects.filter(p => p.id !== pid);
        renderCartModal();
      };
      window.updateProjectTitle = function (pid, val) {
        const p = cartProjects.find(p => p.id === pid); if (p) p.title = val;
      };
      window.addCartRole = function (pid) {
        const p = cartProjects.find(p => p.id === pid);
        if (p) {
          p.roles.push({ id: 'role_' + Date.now(), name: '', type: 'その他', note: '', castIds: [] });
          renderCartModal();
        }
      };
      window.removeCartRole = function (pid, rid) {
        const p = cartProjects.find(p => p.id === pid);
        if (p) {
          p.roles = p.roles.filter(r => r.id !== rid);
          renderCartModal();
        }
      };
      window.updateRoleName = function (pid, rid, val) {
        const r = findRole(pid, rid); if (r) r.name = val;
      };
      window.updateRoleType = function (pid, rid, val) {
        const r = findRole(pid, rid); if (r) r.type = val;
      };
      window.updateRoleNote = function (pid, rid, val) {
        const r = findRole(pid, rid); if (r) r.note = val;
      };
      window.removeCastFromRole = function (pid, rid, cid) {
        const r = findRole(pid, rid);
        if (r) {
          r.castIds = r.castIds.filter(id => id !== cid);
          renderCartModal();
        }
      };

      function findRole(pid, rid) {
        const p = cartProjects.find(p => p.id === pid);
        return p ? p.roles.find(r => r.id === rid) : null;
      }

      // --- Drag & Drop Handlers ---
      function setupDragAndDrop() {
        const draggables = document.querySelectorAll('.draggable-cast');
        const dropZones = document.querySelectorAll('.role-drop-zone');

        draggables.forEach(d => {
          d.addEventListener('dragstart', e => {
            e.dataTransfer.setData('text/plain', d.dataset.castId);
            d.classList.add('opacity-50');
          });
          d.addEventListener('dragend', e => {
            d.classList.remove('opacity-50');
          });
        });

        dropZones.forEach(z => {
          z.addEventListener('dragover', e => {
            e.preventDefault(); // Allow drop
            z.classList.add('bg-blue-50', 'border-blue-300');
          });
          z.addEventListener('dragleave', e => {
            z.classList.remove('bg-blue-50', 'border-blue-300');
          });
          z.addEventListener('drop', e => {
            e.preventDefault();
            z.classList.remove('bg-blue-50', 'border-blue-300');
            const castId = e.dataTransfer.getData('text/plain');
            const pid = z.dataset.projectId;
            const rid = z.dataset.roleId;

            if (castId && pid && rid) {
              const role = findRole(pid, rid);
              if (role && !role.castIds.includes(castId)) {
                role.castIds.push(castId);
                renderCartModal();
              }
            }
          });
        });
      }



      // C-2: 新規外部キャスト作成モーダル
      async function openNewExternalCastModal() {
        const modal = document.getElementById('new-external-cast-modal');
        if (!modal) return;

        modal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl max-w-md w-full p-5">
        <div class="flex items-center justify-between mb-3">
          <h3 class="text-lg font-bold">新規外部キャストを追加</h3>
          <button id="new-cast-close" class="text-gray-600 hover:text-gray-800">&times;</button>
        </div>
        <div class="space-y-3">
          <div>
            <label class="text-sm text-gray-700">名前（必須）</label>
            <input id="new-cast-name" type="text" class="mt-1 w-full p-2 border rounded-md" />
          </div>
          <div>
            <label class="text-sm text-gray-700">性別</label>
            <select id="new-cast-gender" class="mt-1 w-full p-2 border rounded-md">
              <option value="">未選択</option>
              <option value="男性">男性</option>
              <option value="女性">女性</option>
            </select>
          </div>
          <div>
            <label class="text-sm text-gray-700">所属</label>
            <input id="new-cast-agency" type="text" class="mt-1 w-full p-2 border rounded-md" placeholder="例：フリー / 〇〇プロダクション" />
          </div>
          <div>
            <label class="text-sm text-gray-700">メールアドレス</label>
            <input id="new-cast-email" type="email" class="mt-1 w-full p-2 border rounded-md" />
          </div>
          <div>
            <label class="text-sm text-gray-700">備考</label>
            <textarea id="new-cast-notes" class="mt-1 w-full p-2 border rounded-md" rows="2"></textarea>
          </div>
        </div>
        <div class="mt-4 flex justify-end gap-3">
          <button id="new-cast-cancel" class="px-4 py-2 rounded-md border border-gray-300">キャンセル</button>
          <button id="new-cast-save" class="px-4 py-2 rounded-md bg-blue-600 text-white font-semibold">保存</button>
        </div>
      </div>`;

        modal.classList.remove('hidden');

        modal.querySelector('#new-cast-close')?.addEventListener('click', () => closeNewExternalCastModal());
        modal.querySelector('#new-cast-cancel')?.addEventListener('click', () => closeNewExternalCastModal());
        modal.querySelector('#new-cast-save')?.addEventListener('click', async () => {
          await saveNewExternalCast();
        });
      }

      function closeNewExternalCastModal() {
        const modal = document.getElementById('new-external-cast-modal');
        if (!modal) return;
        modal.classList.add('hidden');
        modal.innerHTML = '';
      }

      async function saveNewExternalCast() {
        const name = document.getElementById('new-cast-name').value.trim();
        if (!name) {
          showMessage('名前は必須です。', 'error');
          return;
        }
        const gender = document.getElementById('new-cast-gender').value;
        const agency = document.getElementById('new-cast-agency').value.trim() || '外部';
        const email = document.getElementById('new-cast-email').value.trim();
        const notes = document.getElementById('new-cast-notes').value.trim();

        // 新規 castId は簡易に "ext_" + timestamp で生成
        const castId = 'ext_' + Date.now();

        try {
          showLoader(true);
          // スプレッドシート "キャストリスト" に 1 行追加
          await gapi.client.sheets.spreadsheets.values.append({
            spreadsheetId: SPREADSHEET_ID,
            range: 'キャストリスト!A2',
            valueInputOption: 'USER_ENTERED',
            insertDataOption: 'INSERT_ROWS',
            resource: {
              values: [[
                castId,      // A: キャストID
                name,        // B: 名前
                gender,      // C: 性別
                '',          // D: 生年月日（未入力）
                agency,      // E: 事務所
                '',          // F: 画像URL
                0,           // G: 出演回数
                email,       // H: メール
                notes,       // I: 備考
                '外部',      // J: 内部/外部フラグ
                ''           // K: SlackメンションID
              ]]
            }
          });

          // ローカルの castData にも追加
          const newCast = {
            castId, name, gender, dateOfBirth: '', age: null,
            agency, imageUrl: '', appearanceCount: 0, email, notes,
            castType: '外部',
            isInternal: false,
            internalType: '外部',
            slackMentionId: '',
          };
          castData.push(newCast);

          // B: 作成と同時にカートへ追加
          addToCart(newCast.castId);

          closeNewExternalCastModal();
          showMessage('外部キャストをカートに追加しました。');
          displayAvailableCasts();
        } catch (e) {
          console.error(e);
          showMessage('外部キャストの追加に失敗しました。', 'error');
        } finally {
          showLoader(false);
        }
      }

      // ========= Cart Step1 / Step2 =========
      function renderCartStep1(modal) {
        modal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl w-full max-w-lg mx-4 p-6 relative">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-xl font-bold">STEP1：オーダー情報の入力</h3>
              <button id="cart-step1-close" class="absolute top-4 right-4 text-gray-500 hover:text-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>
            <div class="mb-4">
              <label class="block text-sm font-medium text-gray-700 mb-1">アカウント名（必須）</label>
              <input type="text" id="cart-account" class="w-full border rounded px-3 py-2" placeholder="アカウント名" value="${cartMeta.account || ''}">
            </div>
            <div class="grid grid-cols-1 gap-3 mb-4">
              <div>
                <label class="text-sm font-medium text-gray-700 mb-1">作品名1（必須）</label>
                <input type="text" id="cart-project-1" class="w-full border rounded px-3 py-2" placeholder="作品名1" value="${cartMeta.projectNames?.[0] || ''}">
              </div>
              <div>
                <label class="text-sm font-medium text-gray-700 mb-1">作品名2（任意）</label>
                <input type="text" id="cart-project-2" class="w-full border rounded px-3 py-2" placeholder="作品名2" value="${cartMeta.projectNames?.[1] || ''}">
              </div>
              <div>
                <label class="text-sm font-medium text-gray-700 mb-1">作品名3（任意）</label>
                <input type="text" id="cart-project-3" class="w-full border rounded px-3 py-2" placeholder="作品名3" value="${cartMeta.projectNames?.[2] || ''}">
              </div>
              <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">Notion URL (任意)</label>
                <input type="text" id="cart-notion" class="w-full border rounded px-3 py-2" placeholder="https://www.notion.so/..." value="${cartMeta.notionUrl || ''}">
              </div>
              <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-1">PDFファイル添付 (任意)</label>
                <input type="file" id="cart-pdf-file" accept="application/pdf" multiple class="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                <p class="text-xs text-gray-500 mt-1">※Slack通知のスレッドにアップロードされます。</p>
              </div>
              <div class="flex justify-end">
                <button id="cart-step1-next" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">次へ</button>
              </div>
            </div>
          </div>
        `;
        modal.classList.remove('hidden');

        // Restore file input if exists in memory (Note: file input value cannot be set programmatically for security, so we just keep the object in cartMeta)
        // If user re-selects, we update.

        modal.querySelector('#cart-step1-close')?.addEventListener('click', () => closeCartModal());

        modal.querySelector('#cart-step1-next').addEventListener('click', () => {
          const acc = document.getElementById('cart-account').value.trim();
          const p1 = document.getElementById('cart-project-1').value.trim();
          const p2 = document.getElementById('cart-project-2').value.trim();
          const p3 = document.getElementById('cart-project-3').value.trim();
          const not = document.getElementById('cart-notion').value.trim();
          const fileInput = document.getElementById('cart-pdf-file');

          if (!acc) { alert('アカウント名は必須です'); return; }
          if (!p1 && !p2 && !p3) { alert('作品名は少なくとも1つ入力してください'); return; }

          cartMeta.account = acc;
          cartMeta.projectNames = [p1, p2, p3];
          cartMeta.notionUrl = not;

          if (fileInput.files.length > 0) {
            cartMeta.pdfFiles = fileInput.files;
          }

          // A-1: 組み合わせ作品名を生成
          const baseTitles = cartMeta.projectNames
            .map(t => (t || '').trim())
            .filter(t => t);

          const comboTitles = [];
          // 2作品の組み合わせ
          if (baseTitles.length > 1) {
            for (let i = 0; i < baseTitles.length; i++) {
              for (let j = i + 1; j < baseTitles.length; j++) {
                comboTitles.push(`${baseTitles[i]}/${baseTitles[j]}`);
              }
            }
          }
          // 3作品すべての組み合わせ
          if (baseTitles.length === 3) {
            comboTitles.push(`${baseTitles[0]}/${baseTitles[1]}/${baseTitles[2]}`);
          }
          cartMeta.combinedProjectNames = comboTitles;

          cartStep = 2;
          renderCartModal();
        });
      }


      function renderCartStep2(modal) {
        const items = Object.values(cart);

        // A-2.1: 単体作品と組み合わせ作品を候補リスト化
        const baseTitles = (cartMeta.projectNames || []).map(t => t.trim()).filter(t => t);
        const comboTitles = cartMeta.combinedProjectNames || [];
        const allTitles = [...baseTitles, ...comboTitles];

        const projectOptions = allTitles
          .map(p => `<option value="${p}">${p}</option>`)
          .join('');

        modal.innerHTML = `
          <div class="bg-white rounded-lg shadow-xl w-full max-w-lg mx-4 p-6 relative">
             <h3 class="text-xl font-bold mb-4">STEP2：キャスト情報の紐付け</h3>
             <button class="absolute top-4 right-4 text-gray-500 hover:text-gray-700" onclick="closeCartModal()">&times;</button>
             <div class="space-y-4 max-h-[60vh] overflow-y-auto p-2">
          <table class="min-w-full text-sm">
            <thead>
              <tr class="bg-gray-100">
                <th class="px-4 py-2 text-left">キャスト名</th>
                <th class="px-4 py-2 text-left">作品名</th>
                <th class="px-4 py-2 text-left">区分</th>
                <th class="px-4 py-2 text-left">役名</th>
                <th class="px-4 py-2 text-left">候補順位</th>
                <th class="py-2 px-3 text-left">備考</th>
                <th class="py-2 px-3 text-center">削除</th>
              </tr>
            </thead>
            <tbody>
              ${items.map((item, i) => `
                <tr class="border-b" data-cart-item-id="${item.cast.castId}">
                  <td class="px-4 py-2 font-bold">${item.cast.name}</td>
                  <td class="py-2 px-3">
                    <select class="cart-item-project w-full p-1 border rounded">
                      <option value="">作品を選択</option>
                      ${projectOptions}
                    </select>
                  </td>
                  <td class="px-4 py-2">
                    <select class="cart-item-mainsub border rounded px-2 py-1" data-idx="${i}">
                        <option value="その他" ${item.mainSub === 'その他' ? 'selected' : ''}>その他</option>
                        <option value="メイン" ${item.mainSub === 'メイン' ? 'selected' : ''}>メイン</option>
                    </select>
                  </td>
                  <td class="py-2 px-3">
                    <input type="text" class="cart-item-role w-full p-1 border rounded"
                           value="${item.roleName || ''}" placeholder="役名を入力（例：女1）">
                  </td>
                  <td class="py-2 px-3">
                    <input type="number" class="cart-item-rank w-20 p-1 border rounded"
                           value="${item.rank || 1}" min="1">
                  </td>
                  <td class="py-2 px-3">
                    <input type="text" class="cart-item-note w-full p-1 border rounded"
                           value="${item.note || ''}" placeholder="備考">
                  </td>
                  <td class="py-2 px-3 text-center">
                    <button class="cart-item-remove text-red-500 hover:text-red-700">
                      &times;
                    </button>
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
        <div class="mt-6 flex justify-between">
          <button id="cart-step2-back"
                  class="px-4 py-2 border rounded">戻る</button>
          <button id="cart-step2-confirm"
                  class="px-4 py-2 bg-blue-600 text-white rounded">
            内容を確認して確定へ
          </button>
        </div>
      </div>
    `;

        modal.classList.remove('hidden');

        // イベントリスナー
        modal.querySelector('#cart-step2-back')
          .addEventListener('click', () => {
            cartStep = 1;
            renderCartModal();
          });

        modal.querySelector('#cart-step2-confirm')
          .addEventListener('click', () => {
            // 最終確認モーダルを開く
            renderConfirmationModal();
          });

        modal.querySelectorAll('[data-cart-item-id]').forEach(row => {
          const castId = row.dataset.cartItemId;
          const item = cart[castId];
          if (!item) return;

          const projectEl = row.querySelector('.cart-item-project');
          const roleEl = row.querySelector('.cart-item-role');
          const rankEl = row.querySelector('.cart-item-rank');
          const noteEl = row.querySelector('.cart-item-note');
          const removeEl = row.querySelector('.cart-item-remove');

          // 初期値設定
          if (projectEl) {
            // item.projectName があればそれを選択、なければ基本作品の先頭
            projectEl.value = item.projectName || baseTitles[0] || '';
            // 初期読み込み時にもプレースホルダーを更新
            if (roleEl) {
              roleEl.placeholder = (projectEl.value || '').includes('/')
                ? "役名をスラッシュ区切りで入力（例：女1/友達）"
                : "役名を入力（例：女1）";
            }
          }

          // イベント
          projectEl.addEventListener('change', e => {
            item.projectName = e.target.value;
            // A-2.3: プレースホルダーを更新
            if (roleEl) {
              roleEl.placeholder = (e.target.value || '').includes('/')
                ? "役名をスラッシュ区切りで入力（例：女1/友達）"
                : "役名を入力（例：女1）";
            }
          });

          // ★追加: メイン/その他の変更を検知して保存する
          const mainSubEl = row.querySelector('.cart-item-mainsub');
          if (mainSubEl) {
            mainSubEl.addEventListener('change', e => {
              item.mainSub = e.target.value;
            });
          }
          // ★追加ここまで

          roleEl.addEventListener('input', e => {
            item.roleName = e.target.value;
          });
          rankEl.addEventListener('input', e => {
            item.rank = parseInt(e.target.value, 10) || 1;
          });
          noteEl.addEventListener('input', e => {
            item.note = e.target.value;
          });
          removeEl.addEventListener('click', () => {
            delete cart[castId];
            updateCartCount();
            renderCartModal();
            displayAvailableCasts();
          });
        });
      }
      // ========= Events =========
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          if (btn.id === 'nav-cart') return; // cartは別処理
          const viewId = btn.id.replace('nav-', '') + '-view';
          switchView(viewId);

          if (viewId === 'status-view') {
            await renderCastingStatusView(true);
          } else if (viewId === 'management-view') {
            if (isAdmin) {
              // 管理画面を開いたら、デフォルトで撮影連絡ページを表示
              showShootContactPage();
            } else {
              document.getElementById('management-view').innerHTML = '<p class="text-gray-600">管理者権限がありません。</p>';
            }
          }
        });
      });

      document.getElementById('shooting-contact-btn')?.addEventListener('click', showShootContactPage);

      // (1790行目付近の nav-cart イベントリスナーは残す)
      // (1790行目付近の nav-cart イベントリスナーは残す)
      document.getElementById('nav-cart')?.addEventListener('click', e => {
        e.preventDefault();

        // 撮影が選択されていない場合の分岐
        if (!selectedShooting) {
          document.getElementById('no-shooting-popup').classList.remove('hidden');
          return;
        }

        const modal = document.getElementById('cart-modal');
        if (!modal) return;

        if (!cartMeta.projectNames[0]) {
          cartStep = 1;
        } else {
          cartStep = 2;
        }
        modal.classList.remove('hidden');
        renderCartModal();
      });

      // No Shooting Popup Events
      document.getElementById('btn-popup-back')?.addEventListener('click', () => {
        document.getElementById('no-shooting-popup').classList.add('hidden');
      });

      document.getElementById('btn-order-external')?.addEventListener('click', () => {
        openSpecialOrderModal('external');
      });

      document.getElementById('btn-order-internal')?.addEventListener('click', () => {
        openSpecialOrderModal('internal');
      });

      // Special Order Logic
      let currentSpecialOrderType = 'external';

      function openSpecialOrderModal(type) {
        document.getElementById('no-shooting-popup').classList.add('hidden');
        const modal = document.getElementById('special-order-modal');
        modal.classList.remove('hidden');
        currentSpecialOrderType = type;

        document.getElementById('special-order-title').textContent = type === 'external' ? '外部案件オーダー' : '社内イベントオーダー';

        // Handle Dates
        const dateListEl = document.getElementById('special-order-date-list');
        const datesJsonEl = document.getElementById('special-order-dates-json');

        // Use selectedDates if available, otherwise default to today
        let targetDates = selectedDates.length > 0 ? [...selectedDates] : [new Date().toISOString().split('T')[0]];
        targetDates.sort();

        dateListEl.textContent = targetDates.join(', ');
        datesJsonEl.value = JSON.stringify(targetDates);

        // Cast List
        const castListEl = document.getElementById('special-order-cast-list');
        const castNames = Object.values(cart).map(c => c.cast?.name || c.castName || '不明').join(', ');
        castListEl.textContent = castNames || 'キャストが選択されていません';
      }

      document.getElementById('btn-special-cancel')?.addEventListener('click', () => {
        document.getElementById('special-order-modal').classList.add('hidden');
      });

      document.getElementById('btn-special-submit')?.addEventListener('click', async () => {
        const title = document.getElementById('special-order-name').value;
        const datesJson = document.getElementById('special-order-dates-json').value;
        const start = document.getElementById('special-order-start').value;
        const end = document.getElementById('special-order-end').value;
        const castIds = Object.keys(cart);

        if (!title || !datesJson || !start || !end) {
          alert('すべての項目を入力してください');
          return;
        }
        if (castIds.length === 0) {
          alert('キャストが選択されていません。カートにキャストを追加してください。');
          return;
        }

        const dates = JSON.parse(datesJson);
        const userEmail = currentUser?.email || 'unknown@example.com';

        showProgressBar("処理を開始します...", 10);

        try {
          const payload = {
            orderType: currentSpecialOrderType,
            title: title,
            dates: dates, // Changed from date to dates
            startTime: start,
            endTime: end,
            castIds: castIds,
            ordererEmail: userEmail
          };

          updateProgressBar("オーダー送信中...", 50);

          const res = await fetch('/api/notify/special_order', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!res.ok) throw new Error('Order failed');

          // ★追加: レスポンスデータの取得とカレンダー登録
          const data = await res.json();

          if (data.calendar_events && data.calendar_events.length > 0) {
            updateProgressBar("カレンダー登録中...", 80);
            console.log("Creating calendar events:", data.calendar_events);
            // 既存の関数を使ってカレンダー登録＆シート書き戻し
            await createInternalHoldEvents(data.calendar_events);
          }

          updateProgressBar("完了しました", 100);
          await new Promise(r => setTimeout(r, 500));

          document.getElementById('special-order-modal').classList.add('hidden');
          cart = {};
          updateCartCount();
          displayAvailableCasts();
          showMessage('オーダーを送信しました', 'success');

          // データ再読み込みして表示更新
          setTimeout(() => {
            // ★もしタブがcastingならspecialに切り替えてあげる
            if (window.currentStatusTab !== 'special') {
              window.currentStatusTab = 'special';
              switchView('status-view');
            }
            renderCastingStatusView(true);
          }, 1500);

        } catch (e) {
          console.error(e);
          showMessage('送信に失敗しました', 'error');
        } finally {
          hideProgressBar();
        }
      });

      document.getElementById('authorize_button')?.addEventListener('click', handleAuthClick);
      document.getElementById('signout_button')?.addEventListener('click', handleSignoutClick);

      document.getElementById('prev-month')?.addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() - 1); renderCalendar(); });
      document.getElementById('next-month')?.addEventListener('click', () => { calendarDate.setMonth(calendarDate.getMonth() + 1); renderCalendar(); });

      document.getElementById('calendar-grid')?.addEventListener('click', e => {
        const cell = e.target.closest('.calendar-day'); if (!cell?.dataset.date) return;
        const date = cell.dataset.date;
        const idx = selectedDates.indexOf(date);
        if (idx > -1) selectedDates.splice(idx, 1); else selectedDates.push(date);
        selectedDates.sort();
        renderCalendar(); updateSelectedPeriodDisplay();
        renderShootingList(); // Show existing shootings for selected date
        displayAvailableCasts();
      });

      document.body.addEventListener('input', e => { if (e.target.closest('#cast-filters-container')) displayAvailableCasts(); });

      document.body.addEventListener('click', e => {
        const btn = e.target.closest('.add-to-cart-btn'); if (!btn) return;
        addToCart(btn.getAttribute('data-cast-id'));
      });

      // D-2: ビューモード切り替えボタンのイベント
      document.getElementById('view-mode-comfort')?.addEventListener('click', () => {
        if (viewMode === 'comfort') return;
        viewMode = 'comfort';
        displayAvailableCasts();
      });
      document.getElementById('view-mode-dense')?.addEventListener('click', () => {
        if (viewMode === 'dense') return;
        viewMode = 'dense';
        displayAvailableCasts();
      });

      // Load GAPI & GIS
      const gapiScript = document.createElement('script'); gapiScript.src = 'https://apis.google.com/js/api.js'; gapiScript.async = true; gapiScript.defer = true; gapiScript.onload = gapiLoaded;
      const gisScript = document.createElement('script'); gisScript.src = 'https://accounts.google.com/gsi/client'; gisScript.async = true; gisScript.defer = true; gisScript.onload = gisLoaded;

      document.head.appendChild(gapiScript);
      document.head.appendChild(gisScript); // ★ここを修正しました
    });

  </script>
</body>

</html>